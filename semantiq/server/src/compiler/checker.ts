import * as qb from './base';
import * as qt from './types';
import { Node } from './types';
import * as syntax from './syntax';
import { Syntax } from './syntax';
import { diags as qd } from './diags';
function isTypeDeclaration(
  n: Node
): n is TypeParameterDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ImportClause | ImportSpecifier | ExportSpecifier {
  switch (n.kind) {
    case Syntax.TypeParameter:
    case Syntax.ClassDeclaration:
    case Syntax.InterfaceDeclaration:
    case Syntax.TypeAliasDeclaration:
    case Syntax.EnumDeclaration:
      return true;
    case Syntax.ImportClause:
      return (n as ImportClause).isTypeOnly;
    case Syntax.ImportSpecifier:
    case Syntax.ExportSpecifier:
      return (n as ImportSpecifier | ExportSpecifier).parent.parent.isTypeOnly;
    default:
      return false;
  }
}
function isTypeDeclarationName(n: Node) {
  return n.kind === Syntax.Identifier && n.parent && isTypeDeclaration(n.parent) && n.parent.name === n;
}
export function canHaveExportModifier(n: Statement) {
  return (
    qc.is.kind(EnumDeclaration, n) ||
    qc.is.kind(VariableStatement, n) ||
    qc.is.kind(FunctionDeclaration, n) ||
    qc.is.kind(ClassDeclaration, n) ||
    (qc.is.kind(ModuleDeclaration, n) && !qc.is.externalModuleAugmentation(n) && !isGlobalScopeAugmentation(n)) ||
    qc.is.kind(InterfaceDeclaration, n) ||
    isTypeDeclaration(n)
  );
}
const ambientModuleSymbolRegex = /^".+"$/;
const anon = '(anonymous)' as __String & string;
let nextMergeId = 1;
let nextFlowId = 1;
const enum IterationUse {
  AllowsSyncIterablesFlag = 1 << 0,
  AllowsAsyncIterablesFlag = 1 << 1,
  AllowsStringInputFlag = 1 << 2,
  ForOfFlag = 1 << 3,
  YieldStarFlag = 1 << 4,
  SpreadFlag = 1 << 5,
  DestructuringFlag = 1 << 6,
  Element = AllowsSyncIterablesFlag,
  Spread = AllowsSyncIterablesFlag | SpreadFlag,
  Destructuring = AllowsSyncIterablesFlag | DestructuringFlag,
  ForOf = AllowsSyncIterablesFlag | AllowsStringInputFlag | ForOfFlag,
  ForAwaitOf = AllowsSyncIterablesFlag | AllowsAsyncIterablesFlag | AllowsStringInputFlag | ForOfFlag,
  YieldStar = AllowsSyncIterablesFlag | YieldStarFlag,
  AsyncYieldStar = AllowsSyncIterablesFlag | AllowsAsyncIterablesFlag | YieldStarFlag,
  GeneratorReturnType = AllowsSyncIterablesFlag,
  AsyncGeneratorReturnType = AllowsAsyncIterablesFlag,
}
const enum IterationTypeKind {
  Yield,
  Return,
  Next,
}
interface IterationTypesResolver {
  iterableCacheKey: 'iterationTypesOfAsyncIterable' | 'iterationTypesOfIterable';
  iteratorCacheKey: 'iterationTypesOfAsyncIterator' | 'iterationTypesOfIterator';
  iteratorSymbolName: 'asyncIterator' | 'iterator';
  getGlobalIteratorType: (reportErrors: boolean) => GenericType;
  getGlobalIterableType: (reportErrors: boolean) => GenericType;
  getGlobalIterableIteratorType: (reportErrors: boolean) => GenericType;
  getGlobalGeneratorType: (reportErrors: boolean) => GenericType;
  resolveIterationType: (type: Type, errorNode: Node | undefined) => Type | undefined;
  mustHaveANextMethodDiagnostic: DiagnosticMessage;
  mustBeAMethodDiagnostic: DiagnosticMessage;
  mustHaveAValueDiagnostic: DiagnosticMessage;
}
const enum WideningKind {
  Normal,
  FunctionReturn,
  GeneratorNext,
  GeneratorYield,
}
const enum TypeFacts {
  None = 0,
  TypeofEQString = 1 << 0,
  TypeofEQNumber = 1 << 1,
  TypeofEQBigInt = 1 << 2,
  TypeofEQBoolean = 1 << 3,
  TypeofEQSymbol = 1 << 4,
  TypeofEQObject = 1 << 5,
  TypeofEQFunction = 1 << 6,
  TypeofEQHostObject = 1 << 7,
  TypeofNEString = 1 << 8,
  TypeofNENumber = 1 << 9,
  TypeofNEBigInt = 1 << 10,
  TypeofNEBoolean = 1 << 11,
  TypeofNESymbol = 1 << 12,
  TypeofNEObject = 1 << 13,
  TypeofNEFunction = 1 << 14,
  TypeofNEHostObject = 1 << 15,
  EQUndefined = 1 << 16,
  EQNull = 1 << 17,
  EQUndefinedOrNull = 1 << 18,
  NEUndefined = 1 << 19,
  NENull = 1 << 20,
  NEUndefinedOrNull = 1 << 21,
  Truthy = 1 << 22,
  Falsy = 1 << 23,
  All = (1 << 24) - 1,
  BaseStringStrictFacts = TypeofEQString |
    TypeofNENumber |
    TypeofNEBigInt |
    TypeofNEBoolean |
    TypeofNESymbol |
    TypeofNEObject |
    TypeofNEFunction |
    TypeofNEHostObject |
    NEUndefined |
    NENull |
    NEUndefinedOrNull,
  BaseStringFacts = BaseStringStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
  StringStrictFacts = BaseStringStrictFacts | Truthy | Falsy,
  StringFacts = BaseStringFacts | Truthy,
  EmptyStringStrictFacts = BaseStringStrictFacts | Falsy,
  EmptyStringFacts = BaseStringFacts,
  NonEmptyStringStrictFacts = BaseStringStrictFacts | Truthy,
  NonEmptyStringFacts = BaseStringFacts | Truthy,
  BaseNumberStrictFacts = TypeofEQNumber |
    TypeofNEString |
    TypeofNEBigInt |
    TypeofNEBoolean |
    TypeofNESymbol |
    TypeofNEObject |
    TypeofNEFunction |
    TypeofNEHostObject |
    NEUndefined |
    NENull |
    NEUndefinedOrNull,
  BaseNumberFacts = BaseNumberStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
  NumberStrictFacts = BaseNumberStrictFacts | Truthy | Falsy,
  NumberFacts = BaseNumberFacts | Truthy,
  ZeroNumberStrictFacts = BaseNumberStrictFacts | Falsy,
  ZeroNumberFacts = BaseNumberFacts,
  NonZeroNumberStrictFacts = BaseNumberStrictFacts | Truthy,
  NonZeroNumberFacts = BaseNumberFacts | Truthy,
  BaseBigIntStrictFacts = TypeofEQBigInt |
    TypeofNEString |
    TypeofNENumber |
    TypeofNEBoolean |
    TypeofNESymbol |
    TypeofNEObject |
    TypeofNEFunction |
    TypeofNEHostObject |
    NEUndefined |
    NENull |
    NEUndefinedOrNull,
  BaseBigIntFacts = BaseBigIntStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
  BigIntStrictFacts = BaseBigIntStrictFacts | Truthy | Falsy,
  BigIntFacts = BaseBigIntFacts | Truthy,
  ZeroBigIntStrictFacts = BaseBigIntStrictFacts | Falsy,
  ZeroBigIntFacts = BaseBigIntFacts,
  NonZeroBigIntStrictFacts = BaseBigIntStrictFacts | Truthy,
  NonZeroBigIntFacts = BaseBigIntFacts | Truthy,
  BaseBooleanStrictFacts = TypeofEQBoolean |
    TypeofNEString |
    TypeofNENumber |
    TypeofNEBigInt |
    TypeofNESymbol |
    TypeofNEObject |
    TypeofNEFunction |
    TypeofNEHostObject |
    NEUndefined |
    NENull |
    NEUndefinedOrNull,
  BaseBooleanFacts = BaseBooleanStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
  BooleanStrictFacts = BaseBooleanStrictFacts | Truthy | Falsy,
  BooleanFacts = BaseBooleanFacts | Truthy,
  FalseStrictFacts = BaseBooleanStrictFacts | Falsy,
  FalseFacts = BaseBooleanFacts,
  TrueStrictFacts = BaseBooleanStrictFacts | Truthy,
  TrueFacts = BaseBooleanFacts | Truthy,
  SymbolStrictFacts = TypeofEQSymbol |
    TypeofNEString |
    TypeofNENumber |
    TypeofNEBigInt |
    TypeofNEBoolean |
    TypeofNEObject |
    TypeofNEFunction |
    TypeofNEHostObject |
    NEUndefined |
    NENull |
    NEUndefinedOrNull |
    Truthy,
  SymbolFacts = SymbolStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
  ObjectStrictFacts = TypeofEQObject |
    TypeofEQHostObject |
    TypeofNEString |
    TypeofNENumber |
    TypeofNEBigInt |
    TypeofNEBoolean |
    TypeofNESymbol |
    TypeofNEFunction |
    NEUndefined |
    NENull |
    NEUndefinedOrNull |
    Truthy,
  ObjectFacts = ObjectStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
  FunctionStrictFacts = TypeofEQFunction |
    TypeofEQHostObject |
    TypeofNEString |
    TypeofNENumber |
    TypeofNEBigInt |
    TypeofNEBoolean |
    TypeofNESymbol |
    TypeofNEObject |
    NEUndefined |
    NENull |
    NEUndefinedOrNull |
    Truthy,
  FunctionFacts = FunctionStrictFacts | EQUndefined | EQNull | EQUndefinedOrNull | Falsy,
  UndefinedFacts = TypeofNEString |
    TypeofNENumber |
    TypeofNEBigInt |
    TypeofNEBoolean |
    TypeofNESymbol |
    TypeofNEObject |
    TypeofNEFunction |
    TypeofNEHostObject |
    EQUndefined |
    EQUndefinedOrNull |
    NENull |
    Falsy,
  NullFacts = TypeofEQObject |
    TypeofNEString |
    TypeofNENumber |
    TypeofNEBigInt |
    TypeofNEBoolean |
    TypeofNESymbol |
    TypeofNEFunction |
    TypeofNEHostObject |
    EQNull |
    EQUndefinedOrNull |
    NEUndefined |
    Falsy,
  EmptyObjectStrictFacts = All & ~(EQUndefined | EQNull | EQUndefinedOrNull),
  EmptyObjectFacts = All,
}
const typeofEQFacts: qb.QReadonlyMap<TypeFacts> = new qb.QMap({
  string: TypeFacts.TypeofEQString,
  number: TypeFacts.TypeofEQNumber,
  bigint: TypeFacts.TypeofEQBigInt,
  boolean: TypeFacts.TypeofEQBoolean,
  symbol: TypeFacts.TypeofEQSymbol,
  undefined: TypeFacts.EQUndefined,
  object: TypeFacts.TypeofEQObject,
  function: TypeFacts.TypeofEQFunction,
});
const typeofNEFacts: qb.QReadonlyMap<TypeFacts> = new qb.QMap({
  string: TypeFacts.TypeofNEString,
  number: TypeFacts.TypeofNENumber,
  bigint: TypeFacts.TypeofNEBigInt,
  boolean: TypeFacts.TypeofNEBoolean,
  symbol: TypeFacts.TypeofNESymbol,
  undefined: TypeFacts.NEUndefined,
  object: TypeFacts.TypeofNEObject,
  function: TypeFacts.TypeofNEFunction,
});
type TypeSystemEntity = Node | Symbol | Type | Signature;
const enum TypeSystemPropertyName {
  Type,
  ResolvedBaseConstructorType,
  DeclaredType,
  ResolvedReturnType,
  ImmediateBaseConstraint,
  EnumTagType,
  ResolvedTypeArguments,
}
const enum CheckMode {
  Normal = 0,
  Contextual = 1 << 0,
  Inferential = 1 << 1,
  SkipContextSensitive = 1 << 2,
  SkipGenericFunctions = 1 << 3,
  IsForSignatureHelp = 1 << 4,
}
const enum AccessFlags {
  None = 0,
  NoIndexSignatures = 1 << 0,
  Writing = 1 << 1,
  CacheSymbol = 1 << 2,
  NoTupleBoundsCheck = 1 << 3,
}
const enum SignatureCheckMode {
  BivariantCallback = 1 << 0,
  StrictCallback = 1 << 1,
  IgnoreReturnTypes = 1 << 2,
  StrictArity = 1 << 3,
  Callback = BivariantCallback | StrictCallback,
}
const enum IntersectionState {
  None = 0,
  Source = 1 << 0,
  Target = 1 << 1,
  PropertyCheck = 1 << 2,
  InPropertyCheck = 1 << 3,
}
const enum MappedTypeModifiers {
  IncludeReadonly = 1 << 0,
  ExcludeReadonly = 1 << 1,
  IncludeOptional = 1 << 2,
  ExcludeOptional = 1 << 3,
}
const enum ExpandingFlags {
  None = 0,
  Source = 1,
  Target = 1 << 1,
  Both = Source | Target,
}
const enum MembersOrExportsResolutionKind {
  resolvedExports = 'resolvedExports',
  resolvedMembers = 'resolvedMembers',
}
const enum UnusedKind {
  Local,
  Parameter,
}
type AddUnusedDiagnostic = (containingNode: Node, type: UnusedKind, diagnostic: DiagnosticWithLocation) => void;
const isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor);
const enum DeclarationMeaning {
  GetAccessor = 1,
  SetAccessor = 2,
  PropertyAssignment = 4,
  Method = 8,
  GetOrSetAccessor = GetAccessor | SetAccessor,
  PropertyAssignmentOrMethod = PropertyAssignment | Method,
}
const enum DeclarationSpaces {
  None = 0,
  ExportValue = 1 << 0,
  ExportType = 1 << 1,
  ExportNamespace = 1 << 2,
}
function SymbolLinks(this: SymbolLinks) {}
function NodeLinks(this: NodeLinks) {
  this.flags = 0;
}
export function isInstantiatedModule(node: ModuleDeclaration, preserveConstEnums: boolean) {
  const moduleState = getModuleInstanceState(node);
  return moduleState === ModuleInstanceState.Instantiated || (preserveConstEnums && moduleState === ModuleInstanceState.ConstEnumOnly);
}
export function qc_create(host: TypeCheckerHost, produceDiagnostics: boolean): TypeChecker {
  const getPackagesSet: () => qb.QMap<true> = memoize(() => {
    const set = new qb.QMap<true>();
    host.getSourceFiles().forEach((sf) => {
      if (!sf.resolvedModules) return;
      forEachEntry(sf.resolvedModules, (r) => {
        if (r && r.packageId) set.set(r.packageId.name, true);
      });
    });
    return set;
  });
  let cancellationToken: CancellationToken | undefined;
  let requestedExternalEmitHelpers: ExternalEmitHelpers;
  let externalHelpersModule: Symbol;
  let enumCount = 0;
  let totalInstantiationCount = 0;
  let instantiationCount = 0;
  let instantiationDepth = 0;
  let constraintDepth = 0;
  let currentNode: Node | undefined;
  const emptySymbols = new SymbolTable();
  const arrayVariances = [VarianceFlags.Covariant];
  const compilerOptions = host.getCompilerOptions();
  const languageVersion = getEmitScriptTarget(compilerOptions);
  const moduleKind = getEmitModuleKind(compilerOptions);
  const allowSyntheticDefaultImports = getAllowSyntheticDefaultImports(compilerOptions);
  const strictNullChecks = getStrictOptionValue(compilerOptions, 'strictNullChecks');
  const strictFunctionTypes = getStrictOptionValue(compilerOptions, 'strictFunctionTypes');
  const strictBindCallApply = getStrictOptionValue(compilerOptions, 'strictBindCallApply');
  const strictPropertyInitialization = getStrictOptionValue(compilerOptions, 'strictPropertyInitialization');
  const noImplicitAny = getStrictOptionValue(compilerOptions, 'noImplicitAny');
  const noImplicitThis = getStrictOptionValue(compilerOptions, 'noImplicitThis');
  const keyofStringsOnly = !!compilerOptions.keyofStringsOnly;
  const freshObjectLiteralFlag = compilerOptions.suppressExcessPropertyErrors ? 0 : ObjectFlags.FreshLiteral;
  const emitResolver = createResolver();
  const nodeBuilder = createNodeBuilder();
  class QNode extends Node {
    static nextNodeId = 1;
    getNodeId() {
      if (!this.id) {
        this.id = QNode.nextNodeId;
        QNode.nextNodeId++;
      }
      return this.id;
    }
    getNodeLinks(): NodeLinks {
      const i = this.getNodeId();
      return nodeLinks[i] || (nodeLinks[i] = new (<any>NodeLinks)());
    }
    isGlobalSourceFile() {
      return this.kind === Syntax.SourceFile && !isExternalOrCommonJsModule(this as xSourceFile);
    }
  }
  class QType extends Type {
    static typeCount = 0;
    createType(flags: TypeFlags): Type {
      const result = new Type(checker, flags);
      QType.typeCount++;
      result.id = QType.typeCount;
      return result;
    }
  }
  class QSymbol extends Symbol implements TransientSymbol {
    static nextId = 1;
    static count = 0;
    checkFlags: CheckFlags;
    constructor(f: SymbolFlags, name: __String, c?: CheckFlags) {
      super(f | SymbolFlags.Transient, name);
      QSymbol.count++;
      this.checkFlags = c || 0;
    }
    getId() {
      if (!this.id) {
        this.id = QSymbol.nextId;
        QSymbol.nextId++;
      }
      return this.id;
    }
    private recordMerged(s: Symbol) {
      if (!this.mergeId) {
        this.mergeId = nextMergeId;
        nextMergeId++;
      }
      mergedSymbols[this.mergeId] = s;
    }
    clone() {
      const r = new QSymbol(this.flags, this.escName);
      r.declarations = this.declarations ? this.declarations.slice() : [];
      r.parent = this.parent;
      if (this.valueDeclaration) r.valueDeclaration = this.valueDeclaration;
      if (this.constEnumOnlyModule) r.constEnumOnlyModule = true;
      if (this.members) r.members = cloneMap(this.members);
      if (this.exports) r.exports = cloneMap(this.exports);
      this.recordMerged(r);
      return r;
    }
    merge(t: QSymbol, unidirectional = false): Symbol {
      if (!(t.flags & getExcludedSymbolFlags(this.flags)) || (this.flags | t.flags) & SymbolFlags.Assignment) {
        if (this === t) return t;
        if (!(t.flags & SymbolFlags.Transient)) {
          const r = t.resolveSymbol();
          if (r === unknownSymbol) return this;
          t = r?.clone();
        }
        if (this.flags & SymbolFlags.ValueModule && t.flags & SymbolFlags.ValueModule && t.constEnumOnlyModule && !this.constEnumOnlyModule) t.constEnumOnlyModule = false;
        t.flags |= this.flags;
        if (this.valueDeclaration) setValueDeclaration(t, this.valueDeclaration);
        addRange(t.declarations, this.declarations);
        if (this.members) {
          if (!t.members) t.members = new SymbolTable();
          t.members.merge(this.members, unidirectional);
        }
        if (this.exports) {
          if (!t.exports) t.exports = new SymbolTable();
          t.exports.merge(this.exports, unidirectional);
        }
        if (!unidirectional) this.recordMerged(t);
      } else if (t.flags & SymbolFlags.NamespaceModule) {
        if (t !== globalThisSymbol) error(getNameOfDeclaration(this.declarations[0]), qd.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity, t.symbolToString());
      } else {
        const isEitherEnum = !!(t.flags & SymbolFlags.Enum || this.flags & SymbolFlags.Enum);
        const isEitherBlockScoped = !!(t.flags & SymbolFlags.BlockScopedVariable || this.flags & SymbolFlags.BlockScopedVariable);
        const message = isEitherEnum
          ? qd.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations
          : isEitherBlockScoped
          ? qd.Cannot_redeclare_block_scoped_variable_0
          : qd.Duplicate_identifier_0;
        const sourceSymbolFile = this.declarations && qc.get.sourceFileOf(this.declarations[0]);
        const targetSymbolFile = t.declarations && qc.get.sourceFileOf(t.declarations[0]);
        const symbolName = this.symbolToString();
        if (sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile !== targetSymbolFile) {
          const firstFile = comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === Comparison.LessThan ? sourceSymbolFile : targetSymbolFile;
          const secondFile = firstFile === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile;
          const filesDuplicates = getOrUpdate<DuplicateInfoForFiles>(amalgamatedDuplicates, `${firstFile.path}|${secondFile.path}`, () => ({
            firstFile,
            secondFile,
            conflictingSymbols: new qb.QMap(),
          }));
          const conflictingSymbolInfo = getOrUpdate<DuplicateInfoForSymbol>(filesDuplicates.conflictingSymbols, symbolName, () => ({
            isBlockScoped: isEitherBlockScoped,
            firstFileLocations: [],
            secondFileLocations: [],
          }));
          this.addDuplicates(conflictingSymbolInfo.firstFileLocations);
          t.addDuplicates(conflictingSymbolInfo.secondFileLocations);
        } else {
          t.addDuplicateErrors(this, message, symbolName);
          this.addDuplicateErrors(t, message, symbolName);
        }
      }
      return t;
    }
    symbolToString(decl?: Node, meaning?: SymbolFlags, flags: SymbolFormatFlags = SymbolFormatFlags.AllowAnyNodeKind, w?: EmitTextWriter): string {
      let f = NodeBuilderFlags.IgnoreErrors;
      if (flags & SymbolFormatFlags.UseOnlyExternalAliasing) f |= NodeBuilderFlags.UseOnlyExternalAliasing;
      if (flags & SymbolFormatFlags.WriteTypeParametersOrArguments) f |= NodeBuilderFlags.WriteTypeParametersInQualifiedName;
      if (flags & SymbolFormatFlags.UseAliasDefinedOutsideCurrentScope) f |= NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope;
      if (flags & SymbolFormatFlags.DoNotIncludeSymbolChain) f |= NodeBuilderFlags.DoNotIncludeSymbolChain;
      const builder = flags & SymbolFormatFlags.AllowAnyNodeKind ? nodeBuilder.symbolToExpression : nodeBuilder.symbolToEntityName;
      const worker = (w: EmitTextWriter) => {
        const b = builder(this, meaning!, decl, f)!;
        const p = createPrinter({ removeComments: true });
        const s = decl && qc.get.sourceFileOf(decl);
        p.writeNode(EmitHint.Unspecified, b, s, w);
        return w;
      };
      return w ? worker(w).getText() : usingSingleLineStringWriter(worker);
    }
    resolveSymbol(noAlias?: boolean) {
      return !noAlias && this.isNonLocalAlias() ? this.resolveAlias() : this;
    }
    getLinks(): SymbolLinks {
      if (this.flags & SymbolFlags.Transient) return this;
      const i = this.getId();
      return symbolLinks[i] || (symbolLinks[i] = new (<any>SymbolLinks)());
    }
    resolveAlias() {
      assert((this.flags & SymbolFlags.Alias) !== 0);
      const ls = this.getLinks();
      if (!ls.target) {
        ls.target = resolvingSymbol;
        const n = this.getDeclarationOfAliasSymbol();
        if (!n) return fail();
        const t = getTargetOfAliasDeclaration(n);
        if (ls.target === resolvingSymbol) ls.target = t || unknownSymbol;
        else error(n, qd.Circular_definition_of_import_alias_0, this.symbolToString());
      } else if (ls.target === resolvingSymbol) ls.target = unknownSymbol;
      return ls.target as QSymbol;
    }
    private addDuplicates(locs: Declaration[]) {
      if (this.declarations) {
        for (const d of this.declarations) {
          pushIfUnique(locs, d);
        }
      }
    }
    private addDuplicateErrors(t: Symbol, m: DiagnosticMessage, name: string) {
      forEach(t.declarations, (n) => {
        addDuplicateDeclarationError(n, m, name, this.declarations);
      });
    }
    isNonLocalAlias(excludes = SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace): this is Symbol {
      const f = this.flags;
      return (f & (SymbolFlags.Alias | excludes)) === SymbolFlags.Alias || !!(f & SymbolFlags.Alias && f & SymbolFlags.Assignment);
    }
    tryResolveAlias() {
      const ls = this.getLinks();
      if (ls.target !== resolvingSymbol) return this.resolveAlias();
      return;
    }
    getDeclarationOfAliasSymbol() {
      const ds = this.declarations;
      return ds && find<Declaration>(ds, isAliasSymbolDeclaration);
    }
    getTypeOnlyAliasDeclaration(): TypeOnlyCompatibleAliasDeclaration | undefined {
      if (!(this.flags & SymbolFlags.Alias)) return;
      return this.getLinks().typeOnlyDeclaration || undefined;
    }
    markAliasSymbolAsReferenced(): void {
      const ls = this.getLinks();
      if (!ls.referenced) {
        ls.referenced = true;
        const d = this.getDeclarationOfAliasSymbol();
        if (!d) return fail();
        if (isInternalModuleImportEqualsDeclaration(d)) {
          const t = this.resolveSymbol();
          if (t === unknownSymbol || (t && t.flags & SymbolFlags.Value)) checkExpressionCached(<Expression>d.moduleReference);
        }
      }
    }
    markConstEnumAliasAsReferenced() {
      const ls = this.getLinks();
      if (!ls.constEnumReferenced) ls.constEnumReferenced = true;
    }
    getDeclarationOfJSPrototypeContainer() {
      const v = this.parent!.valueDeclaration;
      if (!v) return;
      const i = isAssignmentDeclaration(v) ? getAssignedExpandoInitializer(v) : qc.is.withOnlyExpressionInitializer(v) ? getDeclaredExpandoInitializer(v) : undefined;
      return i || v;
    }
    getExpandoSymbol(): Symbol | undefined {
      const v = this.valueDeclaration;
      if (!v || !isInJSFile(v) || this.flags & SymbolFlags.TypeAlias || getExpandoInitializer(v, false)) return;
      const i = qc.is.kind(VariableDeclaration, v) ? getDeclaredExpandoInitializer(v) : getAssignedExpandoInitializer(v);
      if (i) {
        const s = getSymbolOfNode(i);
        if (s) return mergeJSSymbols(s, this);
      }
    }
    getExportsOfSymbol(): SymbolTable {
      return this.flags & SymbolFlags.LateBindingContainer
        ? (getResolvedMembersOrExportsOfSymbol(this, MembersOrExportsResolutionKind.resolvedExports) as SymbolTable)
        : this.flags & SymbolFlags.Module
        ? this.getExportsOfModule()
        : this.exports || emptySymbols;
    }
    getExportsOfModule(): SymbolTable {
      const ls = this.getLinks();
      return ls.resolvedExports || (ls.resolvedExports = this.getExportsOfModuleWorker());
    }
    getExportsOfModuleWorker(moduleSymbol: Symbol): SymbolTable {
      const visitedSymbols: Symbol[] = [];
      moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
      return visit(moduleSymbol) || emptySymbols;
      function visit(s: Symbol | undefined): SymbolTable | undefined {
        if (!(s && s.exports && pushIfUnique(visitedSymbols, s))) return;
        const symbols = cloneMap(s.exports);
        const exportStars = s.exports.get(InternalSymbolName.ExportStar);
        if (exportStars) {
          const nestedSymbols = new SymbolTable();
          const lookupTable = new qb.QMap<ExportCollisionTracker>() as ExportCollisionTrackerTable;
          for (const node of exportStars.declarations) {
            const resolvedModule = resolveExternalModuleName(node, (node as ExportDeclaration).moduleSpecifier!);
            const exportedSymbols = visit(resolvedModule);
            extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable, node as ExportDeclaration);
          }
          lookupTable.forEach(({ exportsWithDuplicate }, id) => {
            if (id === 'export=' || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id)) return;
            for (const node of exportsWithDuplicate) {
              diagnostics.add(
                createDiagnosticForNode(
                  node,
                  qd.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity,
                  lookupTable.get(id)!.specifierText,
                  syntax.get.unescUnderscores(id)
                )
              );
            }
          });
          extendExportSymbols(symbols, nestedSymbols);
        }
        return symbols;
      }
    }
    getMergedSymbol(): Symbol;
    getMergedSymbol(): Symbol | undefined;
    getMergedSymbol(): Symbol | undefined {
      let merged: Symbol;
      return this.mergeId && (merged = mergedSymbols[this.mergeId]) ? merged : this;
    }
    getParentOfSymbol(): Symbol | undefined {
      return this.parent?.getLateBoundSymbol().getMergedSymbol();
    }
    getAlternativeContainingModules(enclosingDeclaration: Node): Symbol[] {
      const containingFile = qc.get.sourceFileOf(enclosingDeclaration);
      const id = '' + containingFile.getNodeId();
      const ls = this.getLinks();
      let results: Symbol[] | undefined;
      if (ls.extendedContainersByFile && (results = ls.extendedContainersByFile.get(id))) return results;
      if (containingFile && containingFile.imports) {
        for (const importRef of containingFile.imports) {
          if (isSynthesized(importRef)) continue;
          const resolvedModule = resolveExternalModuleName(enclosingDeclaration, importRef, true);
          if (!resolvedModule) continue;
          const ref = this.getAliasForSymbolInContainer(resolvedModule);
          if (!ref) continue;
          results = append(results, resolvedModule);
        }
        if (length(results)) {
          (ls.extendedContainersByFile || (ls.extendedContainersByFile = new qb.QMap())).set(id, results!);
          return results!;
        }
      }
      if (ls.extendedContainers) return ls.extendedContainers;
      const otherFiles = host.getSourceFiles();
      for (const file of otherFiles) {
        if (!qp_isExternalModule(file)) continue;
        const sym = getSymbolOfNode(file);
        const ref = this.getAliasForSymbolInContainer(sym);
        if (!ref) continue;
        results = append(results, sym);
      }
      return (ls.extendedContainers = results || empty);
    }
    getContainersOfSymbol(enclosingDeclaration: Node | undefined): Symbol[] | undefined {
      const container = this.getParentOfSymbol();
      if (container && !(this.flags & SymbolFlags.TypeParameter)) {
        const additionalContainers = mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer);
        const reexportContainers = enclosingDeclaration && this.getAlternativeContainingModules(enclosingDeclaration);
        if (enclosingDeclaration && getAccessibleSymbolChain(container, enclosingDeclaration, SymbolFlags.Namespace, false))
          return concatenate(concatenate([container], additionalContainers), reexportContainers);
        const res = append(additionalContainers, container);
        return concatenate(res, reexportContainers);
      }
      const candidates = mapDefined(this.declarations, (d) => {
        if (!qc.is.ambientModule(d) && d.parent && hasNonGlobalAugmentationExternalModuleSymbol(d.parent)) return getSymbolOfNode(d.parent);
        if (
          qc.is.kind(ClassExpression, d) &&
          qc.is.kind(BinaryExpression, d.parent) &&
          d.parent.operatorToken.kind === Syntax.EqualsToken &&
          isAccessExpression(d.parent.left) &&
          isEntityNameExpression(d.parent.left.expression)
        ) {
          if (qc.is.moduleExportsAccessExpression(d.parent.left) || qc.is.exportsIdentifier(d.parent.left.expression)) return getSymbolOfNode(qc.get.sourceFileOf(d));
          checkExpressionCached(d.parent.left.expression);
          return getNodeLinks(d.parent.left.expression).resolvedSymbol;
        }
      });
      if (!length(candidates)) return;
      return mapDefined(candidates, (candidate) => (this.getAliasForSymbolInContainer(candidate) ? candidate : undefined));
      function fileSymbolIfFileSymbolExportEqualsContainer(d: Declaration) {
        return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container);
      }
    }
    getExportSymbolOfValueSymbolIfExported(): Symbol;
    getExportSymbolOfValueSymbolIfExported(): Symbol | undefined;
    getExportSymbolOfValueSymbolIfExported(): Symbol | undefined {
      return ((this.flags & SymbolFlags.ExportValue) !== 0 ? this.exportSymbol : this)?.getMergedSymbol();
    }
    symbolIsValue() {
      return !!(this.flags & SymbolFlags.Value || (this.flags & SymbolFlags.Alias && this.resolveAlias().flags & SymbolFlags.Value && !this.getTypeOnlyAliasDeclaration()));
    }
    isPropertyOrMethodDeclarationSymbol() {
      if (this.declarations && this.declarations.length) {
        for (const declaration of this.declarations) {
          switch (declaration.kind) {
            case Syntax.PropertyDeclaration:
            case Syntax.MethodDeclaration:
            case Syntax.GetAccessor:
            case Syntax.SetAccessor:
              continue;
            default:
              return false;
          }
        }
        return true;
      }
      return false;
    }
    needsQualification(enclosingDeclaration: Node | undefined, meaning: SymbolFlags) {
      let qualify = false;
      forEachSymbolTableInScope(enclosingDeclaration, (symbolTable) => {
        let symbolFromSymbolTable = symbolTable.get(this.escName)?.getMergedSymbol();
        if (!symbolFromSymbolTable) return false;
        if (symbolFromSymbolTable === this) return true;
        symbolFromSymbolTable =
          symbolFromSymbolTable.flags & SymbolFlags.Alias && !getDeclarationOfKind(symbolFromSymbolTable, Syntax.ExportSpecifier) ? symbolFromSymbolTable.resolveAlias() : symbolFromSymbolTable;
        if (symbolFromSymbolTable.flags & meaning) {
          qualify = true;
          return true;
        }
        return false;
      });
      return qualify;
    }
    isTypeSymbolAccessible(enclosingDeclaration?: Node) {
      const a = this.isSymbolAccessible(enclosingDeclaration, SymbolFlags.Type, false);
      return a.accessibility === SymbolAccessibility.Accessible;
    }
    isValueSymbolAccessible(enclosingDeclaration?: Node) {
      const a = this.isSymbolAccessible(enclosingDeclaration, SymbolFlags.Value, false);
      return a.accessibility === SymbolAccessibility.Accessible;
    }
    symbolValueDeclarationIsContextSensitive() {
      const v = this.valueDeclaration;
      return v && qc.is.expression(v) && !isContextSensitive(v);
    }
    serializeSymbol(isPrivate: boolean, propertyAsAlias: boolean) {
      const s = this.getMergedSymbol();
      if (visitedSymbols.has('' + s.getId())) return;
      visitedSymbols.set('' + s.getId(), true);
      const skip = !isPrivate;
      if (skip || (!!length(this.declarations) && some(this.declarations, (d) => !!Node.findAncestor(d, (n) => n === enclosingDeclaration)))) {
        const o = context;
        context = cloneQContext(context);
        const r = serializeSymbolWorker(this, isPrivate, propertyAsAlias);
        context = o;
        return r;
      }
    }
    serializeSymbolWorker(isPrivate: boolean, propertyAsAlias: boolean) {
      const symbolName = syntax.get.unescUnderscores(this.escName);
      const isDefault = this.escName === InternalSymbolName.Default;
      if (!(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier) && syntax.is.stringANonContextualKeyword(symbolName) && !isDefault) {
        context.encounteredError = true;
        return;
      }
      const needsPostExportDefault =
        isDefault &&
        !!(this.flags & SymbolFlags.ExportDoesNotSupportDefaultModifier || (this.flags & SymbolFlags.Function && length(getPropertiesOfType(this.getTypeOfSymbol())))) &&
        !(this.flags & SymbolFlags.Alias);
      if (needsPostExportDefault) isPrivate = true;
      const modifierFlags = (!isPrivate ? ModifierFlags.Export : 0) | (isDefault && !needsPostExportDefault ? ModifierFlags.Default : 0);
      const isConstMergedWithNS =
        this.flags & SymbolFlags.Module &&
        this.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.FunctionScopedVariable | SymbolFlags.Property) &&
        this.escName !== InternalSymbolName.ExportEquals;
      const isConstMergedWithNSPrintableAsSignatureMerge = isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(this.getTypeOfSymbol(), this);
      if (this.flags & (SymbolFlags.Function | SymbolFlags.Method) || isConstMergedWithNSPrintableAsSignatureMerge)
        serializeAsFunctionNamespaceMerge(this.getTypeOfSymbol(), this, getInternalSymbolName(symbolName), modifierFlags);
      if (this.flags & SymbolFlags.TypeAlias) this.serializeTypeAlias(symbolName, modifierFlags);
      if (
        this.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.FunctionScopedVariable | SymbolFlags.Property) &&
        this.escName !== InternalSymbolName.ExportEquals &&
        !(this.flags & SymbolFlags.Prototype) &&
        !(this.flags & SymbolFlags.Class) &&
        !isConstMergedWithNSPrintableAsSignatureMerge
      ) {
        this.serializeVariableOrProperty(symbolName, isPrivate, needsPostExportDefault, propertyAsAlias, modifierFlags);
      }
      if (this.flags & SymbolFlags.Enum) this.serializeEnum(symbolName, modifierFlags);
      if (this.flags & SymbolFlags.Class) {
        if (this.flags & SymbolFlags.Property && qc.is.kind(BinaryExpression, this.valueDeclaration.parent) && qc.is.kind(ClassExpression, this.valueDeclaration.parent.right))
          this.serializeAsAlias(this.getInternalSymbolName(symbolName), modifierFlags);
        else {
          this.serializeAsClass(this.getInternalSymbolName(symbolName), modifierFlags);
        }
      }
      if ((this.flags & (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) || isConstMergedWithNSPrintableAsSignatureMerge)
        this.serializeModule(symbolName, modifierFlags);
      if (this.flags & SymbolFlags.Interface) this.serializeInterface(symbolName, modifierFlags);
      if (this.flags & SymbolFlags.Alias) this.serializeAsAlias(this.getInternalSymbolName(symbolName), modifierFlags);
      if (this.flags & SymbolFlags.Property && this.escName === InternalSymbolName.ExportEquals) serializeMaybeAliasAssignment(symbol);
      if (this.flags & SymbolFlags.ExportStar) {
        for (const node of this.declarations) {
          const resolvedModule = resolveExternalModuleName(node, (node as ExportDeclaration).moduleSpecifier!);
          if (!resolvedModule) continue;
          addResult(new qc.ExportDeclaration(undefined, undefined, undefined, qc.asLiteral(getSpecifierForModuleSymbol(resolvedModule, context))), ModifierFlags.None);
        }
      }
      if (needsPostExportDefault) addResult(new qc.ExportAssignment(undefined, undefined, false, new Identifier(this.getInternalSymbolName(symbolName))), ModifierFlags.None);
    }
    includePrivateSymbol() {
      if (some(this.declarations, isParameterDeclaration)) return;
      Debug.assertIsDefined(deferredPrivates);
      getUnusedName(syntax.get.unescUnderscores(this.escName), this);
      deferredPrivates.set('' + this.getId(), this);
    }
    serializeTypeAlias(symbolName: string, modifierFlags: ModifierFlags) {
      const aliasType = this.getDeclaredTypeOfTypeAlias();
      const typeParams = this.getLinks().typeParameters;
      const typeParamDecls = map(typeParams, (p) => typeParameterToDeclaration(p, context));
      const jsdocAliasDecl = find(this.declarations, isJSDocTypeAlias);
      const commentText = jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : undefined;
      const oldFlags = context.flags;
      context.flags |= NodeBuilderFlags.InTypeAlias;
      addResult(
        setSyntheticLeadingComments(
          new qc.TypeAliasDeclaration(undefined, undefined, this.getInternalSymbolName(symbolName), typeParamDecls, typeToTypeNodeHelper(aliasType, context)),
          !commentText
            ? []
            : [
                {
                  kind: Syntax.MultiLineCommentTrivia,
                  text: '*\n * ' + commentText.replace(/\n/g, '\n * ') + '\n ',
                  pos: -1,
                  end: -1,
                  hasTrailingNewLine: true,
                },
              ]
        ),
        modifierFlags
      );
      context.flags = oldFlags;
    }
    serializeInterface(symbolName: string, modifierFlags: ModifierFlags) {
      const interfaceType = this.getDeclaredTypeOfClassOrInterface();
      const localParams = this.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias();
      const typeParamDecls = map(localParams, (p) => typeParameterToDeclaration(p, context));
      const baseTypes = getBaseTypes(interfaceType);
      const baseType = length(baseTypes) ? getIntersectionType(baseTypes) : undefined;
      const members = flatMap<Symbol, TypeElement>(getPropertiesOfType(interfaceType), (p) => serializePropertySymbolForInterface(p, baseType));
      const callSignatures = serializeSignatures(SignatureKind.Call, interfaceType, baseType, Syntax.CallSignature) as CallSignatureDeclaration[];
      const constructSignatures = serializeSignatures(SignatureKind.Construct, interfaceType, baseType, Syntax.ConstructSignature) as ConstructSignatureDeclaration[];
      const indexSignatures = serializeIndexSignatures(interfaceType, baseType);
      const heritageClauses = !length(baseTypes)
        ? undefined
        : [
            new qc.HeritageClause(
              Syntax.ExtendsKeyword,
              mapDefined(baseTypes, (b) => trySerializeAsTypeReference(b))
            ),
          ];
      addResult(
        new qc.InterfaceDeclaration(undefined, undefined, this.getInternalSymbolName(symbolName), typeParamDecls, heritageClauses, [
          ...indexSignatures,
          ...constructSignatures,
          ...callSignatures,
          ...members,
        ]),
        modifierFlags
      );
    }
    getNamespaceMembersForSerialization() {
      return !this.exports ? [] : filter(arrayFrom(this.exports.values()), isNamespaceMember);
    }
    isTypeOnlyNamespace() {
      return every(this.getNamespaceMembersForSerialization(), (m) => !(m.resolveSymbol().flags & SymbolFlags.Value));
    }
    serializeModule(symbolName: string, modifierFlags: ModifierFlags) {
      const members = this.getNamespaceMembersForSerialization();
      const locationMap = arrayToMultiMap(members, (m) => (m.parent && m.parent === this ? 'real' : 'merged'));
      const realMembers = locationMap.get('real') || empty;
      const mergedMembers = locationMap.get('merged') || empty;
      if (length(realMembers)) {
        const localName = this.getInternalSymbolName(symbolName);
        serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(this.flags & (SymbolFlags.Function | SymbolFlags.Assignment)));
      }
      if (length(mergedMembers)) {
        const containingFile = qc.get.sourceFileOf(context.enclosingDeclaration);
        const localName = this.getInternalSymbolName(symbolName);
        const nsBody = new qc.ModuleBlock([
          new qc.ExportDeclaration(
            undefined,
            undefined,
            new qc.NamedExports(
              mapDefined(
                filter(mergedMembers, (n) => n.escName !== InternalSymbolName.ExportEquals),
                (s) => {
                  const name = syntax.get.unescUnderscores(s.escName);
                  const localName = getInternalSymbolName(s, name);
                  const aliasDecl = s.declarations && s.getDeclarationOfAliasSymbol();
                  if (containingFile && (aliasDecl ? containingFile !== qc.get.sourceFileOf(aliasDecl) : !some(s.declarations, (d) => qc.get.sourceFileOf(d) === containingFile))) {
                    context.tracker?.reportNonlocalAugmentation?.(containingFile, symbol, s);
                    return;
                  }
                  const target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, true);
                  includePrivateSymbol(target || s);
                  const targetName = target ? getInternalSymbolName(target, syntax.get.unescUnderscores(target.escName)) : localName;
                  return new qc.ExportSpecifier(name === targetName ? undefined : targetName, name);
                }
              )
            )
          ),
        ]);
        addResult(new qc.ModuleDeclaration(undefined, undefined, new Identifier(localName), nsBody, NodeFlags.Namespace), ModifierFlags.None);
      }
    }
    serializeEnum(symbolName: string, modifierFlags: ModifierFlags) {
      addResult(
        new qc.EnumDeclaration(
          undefined,
          createModifiersFromModifierFlags(this.isConstEnumSymbol() ? ModifierFlags.Const : 0),
          this.getInternalSymbolName(symbolName),
          map(
            filter(getPropertiesOfType(this.getTypeOfSymbol()), (p) => !!(p.flags & SymbolFlags.EnumMember)),
            (p) => {
              const initializedValue = p.declarations && p.declarations[0] && qc.is.kind(EnumMember, p.declarations[0]) && getConstantValue(p.declarations[0] as EnumMember);
              return new qc.EnumMember(syntax.get.unescUnderscores(p.escName), initializedValue === undefined ? undefined : qc.asLiteral(initializedValue));
            }
          )
        ),
        modifierFlags
      );
    }
    serializeVariableOrProperty(symbolName: string, isPrivate: boolean, needsPostExportDefault: boolean, propertyAsAlias: boolean | undefined, modifierFlags: ModifierFlags) {
      if (propertyAsAlias) serializeMaybeAliasAssignment(this);
      else {
        const type = getTypeOfSymbol(this);
        const localName = getInternalSymbolName(this, symbolName);
        if (!(this.flags & SymbolFlags.Function) && isTypeRepresentableAsFunctionNamespaceMerge(type, symbol)) serializeAsFunctionNamespaceMerge(type, symbol, localName, modifierFlags);
        else {
          const flags = !(this.flags & SymbolFlags.BlockScopedVariable) ? undefined : isConstVariable(symbol) ? NodeFlags.Const : NodeFlags.Let;
          const name = needsPostExportDefault || !(this.flags & SymbolFlags.Property) ? localName : getUnusedName(localName, symbol);
          let textRange: Node | undefined = this.declarations && find(this.declarations, (d) => qc.is.kind(VariableDeclaration, d));
          if (textRange && qc.is.kind(VariableDeclarationList, textRange.parent) && textRange.parent.declarations.length === 1) textRange = textRange.parent.parent;
          const statement = setRange(
            new qc.VariableStatement(
              undefined,
              new qc.VariableDeclarationList([new qc.VariableDeclaration(name, serializeTypeForDeclaration(context, type, symbol, enclosingDeclaration, includePrivateSymbol, bundled))], flags)
            ),
            textRange
          );
          addResult(statement, name !== localName ? modifierFlags & ~ModifierFlags.Export : modifierFlags);
          if (name !== localName && !isPrivate) addResult(new qc.ExportDeclaration(undefined, undefined, new qc.NamedExports([new qc.ExportSpecifier(name, localName)])), ModifierFlags.None);
        }
      }
    }
    serializeAsAlias(localName: string, modifierFlags: ModifierFlags) {
      const node = this.getDeclarationOfAliasSymbol();
      if (!node) return fail();
      const target = getMergedSymbol(getTargetOfAliasDeclaration(node, true));
      if (!target) return;
      let verbatimTargetName = syntax.get.unescUnderscores(target.escName);
      if (verbatimTargetName === InternalSymbolName.ExportEquals && (compilerOptions.esModuleInterop || compilerOptions.allowSyntheticDefaultImports)) verbatimTargetName = InternalSymbolName.Default;
      const targetName = getInternalSymbolName(target, verbatimTargetName);
      includePrivateSymbol(target);
      switch (node.kind) {
        case Syntax.ImportEqualsDeclaration:
          const isLocalImport = !(target.flags & SymbolFlags.ValueModule);
          addResult(
            new qc.ImportEqualsDeclaration(
              undefined,
              undefined,
              new Identifier(localName),
              isLocalImport ? symbolToName(target, context, SymbolFlags.All, false) : new qc.ExternalModuleReference(qc.asLiteral(getSpecifierForModuleSymbol(symbol, context)))
            ),
            isLocalImport ? modifierFlags : ModifierFlags.None
          );
          break;
        case Syntax.NamespaceExportDeclaration:
          addResult(new qc.NamespaceExportDeclaration(idText((node as NamespaceExportDeclaration).name)), ModifierFlags.None);
          break;
        case Syntax.ImportClause:
          addResult(
            new qc.ImportDeclaration(undefined, undefined, new qc.ImportClause(new Identifier(localName), undefined), qc.asLiteral(getSpecifierForModuleSymbol(target.parent || target, context))),
            ModifierFlags.None
          );
          break;
        case Syntax.NamespaceImport:
          addResult(
            new qc.ImportDeclaration(
              undefined,
              undefined,
              new qc.ImportClause(undefined, new qc.NamespaceImport(new Identifier(localName))),
              qc.asLiteral(getSpecifierForModuleSymbol(target, context))
            ),
            ModifierFlags.None
          );
          break;
        case Syntax.NamespaceExport:
          addResult(new qc.ExportDeclaration(undefined, undefined, new qc.NamespaceExport(new Identifier(localName)), qc.asLiteral(getSpecifierForModuleSymbol(target, context))), ModifierFlags.None);
          break;
        case Syntax.ImportSpecifier:
          addResult(
            new qc.ImportDeclaration(
              undefined,
              undefined,
              new qc.ImportClause(
                undefined,
                new qc.NamedImports([new qc.ImportSpecifier(localName !== verbatimTargetName ? new Identifier(verbatimTargetName) : undefined, new Identifier(localName))])
              ),
              qc.asLiteral(getSpecifierForModuleSymbol(target.parent || target, context))
            ),
            ModifierFlags.None
          );
          break;
        case Syntax.ExportSpecifier:
          const specifier = (node.parent.parent as ExportDeclaration).moduleSpecifier;
          serializeExportSpecifier(
            syntax.get.unescUnderscores(this.escName),
            specifier ? verbatimTargetName : targetName,
            specifier && StringLiteral.like(specifier) ? qc.asLiteral(specifier.text) : undefined
          );
          break;
        case Syntax.ExportAssignment:
          serializeMaybeAliasAssignment(symbol);
          break;
        case Syntax.BinaryExpression:
        case Syntax.PropertyAccessExpression:
          if (this.escName === InternalSymbolName.Default || this.escName === InternalSymbolName.ExportEquals) serializeMaybeAliasAssignment(symbol);
          else {
            serializeExportSpecifier(localName, targetName);
          }
          break;
        default:
          return Debug.failBadSyntax(node, 'Unhandled alias declaration kind in symbol serializer!');
      }
    }
    serializeMaybeAliasAssignment() {
      if (this.flags & SymbolFlags.Prototype) return;
      const name = syntax.get.unescUnderscores(this.escName);
      const isExportEquals = name === InternalSymbolName.ExportEquals;
      const isDefault = name === InternalSymbolName.Default;
      const isExportAssignment = isExportEquals || isDefault;
      const aliasDecl = this.declarations && this.getDeclarationOfAliasSymbol();
      const target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, true);
      if (target && length(target.declarations) && some(target.declarations, (d) => qc.get.sourceFileOf(d) === qc.get.sourceFileOf(enclosingDeclaration))) {
        const expr = isExportAssignment
          ? getExportAssignmentExpression(aliasDecl as ExportAssignment | BinaryExpression)
          : getPropertyAssignmentAliasLikeExpression(aliasDecl as ShorthandPropertyAssignment | PropertyAssignment | PropertyAccessExpression);
        const first = isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : undefined;
        const referenced = first && resolveEntityName(first, SymbolFlags.All, true, true, enclosingDeclaration);
        if (referenced || target) includePrivateSymbol(referenced || target);
        const oldTrack = context.tracker.trackSymbol;
        context.tracker.trackSymbol = noop;
        if (isExportAssignment) results.push(new qc.ExportAssignment(undefined, undefined, isExportEquals, symbolToExpression(target, context, SymbolFlags.All)));
        else {
          if (first === expr) serializeExportSpecifier(name, idText(first));
          else if (qc.is.kind(ClassExpression, expr)) {
            serializeExportSpecifier(name, getInternalSymbolName(target, target.name));
          } else {
            const varName = getUnusedName(name, symbol);
            addResult(new qc.ImportEqualsDeclaration(undefined, undefined, new Identifier(varName), symbolToName(target, context, SymbolFlags.All, false)), ModifierFlags.None);
            serializeExportSpecifier(name, varName);
          }
        }
        context.tracker.trackSymbol = oldTrack;
      } else {
        const varName = getUnusedName(name, symbol);
        const typeToSerialize = getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)));
        if (isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol))
          serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName, isExportAssignment ? ModifierFlags.None : ModifierFlags.Export);
        else {
          const statement = new qc.VariableStatement(
            undefined,
            new qc.VariableDeclarationList(
              [new qc.VariableDeclaration(varName, serializeTypeForDeclaration(context, typeToSerialize, symbol, enclosingDeclaration, includePrivateSymbol, bundled))],
              NodeFlags.Const
            )
          );
          addResult(statement, name === varName ? ModifierFlags.Export : ModifierFlags.None);
        }
        if (isExportAssignment) results.push(new qc.ExportAssignment(undefined, undefined, isExportEquals, new Identifier(varName)));
        else if (name !== varName) {
          serializeExportSpecifier(name, varName);
        }
      }
    }
    isConstructorDeclaredProperty() {
      if (this.valueDeclaration && qc.is.kind(BinaryExpression, this.valueDeclaration)) {
        const ls = this.getLinks();
        if (ls.isConstructorDeclaredProperty === undefined) {
          ls.isConstructorDeclaredProperty =
            !!getDeclaringConstructor(symbol) &&
            every(
              this.declarations,
              (declaration) =>
                qc.is.kind(BinaryExpression, declaration) &&
                getAssignmentDeclarationKind(declaration) === AssignmentDeclarationKind.ThisProperty &&
                (declaration.left.kind !== Syntax.ElementAccessExpression || StringLiteral.orNumericLiteralLike((<ElementAccessExpression>declaration.left).argumentExpression)) &&
                !getAnnotatedTypeForAssignmentDeclaration(undefined, declaration, symbol, declaration)
            );
        }
        return ls.isConstructorDeclaredProperty;
      }
      return false;
    }
    isAutoTypedProperty() {
      const v = this.valueDeclaration;
      return v && qc.is.kind(PropertyDeclaration, v) && !getEffectiveTypeAnnotationNode(v) && !v.initializer && (noImplicitAny || isInJSFile(v));
    }
    getDeclaringConstructor() {
      const ds = this.declarations;
      if (ds) {
        for (const d of ds) {
          const c = qc.get.thisContainer(d, false);
          if (c && (c.kind === Syntax.Constructor || isJSConstructor(c))) return <ConstructorDeclaration>c;
        }
      }
    }
    getTypeOfVariableOrParameterOrProperty(): Type {
      const ls = this.getLinks();
      if (!ls.type) {
        const t = getTypeOfVariableOrParameterOrPropertyWorker(symbol);
        if (!ls.type) ls.type = t;
      }
      return ls.type;
    }
    getTypeOfVariableOrParameterOrPropertyWorker() {
      if (symbol.flags & SymbolFlags.Prototype) return getTypeOfPrototypeProperty(symbol);
      if (symbol === requireSymbol) return anyType;
      if (symbol.flags & SymbolFlags.ModuleExports) {
        const fileSymbol = getSymbolOfNode(qc.get.sourceFileOf(symbol.valueDeclaration));
        const members = new SymbolTable();
        members.set('exports' as __String, fileSymbol);
        return createAnonymousType(symbol, members, empty, empty, undefined, undefined);
      }
      const declaration = symbol.valueDeclaration;
      if (isCatchClauseVariableDeclarationOrBindingElement(declaration)) return anyType;
      if (qc.is.kind(SourceFile, declaration) && isJsonSourceFile(declaration)) {
        if (!declaration.statements.length) return emptyObjectType;
        return getWidenedType(getWidenedLiteralType(checkExpression(declaration.statements[0].expression)));
      }
      if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) {
        if (symbol.flags & SymbolFlags.ValueModule && !(symbol.flags & SymbolFlags.Assignment)) return this.getTypeOfFuncClassEnumModule();
        return reportCircularityError(symbol);
      }
      let type: Type | undefined;
      if (declaration.kind === Syntax.ExportAssignment) type = widenTypeForVariableLikeDeclaration(checkExpressionCached((<ExportAssignment>declaration).expression), declaration);
      else if (
        qc.is.kind(BinaryExpression, declaration) ||
        (isInJSFile(declaration) &&
          (qc.is.kind(CallExpression, declaration) ||
            ((qc.is.kind(PropertyAccessExpression, declaration) || isBindableStaticElementAccessExpression(declaration)) && qc.is.kind(BinaryExpression, declaration.parent))))
      ) {
        type = getWidenedTypeForAssignmentDeclaration(symbol);
      } else if (
        qc.isDoc.propertyLikeTag(declaration) ||
        qc.is.kind(PropertyAccessExpression, declaration) ||
        qc.is.kind(ElementAccessExpression, declaration) ||
        qc.is.kind(Identifier, declaration) ||
        StringLiteral.like(declaration) ||
        qc.is.kind(NumericLiteral, declaration) ||
        qc.is.kind(ClassDeclaration, declaration) ||
        qc.is.kind(FunctionDeclaration, declaration) ||
        (qc.is.kind(MethodDeclaration, declaration) && !qc.is.objectLiteralMethod(declaration)) ||
        qc.is.kind(MethodSignature, declaration) ||
        qc.is.kind(SourceFile, declaration)
      ) {
        if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)) return this.getTypeOfFuncClassEnumModule();
        type = qc.is.kind(BinaryExpression, declaration.parent) ? getWidenedTypeForAssignmentDeclaration(symbol) : tryGetTypeFromEffectiveTypeNode(declaration) || anyType;
      } else if (qc.is.kind(PropertyAssignment, declaration)) {
        type = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration);
      } else if (qc.is.kind(JsxAttribute, declaration)) {
        type = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration);
      } else if (qc.is.kind(ShorthandPropertyAssignment, declaration)) {
        type = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, CheckMode.Normal);
      } else if (qc.is.objectLiteralMethod(declaration)) {
        type = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, CheckMode.Normal);
      } else if (
        qc.is.kind(ParameterDeclaration, declaration) ||
        qc.is.kind(PropertyDeclaration, declaration) ||
        qc.is.kind(PropertySignature, declaration) ||
        qc.is.kind(VariableDeclaration, declaration) ||
        qc.is.kind(BindingElement, declaration)
      ) {
        type = getWidenedTypeForVariableLikeDeclaration(declaration, true);
      } else if (qc.is.kind(EnumDeclaration, declaration)) {
        type = this.getTypeOfFuncClassEnumModule();
      } else if (qc.is.kind(EnumMember, declaration)) {
        type = this.getTypeOfEnumMember();
      } else if (qc.is.accessor(declaration)) {
        type = resolveTypeOfAccessors(symbol);
      } else return fail('Unhandled declaration kind! ' + Debug.formatSyntax(declaration.kind) + ' for ' + Debug.formatSymbol(symbol));
      if (!popTypeResolution()) {
        if (symbol.flags & SymbolFlags.ValueModule && !(symbol.flags & SymbolFlags.Assignment)) return this.getTypeOfFuncClassEnumModule();
        return reportCircularityError(symbol);
      }
      return type;
    }
    getTypeOfAccessors(): Type {
      const ls = this.getLinks();
      return ls.type || (ls.type = getTypeOfAccessorsWorker(symbol));
    }
    getTypeOfAccessorsWorker(): Type {
      if (!pushTypeResolution(this, TypeSystemPropertyName.Type)) return errorType;
      let type = resolveTypeOfAccessors(this);
      if (!popTypeResolution()) {
        type = anyType;
        if (noImplicitAny) {
          const getter = getDeclarationOfKind<AccessorDeclaration>(this, Syntax.GetAccessor);
          error(
            getter,
            qd._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions,
            this.symbolToString()
          );
        }
      }
      return type;
    }
    resolveTypeOfAccessors() {
      const getter = getDeclarationOfKind<AccessorDeclaration>(this, Syntax.GetAccessor);
      const setter = getDeclarationOfKind<AccessorDeclaration>(this, Syntax.SetAccessor);
      if (getter && isInJSFile(getter)) {
        const jsDocType = getTypeForDeclarationFromJSDocComment(getter);
        if (jsDocType) return jsDocType;
      }
      const getterReturnType = getAnnotatedAccessorType(getter);
      if (getterReturnType) return getterReturnType;
      const setterParameterType = getAnnotatedAccessorType(setter);
      if (setterParameterType) return setterParameterType;
      if (getter && getter.body) return getReturnTypeFromBody(getter);
      if (setter) {
        if (!isPrivateWithinAmbient(setter))
          errorOrSuggestion(noImplicitAny, setter, qd.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, this.symbolToString());
      } else {
        assert(!!getter, 'there must exist a getter as we are current checking either setter or getter in this function');
        if (!isPrivateWithinAmbient(getter))
          errorOrSuggestion(noImplicitAny, getter, qd.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, this.symbolToString());
      }
      return anyType;
    }
    getBaseTypeVariableOfClass() {
      const baseConstructorType = getBaseConstructorTypeOfClass(this.getDeclaredTypeOfClassOrInterface());
      return baseConstructorType.flags & TypeFlags.TypeVariable
        ? baseConstructorType
        : baseConstructorType.flags & TypeFlags.Intersection
        ? find((baseConstructorType as IntersectionType).types, (t) => !!(t.flags & TypeFlags.TypeVariable))
        : undefined;
    }
    getTypeOfFuncClassEnumModule(): Type {
      let ls = this.getLinks();
      const originalLinks = ls;
      if (!ls.type) {
        const jsDeclaration = this.valueDeclaration && getDeclarationOfExpando(this.valueDeclaration);
        if (jsDeclaration) {
          const merged = this.mergeJSSymbols(getSymbolOfNode(jsDeclaration));
          if (merged) symbol = ls = merged;
        }
        originalLinks.type = ls.type = getTypeOfFuncClassEnumModuleWorker(symbol);
      }
      return ls.type;
    }
    getTypeOfFuncClassEnumModuleWorker(): Type {
      const declaration = symbol.valueDeclaration;
      if (symbol.flags & SymbolFlags.Module && isShorthandAmbientModuleSymbol(symbol)) return anyType;
      else if (declaration && (declaration.kind === Syntax.BinaryExpression || (isAccessExpression(declaration) && declaration.parent.kind === Syntax.BinaryExpression)))
        return getWidenedTypeForAssignmentDeclaration(symbol);
      else if (symbol.flags & SymbolFlags.ValueModule && declaration && qc.is.kind(SourceFile, declaration) && declaration.commonJsModuleIndicator) {
        const resolvedModule = resolveExternalModuleSymbol(symbol);
        if (resolvedModule !== symbol) {
          if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) return errorType;
          const exportEquals = getMergedSymbol(symbol.exports!.get(InternalSymbolName.ExportEquals)!);
          const type = getWidenedTypeForAssignmentDeclaration(exportEquals, exportEquals === resolvedModule ? undefined : resolvedModule);
          if (!popTypeResolution()) return reportCircularityError(symbol);
          return type;
        }
      }
      const type = createObjectType(ObjectFlags.Anonymous, symbol);
      if (symbol.flags & SymbolFlags.Class) {
        const baseTypeVariable = getBaseTypeVariableOfClass(symbol);
        return baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type;
      }
      return strictNullChecks && symbol.flags & SymbolFlags.Optional ? getOptionalType(type) : type;
    }
    getTypeOfEnumMember(): Type {
      const ls = this.getLinks();
      return ls.type || (ls.type = getDeclaredTypeOfEnumMember(symbol));
    }
    getTypeOfAlias(): Type {
      const ls = this.getLinks();
      if (!ls.type) {
        const targetSymbol = this.resolveAlias();
        ls.type = targetSymbol.flags & SymbolFlags.Value ? getTypeOfSymbol(targetSymbol) : errorType;
      }
      return ls.type;
    }
    getTypeOfInstantiatedSymbol(): Type {
      const ls = this.getLinks();
      if (!ls.type) {
        if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) return (ls.type = errorType);
        let type = instantiateType(getTypeOfSymbol(ls.target!), ls.mapper);
        if (!popTypeResolution()) type = reportCircularityError(symbol);
        ls.type = type;
      }
      return ls.type;
    }
    reportCircularityError() {
      const declaration = <VariableLikeDeclaration>this.valueDeclaration;
      if (getEffectiveTypeAnnotationNode(declaration)) {
        error(this.valueDeclaration, qd._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, this.symbolToString());
        return errorType;
      }
      if (noImplicitAny && (declaration.kind !== Syntax.Parameter || (<HasInitializer>declaration).initializer)) {
        error(this.valueDeclaration, qd._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, this.symbolToString());
      }
      return anyType;
    }
    getTypeOfSymbolWithDeferredType() {
      const ls = this.getLinks();
      if (!ls.type) {
        Debug.assertIsDefined(ls.deferralParent);
        Debug.assertIsDefined(ls.deferralConstituents);
        ls.type = ls.deferralParent.flags & TypeFlags.Union ? getUnionType(ls.deferralConstituents) : getIntersectionType(ls.deferralConstituents);
      }
      return ls.type;
    }
    getTypeOfSymbol(): Type {
      const f = this.getCheckFlags();
      if (f & CheckFlags.DeferredType) return this.getTypeOfSymbolWithDeferredType();
      if (f & CheckFlags.Instantiated) return this.getTypeOfInstantiatedSymbol();
      if (f & CheckFlags.Mapped) return getTypeOfMappedSymbol(this as MappedSymbol);
      if (f & CheckFlags.ReverseMapped) return getTypeOfReverseMappedSymbol(this as ReverseMappedSymbol);
      if (this.flags & (SymbolFlags.Variable | SymbolFlags.Property)) return this.getTypeOfVariableOrParameterOrProperty();
      if (this.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule)) return this.getTypeOfFuncClassEnumModule();
      if (this.flags & SymbolFlags.EnumMember) return this.getTypeOfEnumMember();
      if (this.flags & SymbolFlags.Accessor) return this.getTypeOfAccessors();
      if (this.flags & SymbolFlags.Alias) return this.getTypeOfAlias();
      return errorType;
    }
    getOuterTypeParametersOfClassOrInterface(): TypeParameter[] | undefined {
      const d = this.flags & SymbolFlags.Class ? this.valueDeclaration : this.getDeclarationOfKind(Syntax.InterfaceDeclaration)!;
      assert(!!d, 'Class was missing valueDeclaration -OR- non-class had no interface declarations');
      return getOuterTypeParameters(d);
    }
    getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(): TypeParameter[] | undefined {
      let r: TypeParameter[] | undefined;
      for (const d of this.declarations ?? []) {
        if (d.kind === Syntax.InterfaceDeclaration || d.kind === Syntax.ClassDeclaration || d.kind === Syntax.ClassExpression || isJSConstructor(d) || qc.is.typeAlias(d)) {
          const d2 = d as InterfaceDeclaration | TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag;
          r = appendTypeParameters(r, getEffectiveTypeParameterDeclarations(d2));
        }
      }
      return r;
    }
    getTypeParametersOfClassOrInterface(): TypeParameter[] | undefined {
      return concatenate(this.getOuterTypeParametersOfClassOrInterface(), this.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias());
    }
    isThislessInterface() {
      const ds = this.declarations;
      if (ds) {
        for (const d of ds) {
          if (d.kind === Syntax.InterfaceDeclaration) {
            if (d.flags & NodeFlags.ContainsThis) return false;
            const ns = getInterfaceBaseTypeNodes(<InterfaceDeclaration>d);
            if (ns) {
              for (const n of ns) {
                if (isEntityNameExpression(n.expression)) {
                  const s = resolveEntityName(n.expression, SymbolFlags.Type, true);
                  if (!s || !(s.flags & SymbolFlags.Interface) || s.getDeclaredTypeOfClassOrInterface().thisType) return false;
                }
              }
            }
          }
        }
      }
      return true;
    }
    getDeclaredTypeOfClassOrInterface(): InterfaceType {
      let ls = this.getLinks();
      const originalLinks = ls;
      if (!ls.declaredType) {
        const kind = this.flags & SymbolFlags.Class ? ObjectFlags.Class : ObjectFlags.Interface;
        const merged = mergeJSSymbols(this, getAssignedClassSymbol(this.valueDeclaration));
        if (merged) symbol = ls = merged;
        const type = (originalLinks.declaredType = ls.declaredType = <InterfaceType>createObjectType(kind, this));
        const outerTypeParameters = this.getOuterTypeParametersOfClassOrInterface();
        const localTypeParameters = this.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias();
        if (outerTypeParameters || localTypeParameters || kind === ObjectFlags.Class || !isThislessInterface(this)) {
          type.objectFlags |= ObjectFlags.Reference;
          type.typeParameters = concatenate(outerTypeParameters, localTypeParameters);
          type.outerTypeParameters = outerTypeParameters;
          type.localTypeParameters = localTypeParameters;
          (<GenericType>type).instantiations = new qb.QMap<TypeReference>();
          (<GenericType>type).instantiations.set(getTypeListId(type.typeParameters), <GenericType>type);
          (<GenericType>type).target = <GenericType>type;
          (<GenericType>type).resolvedTypeArguments = type.typeParameters;
          type.thisType = createTypeParameter(this);
          type.thisType.isThisType = true;
          type.thisType.constraint = type;
        }
      }
      return <InterfaceType>ls.declaredType;
    }
    getDeclaredTypeOfTypeAlias(): Type {
      const ls = this.getLinks();
      if (!ls.declaredType) {
        if (!pushTypeResolution(this, TypeSystemPropertyName.DeclaredType)) return errorType;
        const d = Debug.checkDefined(find(this.declarations, isTypeAlias), 'Type alias symbol with no valid declaration found');
        const typeNode = qc.isDoc.typeAlias(d) ? d.typeExpression : d.type;
        let type = typeNode ? getTypeFromTypeNode(typeNode) : errorType;
        if (popTypeResolution()) {
          const ps = this.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias();
          if (ps) {
            ls.typeParameters = ps;
            ls.instantiations = new qb.QMap<Type>();
            ls.instantiations.set(getTypeListId(ps), type);
          }
        } else {
          type = errorType;
          error(qc.is.namedDeclaration(d) ? d.name : d || d, qd.Type_alias_0_circularly_references_itself, this.symbolToString());
        }
        ls.declaredType = type;
      }
      return ls.declaredType;
    }
    getEnumKind(): EnumKind {
      const ls = this.getLinks();
      if (ls.enumKind !== undefined) return ls.enumKind;
      let hasNonLiteralMember = false;
      for (const d of this.declarations ?? []) {
        if (d.kind === Syntax.EnumDeclaration) {
          for (const m of (<EnumDeclaration>d).members) {
            if (m.initializer && StringLiteral.like(m.initializer)) return (ls.enumKind = EnumKind.Literal);
            if (!isLiteralEnumMember(m)) hasNonLiteralMember = true;
          }
        }
      }
      return (ls.enumKind = hasNonLiteralMember ? EnumKind.Numeric : EnumKind.Literal);
    }
    getDeclaredTypeOfEnum(): Type {
      const ls = this.getLinks();
      if (ls.declaredType) return ls.declaredType;
      if (this.getEnumKind() === EnumKind.Literal) {
        enumCount++;
        const memberTypeList: Type[] = [];
        for (const d of this.declarations ?? []) {
          if (d.kind === Syntax.EnumDeclaration) {
            for (const m of (<EnumDeclaration>d).members) {
              const v = getEnumMemberValue(m);
              const t = getFreshTypeOfLiteralType(getLiteralType(v !== undefined ? v : 0, enumCount, getSymbolOfNode(m)));
              getSymbolOfNode(m).getLinks().declaredType = t;
              memberTypeList.push(getRegularTypeOfLiteralType(t));
            }
          }
        }
        if (memberTypeList.length) {
          const e = getUnionType(memberTypeList, UnionReduction.Literal, this, undefined);
          if (e.flags & TypeFlags.Union) {
            e.flags |= TypeFlags.EnumLiteral;
            e.symbol = this;
          }
          return (ls.declaredType = e);
        }
      }
      const e = createType(TypeFlags.Enum);
      e.symbol = this;
      return (ls.declaredType = e);
    }
    getDeclaredTypeOfEnumMember(): Type {
      const ls = this.getLinks();
      if (!ls.declaredType) {
        const e = this.getParentOfSymbol()!.getDeclaredTypeOfEnum();
        if (!ls.declaredType) ls.declaredType = e;
      }
      return ls.declaredType;
    }
    getDeclaredTypeOfTypeParameter(): TypeParameter {
      const ls = this.getLinks();
      return ls.declaredType || (ls.declaredType = createTypeParameter(this));
    }
    getDeclaredTypeOfAlias(): Type {
      const ls = this.getLinks();
      return ls.declaredType || (ls.declaredType = this.resolveAlias().getDeclaredTypeOfSymbol());
    }
    getDeclaredTypeOfSymbol(): Type {
      return this.tryGetDeclaredTypeOfSymbol() || errorType;
    }
    tryGetDeclaredTypeOfSymbol(): Type | undefined {
      if (this.flags & (SymbolFlags.Class | SymbolFlags.Interface)) return this.getDeclaredTypeOfClassOrInterface();
      if (this.flags & SymbolFlags.TypeAlias) return this.getDeclaredTypeOfTypeAlias();
      if (this.flags & SymbolFlags.TypeParameter) return this.getDeclaredTypeOfTypeParameter();
      if (this.flags & SymbolFlags.Enum) return this.getDeclaredTypeOfEnum();
      if (this.flags & SymbolFlags.EnumMember) return this.getDeclaredTypeOfEnumMember();
      if (this.flags & SymbolFlags.Alias) return this.getDeclaredTypeOfAlias();
      return;
    }
    isThisless() {
      if (this.declarations && this.declarations.length === 1) {
        const declaration = this.declarations[0];
        if (declaration) {
          switch (declaration.kind) {
            case Syntax.PropertyDeclaration:
            case Syntax.PropertySignature:
              return isThislessVariableLikeDeclaration(<VariableLikeDeclaration>declaration);
            case Syntax.MethodDeclaration:
            case Syntax.MethodSignature:
            case Syntax.Constructor:
            case Syntax.GetAccessor:
            case Syntax.SetAccessor:
              return isThislessFunctionLikeDeclaration(<FunctionLikeDeclaration | AccessorDeclaration>declaration);
          }
        }
      }
      return false;
    }
    getMembersOfSymbol() {
      return this.flags & SymbolFlags.LateBindingContainer ? getResolvedMembersOrExportsOfSymbol(this, MembersOrExportsResolutionKind.resolvedMembers) : this.members || emptySymbols;
    }
    getLateBoundSymbol(): QSymbol {
      if (this.flags & SymbolFlags.ClassMember && this.escName === InternalSymbolName.Computed) {
        const ls = this.getLinks();
        if (!ls.lateSymbol && some(this.declarations, hasLateBindableName)) {
          const parent = this.parent?.getMergedSymbol()!;
          if (some(this.declarations, hasStaticModifier)) parent.getExportsOfSymbol();
          else parent.getMembersOfSymbol();
        }
        return ls.lateSymbol || (ls.lateSymbol = this);
      }
      return this;
    }
    getIndexSymbol() {
      return this.members!.get(InternalSymbolName.Index);
    }
    getIndexDeclarationOfSymbol(k: IndexKind): IndexSignatureDeclaration | undefined {
      const syntaxKind = k === IndexKind.Number ? Syntax.NumberKeyword : Syntax.StringKeyword;
      const s = this.getIndexSymbol();
      if (s) {
        for (const d of s.declarations ?? []) {
          const n = cast(d, IndexSignatureDeclaration.kind);
          if (n.parameters.length === 1) {
            const p = n.parameters[0];
            if (p.type && p.type.kind === syntaxKind) return n;
          }
        }
      }
      return;
    }
    getIndexInfoOfSymbol(k: IndexKind): IndexInfo | undefined {
      const d = this.getIndexDeclarationOfSymbol(k);
      if (d) return createIndexInfo(d.type ? getTypeFromTypeNode(d.type) : anyType, hasEffectiveModifier(d, ModifierFlags.Readonly), d);
      return;
    }
    createUniqueESSymbolType() {
      const type = <UniqueESSymbolType>createType(TypeFlags.UniqueESSymbol);
      type.symbol = this;
      type.escName = `__@${this.escName}@${this.getId()}` as __String;
      return type;
    }
    getAliasVariances() {
      const ls = this.getLinks();
      return getVariancesWorker(ls.typeParameters, ls, (_links, param, marker) => {
        const type = getTypeAliasInstantiation(this, instantiateTypes(ls.typeParameters!, makeUnaryTypeMapper(param, marker)));
        type.aliasTypeArgumentsContainsMarker = true;
        return type;
      });
    }
    isParameterAssigned() {
      const f = getRootDeclaration(this.valueDeclaration).parent as FunctionLikeDeclaration;
      const ls = getNodeLinks(f);
      if (!(ls.flags & NodeCheckFlags.AssignmentsMarked)) {
        ls.flags |= NodeCheckFlags.AssignmentsMarked;
        if (!hasParentWithAssignmentsMarked(f)) markParameterAssignments(f);
      }
      return this.isAssigned || false;
    }
    isConstVariable() {
      return this.flags & SymbolFlags.Variable && (getDeclarationNodeFlagsFromSymbol(this) & NodeFlags.Const) !== 0 && this.getTypeOfSymbol() !== autoArrayType;
    }
    isCircularMappedProperty() {
      return !!(this.getCheckFlags() & CheckFlags.Mapped && !(this as MappedType).type && findResolutionCycleStartIndex(this, TypeSystemPropertyName.Type) >= 0);
    }
    getImmediateAliasedSymbol(): Symbol | undefined {
      assert((this.flags & SymbolFlags.Alias) !== 0, 'Should only get Alias here.');
      const ls = this.getLinks();
      if (!ls.immediateTarget) {
        const node = this.getDeclarationOfAliasSymbol();
        if (!node) return fail();
        ls.immediateTarget = getTargetOfAliasDeclaration(node, true);
      }
      return ls.immediateTarget;
    }
    isPrototypeProperty() {
      if (this.flags & SymbolFlags.Method || this.getCheckFlags() & CheckFlags.SyntheticMethod) return true;
      if (isInJSFile(this.valueDeclaration)) {
        const p = this.valueDeclaration?.parent;
        return p && qc.is.kind(BinaryExpression, p) && getAssignmentDeclarationKind(p) === AssignmentDeclarationKind.PrototypeProperty;
      }
    }
    symbolHasNonMethodDeclaration() {
      return !!forEachProperty(this, (p) => !(p.flags & SymbolFlags.Method));
    }
    getTypeOfParameter() {
      const t = this.getTypeOfSymbol();
      if (strictNullChecks) {
        const d = this.valueDeclaration;
        if (d && qc.is.withInitializer(d)) return getOptionalType(t);
      }
      return t;
    }
    isReadonlySymbol() {
      return !!(
        this.getCheckFlags() & CheckFlags.Readonly ||
        (this.flags & SymbolFlags.Property && this.getDeclarationModifierFlagsFromSymbol() & ModifierFlags.Readonly) ||
        (this.flags & SymbolFlags.Variable && this.getDeclarationNodeFlagsFromSymbol() & NodeFlags.Const) ||
        (this.flags & SymbolFlags.Accessor && !(this.flags & SymbolFlags.SetAccessor)) ||
        this.flags & SymbolFlags.EnumMember ||
        some(this.declarations, isReadonlyAssignmentDeclaration)
      );
    }
    isConstEnumSymbol() {
      return (this.flags & SymbolFlags.ConstEnum) !== 0;
    }
    checkFunctionOrConstructorSymbol(): void {
      if (!produceDiagnostics) return;
      function getCanonicalOverload(overloads: Declaration[], implementation: FunctionLikeDeclaration | undefined): Declaration {
        const implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
        return implementationSharesContainerWithFirstOverload ? implementation! : overloads[0];
      }
      function checkFlagAgreementBetweenOverloads(
        overloads: Declaration[],
        implementation: FunctionLikeDeclaration | undefined,
        flagsToCheck: ModifierFlags,
        someOverloadFlags: ModifierFlags,
        allOverloadFlags: ModifierFlags
      ): void {
        const someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
        if (someButNotAllOverloadFlags !== 0) {
          const canonicalFlags = getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck);
          forEach(overloads, (o) => {
            const deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;
            if (deviation & ModifierFlags.Export) error(getNameOfDeclaration(o), qd.Overload_signatures_must_all_be_exported_or_non_exported);
            else if (deviation & ModifierFlags.Ambient) {
              error(getNameOfDeclaration(o), qd.Overload_signatures_must_all_be_ambient_or_non_ambient);
            } else if (deviation & (ModifierFlags.Private | ModifierFlags.Protected)) {
              error(getNameOfDeclaration(o) || o, qd.Overload_signatures_must_all_be_public_private_or_protected);
            } else if (deviation & ModifierFlags.Abstract) {
              error(getNameOfDeclaration(o), qd.Overload_signatures_must_all_be_abstract_or_non_abstract);
            }
          });
        }
      }
      function checkQuestionTokenAgreementBetweenOverloads(
        overloads: Declaration[],
        implementation: FunctionLikeDeclaration | undefined,
        someHaveQuestionToken: boolean,
        allHaveQuestionToken: boolean
      ): void {
        if (someHaveQuestionToken !== allHaveQuestionToken) {
          const canonicalHasQuestionToken = hasQuestionToken(getCanonicalOverload(overloads, implementation));
          forEach(overloads, (o) => {
            const deviation = hasQuestionToken(o) !== canonicalHasQuestionToken;
            if (deviation) error(getNameOfDeclaration(o), qd.Overload_signatures_must_all_be_optional_or_required);
          });
        }
      }
      const flagsToCheck: ModifierFlags = ModifierFlags.Export | ModifierFlags.Ambient | ModifierFlags.Private | ModifierFlags.Protected | ModifierFlags.Abstract;
      let someNodeFlags: ModifierFlags = ModifierFlags.None;
      let allNodeFlags = flagsToCheck;
      let someHaveQuestionToken = false;
      let allHaveQuestionToken = true;
      let hasOverloads = false;
      let bodyDeclaration: FunctionLikeDeclaration | undefined;
      let lastSeenNonAmbientDeclaration: FunctionLikeDeclaration | undefined;
      let previousDeclaration: SignatureDeclaration | undefined;
      const declarations = this.declarations;
      const isConstructor = (this.flags & SymbolFlags.Constructor) !== 0;
      function reportImplementationExpectedError(node: SignatureDeclaration): void {
        if (node.name && qc.is.missing(node.name)) return;
        let seen = false;
        const subsequentNode = qc.forEach.child(node.parent, (c) => {
          if (seen) return c;
          seen = c === node;
        });
        if (subsequentNode && subsequentNode.pos === node.end) {
          if (subsequentNode.kind === node.kind) {
            const errorNode: Node = (<FunctionLikeDeclaration>subsequentNode).name || subsequentNode;
            const subsequentName = (<FunctionLikeDeclaration>subsequentNode).name;
            if (
              node.name &&
              subsequentName &&
              ((qc.is.kind(PrivateIdentifier, node.name) && qc.is.kind(PrivateIdentifier, subsequentName) && node.name.escapedText === subsequentName.escapedText) ||
                (qc.is.kind(ComputedPropertyName, node.name) && qc.is.kind(ComputedPropertyName, subsequentName)) ||
                (isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) && getEscapedTextOfIdentifierOrLiteral(node.name) === getEscapedTextOfIdentifierOrLiteral(subsequentName)))
            ) {
              const reportError =
                (node.kind === Syntax.MethodDeclaration || node.kind === Syntax.MethodSignature) &&
                hasSyntacticModifier(node, ModifierFlags.Static) !== hasSyntacticModifier(subsequentNode, ModifierFlags.Static);
              if (reportError) {
                const diagnostic = hasSyntacticModifier(node, ModifierFlags.Static) ? qd.Function_overload_must_be_static : qd.Function_overload_must_not_be_static;
                error(errorNode, diagnostic);
              }
              return;
            }
            if (qc.is.present((<FunctionLikeDeclaration>subsequentNode).body)) {
              error(errorNode, qd.Function_implementation_name_must_be_0, declarationNameToString(node.name));
              return;
            }
          }
        }
        const errorNode: Node = node.name || node;
        if (isConstructor) error(errorNode, qd.Constructor_implementation_is_missing);
        else {
          if (hasSyntacticModifier(node, ModifierFlags.Abstract)) error(errorNode, qd.All_declarations_of_an_abstract_method_must_be_consecutive);
          else error(errorNode, qd.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
        }
      }
      let duplicateFunctionDeclaration = false;
      let multipleConstructorImplementation = false;
      let hasNonAmbientClass = false;
      for (const current of declarations) {
        const node = <SignatureDeclaration | ClassDeclaration | ClassExpression>current;
        const inAmbientContext = node.flags & NodeFlags.Ambient;
        const inAmbientContextOrInterface = node.parent.kind === Syntax.InterfaceDeclaration || node.parent.kind === Syntax.TypeLiteral || inAmbientContext;
        if (inAmbientContextOrInterface) previousDeclaration = undefined;
        if ((node.kind === Syntax.ClassDeclaration || node.kind === Syntax.ClassExpression) && !inAmbientContext) hasNonAmbientClass = true;
        if (node.kind === Syntax.FunctionDeclaration || node.kind === Syntax.MethodDeclaration || node.kind === Syntax.MethodSignature || node.kind === Syntax.Constructor) {
          const currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
          someNodeFlags |= currentNodeFlags;
          allNodeFlags &= currentNodeFlags;
          someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node);
          allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node);
          if (qc.is.present((node as FunctionLikeDeclaration).body) && bodyDeclaration) {
            if (isConstructor) multipleConstructorImplementation = true;
            else duplicateFunctionDeclaration = true;
          } else if (previousDeclaration && previousDeclaration.parent === node.parent && previousDeclaration.end !== node.pos) {
            reportImplementationExpectedError(previousDeclaration);
          }
          if (qc.is.present((node as FunctionLikeDeclaration).body))
            if (!bodyDeclaration) bodyDeclaration = node as FunctionLikeDeclaration;
            else hasOverloads = true;
          previousDeclaration = node;
          if (!inAmbientContextOrInterface) lastSeenNonAmbientDeclaration = node as FunctionLikeDeclaration;
        }
      }
      if (multipleConstructorImplementation) {
        forEach(declarations, (declaration) => {
          error(declaration, qd.Multiple_constructor_implementations_are_not_allowed);
        });
      }
      if (duplicateFunctionDeclaration) {
        forEach(declarations, (declaration) => {
          error(getNameOfDeclaration(declaration), qd.Duplicate_function_implementation);
        });
      }
      if (hasNonAmbientClass && !isConstructor && this.flags & SymbolFlags.Function) {
        forEach(declarations, (declaration) => {
          addDuplicateDeclarationError(declaration, qd.Duplicate_identifier_0, this.name, declarations);
        });
      }
      if (
        lastSeenNonAmbientDeclaration &&
        !lastSeenNonAmbientDeclaration.body &&
        !hasSyntacticModifier(lastSeenNonAmbientDeclaration, ModifierFlags.Abstract) &&
        !lastSeenNonAmbientDeclaration.questionToken
      ) {
        reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
      }
      if (hasOverloads) {
        checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
        checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);
        if (bodyDeclaration) {
          const ss = this.getSignaturesOfSymbol();
          const bs = getSignatureFromDeclaration(bodyDeclaration);
          for (const s of ss) {
            if (!isImplementationCompatibleWithOverload(bs, s)) {
              addRelatedInfo(
                error(s.declaration, qd.This_overload_signature_is_not_compatible_with_its_implementation_signature),
                createDiagnosticForNode(bodyDeclaration, qd.The_implementation_signature_is_declared_here)
              );
              break;
            }
          }
        }
      }
    }
    checkTypeParameterListsIdentical() {
      if (this.declarations?.length === 1) return;
      const ls = this.getLinks();
      if (!ls.typeParametersChecked) {
        ls.typeParametersChecked = true;
        const ds = this.getClassOrInterfaceDeclarationsOfSymbol();
        if (!ds || ds.length <= 1) return;
        const t = this.getDeclaredTypeOfSymbol() as InterfaceType;
        if (!areTypeParametersIdentical(ds, t.localTypeParameters!)) {
          const n = this.symbolToString();
          for (const d of ds) {
            error(d.name, qd.All_declarations_of_0_must_have_identical_type_parameters, n);
          }
        }
      }
    }
    getTargetSymbol() {
      return this.getCheckFlags() & CheckFlags.Instantiated ? this.target! : this;
    }
    getClassOrInterfaceDeclarationsOfSymbol() {
      return filter(this.declarations, (d: Declaration): d is ClassDeclaration | InterfaceDeclaration => d.kind === Syntax.ClassDeclaration || d.kind === Syntax.InterfaceDeclaration);
    }
    getFirstNonAmbientClassOrFunctionDeclaration(): Declaration | undefined {
      for (const d of this.declarations ?? []) {
        if ((d.kind === Syntax.ClassDeclaration || (d.kind === Syntax.FunctionDeclaration && qc.is.present((<FunctionLikeDeclaration>d).body))) && !(d.flags & NodeFlags.Ambient)) return d;
      }
      return;
    }
    getRootSymbols(): readonly Symbol[] {
      const rs = this.getImmediateRootSymbols();
      return rs ? flatMap(rs, this.getRootSymbols) : [this];
    }
    getImmediateRootSymbols(): readonly Symbol[] | undefined {
      if (this.getCheckFlags() & CheckFlags.Synthetic) return mapDefined(this.getLinks().containingType!.types, (t) => getPropertyOfType(t, this.escName));
      if (this.flags & SymbolFlags.Transient) {
        const { leftSpread, rightSpread, syntheticOrigin } = this as TransientSymbol;
        return leftSpread ? [leftSpread, rightSpread!] : syntheticOrigin ? [syntheticOrigin] : singleElementArray(this.tryGetAliasTarget());
      }
      return;
    }
    tryGetAliasTarget(): Symbol | undefined {
      let target: Symbol | undefined;
      let next: Symbol | undefined = this;
      while ((next = next.getLinks().target)) {
        target = next;
      }
      return target;
    }
    isSymbolOfDestructuredElementOfCatchBinding() {
      return qc.is.kind(BindingElement, this.valueDeclaration) && walkUpBindingElementsAndPatterns(this.valueDeclaration).parent.kind === Syntax.CatchClause;
    }
    isSymbolOfDeclarationWithCollidingName() {
      if (this.flags & SymbolFlags.BlockScoped && !qc.is.kind(SourceFile, this.valueDeclaration)) {
        const ls = this.getLinks();
        if (ls.isDeclarationWithCollidingName === undefined) {
          const container = qc.get.enclosingBlockScopeContainer(this.valueDeclaration);
          if (qc.is.statementWithLocals(container) || this.isSymbolOfDestructuredElementOfCatchBinding()) {
            const nodeLinks = getNodeLinks(this.valueDeclaration);
            if (resolveName(container.parent, this.escName, SymbolFlags.Value, undefined, undefined, false)) ls.isDeclarationWithCollidingName = true;
            else if (nodeLinks.flags & NodeCheckFlags.CapturedBlockScopedBinding) {
              const isDeclaredInLoop = nodeLinks.flags & NodeCheckFlags.BlockScopedBindingInLoop;
              const inLoopInitializer = qc.is.iterationStatement(container, false);
              const inLoopBodyBlock = container.kind === Syntax.Block && qc.is.iterationStatement(container.parent, false);
              ls.isDeclarationWithCollidingName = !qc.is.blockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock));
            } else {
              ls.isDeclarationWithCollidingName = false;
            }
          }
        }
        return ls.isDeclarationWithCollidingName!;
      }
      return false;
    }
    isAliasResolvedToValue() {
      const target = this.resolveAlias();
      if (target === unknownSymbol) return true;
      return !!(target.flags & SymbolFlags.Value) && (compilerOptions.preserveConstEnums || !isConstEnumOrConstEnumOnlyModule(target));
    }
    isConstEnumOrConstEnumOnlyModule() {
      return this.isConstEnumSymbol() || !!this.constEnumOnlyModule;
    }
    getTypeReferenceDirectivesForSymbol(meaning?: SymbolFlags): string[] | undefined {
      if (!fileToDirective) return;
      if (!this.isSymbolFromTypeDeclarationFile()) return;
      let typeReferenceDirectives: string[] | undefined;
      for (const d of this.declarations ?? []) {
        if (d.symbol && d.symbol.flags & meaning!) {
          const file = qc.get.sourceFileOf(d);
          const typeReferenceDirective = fileToDirective.get(file.path);
          if (typeReferenceDirective) (typeReferenceDirectives || (typeReferenceDirectives = [])).push(typeReferenceDirective);
          else return;
        }
      }
      return typeReferenceDirectives;
    }
    isSymbolFromTypeDeclarationFile() {
      if (!this.declarations) return false;
      let current = this;
      while (true) {
        const p = current.getParentOfSymbol();
        if (p) current = p;
        else break;
      }
      if (current.valueDeclaration && current.valueDeclaration.kind === Syntax.SourceFile && current.flags & SymbolFlags.ValueModule) return false;
      for (const d of this.declarations) {
        const f = qc.get.sourceFileOf(d);
        if (fileToDirective.has(f.path)) return true;
      }
      return false;
    }
    checkSymbolUsageInExpressionContext(name: __String, useSite: Node) {
      if (!isValidTypeOnlyAliasUseSite(useSite)) {
        const typeOnlyDeclaration = this.getTypeOnlyAliasDeclaration();
        if (typeOnlyDeclaration) {
          const isExport = typeOnlyDeclarationIsExport(typeOnlyDeclaration);
          const message = isExport ? qd._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type : qd._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type;
          const relatedMessage = isExport ? qd._0_was_exported_here : qd._0_was_imported_here;
          const unescName = syntax.get.unescUnderscores(name);
          addRelatedInfo(error(useSite, message, unescName), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, unescName));
        }
      }
    }
    isTypeParameterSymbolDeclaredInContainer(container: Node) {
      for (const d of this.declarations) {
        if (d.kind === Syntax.TypeParameter) {
          const p = qc.is.kind(JSDocTemplateTag, d.parent) ? qc.getDoc.host(d.parent) : d.parent;
          if (p === container) return !(qc.is.kind(JSDocTemplateTag, d.parent) && find((d.parent.parent as JSDoc).tags!, isJSDocTypeAlias));
        }
      }
      return false;
    }
    getExportOfModule(specifier: ImportOrExportSpecifier, dontResolveAlias: boolean): Symbol | undefined {
      if (this.flags & SymbolFlags.Module) {
        const name = (specifier.propertyName ?? specifier.name).escapedText;
        const exportSymbol = this.getExportsOfSymbol().get(name);
        const resolved = exportSymbol.resolveSymbol(dontResolveAlias);
        markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved, false);
        return resolved;
      }
      return;
    }
    getPropertyOfVariable(name: __String): Symbol | undefined {
      if (this.flags & SymbolFlags.Variable) {
        const typeAnnotation = (<VariableDeclaration>this.valueDeclaration).type;
        if (typeAnnotation) return getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name)?.resolveSymbol();
      }
      return;
    }
    getFullyQualifiedName(containingLocation?: Node): string {
      return this.parent
        ? getFullyQualifiedName(this.parent, containingLocation) + '.' + this.symbolToString()
        : this.symbolToString(containingLocation, undefined, SymbolFormatFlags.DoNotIncludeSymbolChain | SymbolFormatFlags.AllowAnyNodeKind);
    }
    getAliasForSymbolInContainer(container: Symbol) {
      if (container === this.getParentOfSymbol()) return this;
      const exportEquals = container.exports && container.exports.get(InternalSymbolName.ExportEquals);
      if (exportEquals && getSymbolIfSameReference(exportEquals, this)) return container;
      const exports = container.getExportsOfSymbol();
      const quick = exports.get(this.escName);
      if (quick && getSymbolIfSameReference(quick, this)) return quick;
      return forEachEntry(exports, (exported) => {
        if (getSymbolIfSameReference(exported, this)) return exported;
      });
    }
    hasVisibleDeclarations(shouldComputeAliasToMakeVisible: boolean): SymbolVisibilityResult | undefined {
      let aliasesToMakeVisible: LateVisibilityPaintedStatement[] | undefined;
      if (
        !every(
          filter(this.declarations, (d) => d.kind !== Syntax.Identifier),
          getIsDeclarationVisible
        )
      ) {
        return;
      }
      return { accessibility: SymbolAccessibility.Accessible, aliasesToMakeVisible };
      function getIsDeclarationVisible(declaration: Declaration) {
        if (!isDeclarationVisible(declaration)) {
          const anyImportSyntax = getAnyImportSyntax(declaration);
          if (anyImportSyntax && !hasSyntacticModifier(anyImportSyntax, ModifierFlags.Export) && isDeclarationVisible(anyImportSyntax.parent)) return addVisibleAlias(declaration, anyImportSyntax);
          else if (
            qc.is.kind(VariableDeclaration, declaration) &&
            qc.is.kind(VariableStatement, declaration.parent.parent) &&
            !hasSyntacticModifier(declaration.parent.parent, ModifierFlags.Export) &&
            isDeclarationVisible(declaration.parent.parent.parent)
          ) {
            return addVisibleAlias(declaration, declaration.parent.parent);
          } else if (qc.is.lateVisibilityPaintedStatement(declaration) && !hasSyntacticModifier(declaration, ModifierFlags.Export) && isDeclarationVisible(declaration.parent)) {
            return addVisibleAlias(declaration, declaration);
          }
          return false;
        }
        return true;
      }
      function addVisibleAlias(declaration: Declaration, aliasingStatement: LateVisibilityPaintedStatement) {
        if (shouldComputeAliasToMakeVisible) {
          getNodeLinks(declaration).isVisible = true;
          aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement);
        }
        return true;
      }
    }
    getDeclarationWithTypeAnnotation(enclosingDeclaration: Node | undefined) {
      return this.declarations && find(this.declarations, (s) => !!getEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!Node.findAncestor(s, (n) => n === enclosingDeclaration)));
    }
    getNameOfSymbolFromNameType(c?: QContext) {
      const nameType = this.getLinks().nameType;
      if (nameType) {
        if (nameType.flags & TypeFlags.StringOrNumberLiteral) {
          const name = '' + (<StringLiteralType | NumberLiteralType>nameType).value;
          if (!syntax.is.identifierText(name) && !NumericLiteral.name(name)) return `"${escapeString(name, Codes.doubleQuote)}"`;
          if (NumericLiteral.name(name) && startsWith(name, '-')) return `[${name}]`;
          return name;
        }
        if (nameType.flags & TypeFlags.UniqueESSymbol) return `[${getNameOfSymbolAsWritten((<UniqueESSymbolType>nameType).symbol, c)}]`;
      }
    }
    getNameOfSymbolAsWritten(c?: QContext): string {
      if (
        c &&
        this.escName === InternalSymbolName.Default &&
        !(c.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope) &&
        (!(c.flags & NodeBuilderFlags.InInitialEntityName) ||
          !this.declarations ||
          (c.enclosingDeclaration && Node.findAncestor(this.declarations[0], isDefaultBindingContext) !== Node.findAncestor(c.enclosingDeclaration, isDefaultBindingContext)))
      ) {
        return 'default';
      }
      if (this.declarations && this.declarations.length) {
        let d = firstDefined(this.declarations, (d) => (getNameOfDeclaration(d) ? d : undefined));
        const name = d && getNameOfDeclaration(d);
        if (d && name) {
          if (qc.is.kind(CallExpression, d) && isBindableObjectDefinePropertyCall(d)) return this.name;
          if (qc.is.kind(ComputedPropertyName, name) && !(this.getCheckFlags() & CheckFlags.Late)) {
            const nameType = this.getLinks().nameType;
            if (nameType && nameType.flags & TypeFlags.StringOrNumberLiteral) {
              const result = getNameOfSymbolFromNameType(this, c);
              if (result !== undefined) return result;
            }
          }
          return declarationNameToString(name);
        }
        if (!d) d = this.declarations[0];
        if (d.parent && d.parent.kind === Syntax.VariableDeclaration) return declarationNameToString((<VariableDeclaration>d.parent).name);
        switch (d.kind) {
          case Syntax.ClassExpression:
          case Syntax.FunctionExpression:
          case Syntax.ArrowFunction:
            if (c && !c.encounteredError && !(c.flags & NodeBuilderFlags.AllowAnonymousIdentifier)) c.encounteredError = true;
            return d.kind === Syntax.ClassExpression ? '(Anonymous class)' : '(Anonymous function)';
        }
      }
      const n = getNameOfSymbolFromNameType(this, c);
      return n !== undefined ? n : this.name;
    }
  }
  class QSymbolTable extends SymbolTable<QSymbol> {
    getSymbol(symbols: SymbolTable, name: __String, meaning: SymbolFlags): Symbol | undefined {
      if (meaning) {
        const symbol = getMergedSymbol(symbols.get(name));
        if (symbol) {
          assert((this.getCheckFlags() & CheckFlags.Instantiated) === 0, 'Should never get an instantiated symbol here.');
          if (symbol.flags & meaning) return symbol;
          if (symbol.flags & SymbolFlags.Alias) {
            const target = this.resolveAlias();
            if (target === unknownSymbol || target.flags & meaning) return symbol;
          }
        }
      }
    }
    visitSymbolTable(symbolTable: SymbolTable, suppressNewPrivateContext?: boolean, propertyAsAlias?: boolean) {
      const oldDeferredPrivates = deferredPrivates;
      if (!suppressNewPrivateContext) deferredPrivates = new qb.QMap();
      symbolTable.forEach((s: Symbol) => {
        serializeSymbol(symbol, false, !!propertyAsAlias);
      });
      if (!suppressNewPrivateContext) {
        deferredPrivates!.forEach((s: Symbol) => {
          serializeSymbol(symbol, true, !!propertyAsAlias);
        });
      }
      deferredPrivates = oldDeferredPrivates;
    }
  }
  const globals = new QSymbolTable();
  const undefinedSymbol = new QSymbol(SymbolFlags.Property, 'undefined' as __String);
  undefinedSymbol.declarations = [];
  const globalThisSymbol = new QSymbol(SymbolFlags.Module, 'globalThis' as __String, CheckFlags.Readonly);
  globalThisSymbol.exports = globals;
  globalThisSymbol.declarations = [];
  globals.set(globalThisSymbol.escName, globalThisSymbol);
  const argumentsSymbol = new QSymbol(SymbolFlags.Property, 'arguments' as __String);
  const requireSymbol = new QSymbol(SymbolFlags.Property, 'require' as __String);
  let apparentArgumentCount: number | undefined;
  const checker: TypeChecker = {
    getNodeCount: () => sum(host.getSourceFiles(), 'nodeCount'),
    getIdentifierCount: () => sum(host.getSourceFiles(), 'identifierCount'),
    getSymbolCount: () => sum(host.getSourceFiles(), 'symbolCount') + QSymbol.count,
    getTypeCount: () => QType.typeCount,
    getInstantiationCount: () => totalInstantiationCount,
    getRelationCacheSizes: () => ({
      assignable: assignableRelation.size,
      identity: identityRelation.size,
      subtype: subtypeRelation.size,
      strictSubtype: strictSubtypeRelation.size,
    }),
    isUndefinedSymbol: (symbol) => symbol === undefinedSymbol,
    isArgumentsSymbol: (symbol) => symbol === argumentsSymbol,
    isUnknownSymbol: (symbol) => symbol === unknownSymbol,
    getMergedSymbol,
    getDiagnostics,
    getGlobalDiagnostics,
    getTypeOfSymbolAtLocation: (symbol, location) => {
      location = qc.get.parseTreeOf(location);
      return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;
    },
    getSymbolsOfParameterPropertyDeclaration: (parameterIn, parameterName) => {
      const parameter = qc.get.parseTreeOf(parameterIn, isParameter);
      if (parameter === undefined) return fail('Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.');
      return getSymbolsOfParameterPropertyDeclaration(parameter, syntax.get.escUnderscores(parameterName));
    },
    getDeclaredTypeOfSymbol,
    getPropertiesOfType,
    getPropertyOfType: (type, name) => getPropertyOfType(type, syntax.get.escUnderscores(name)),
    getPrivateIdentifierPropertyOfType: (leftType: Type, name: string, location: Node) => {
      const node = qc.get.parseTreeOf(location);
      if (!node) return;
      const propName = syntax.get.escUnderscores(name);
      const lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);
      return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined;
    },
    getTypeOfPropertyOfType: (type, name) => getTypeOfPropertyOfType(type, syntax.get.escUnderscores(name)),
    getIndexInfoOfType,
    getSignaturesOfType,
    getIndexTypeOfType,
    getBaseTypes,
    getBaseTypeOfLiteralType,
    getWidenedType,
    getTypeFromTypeNode: (nodeIn) => {
      const node = qc.get.parseTreeOf(nodeIn, isTypeNode);
      return node ? getTypeFromTypeNode(node) : errorType;
    },
    getParameterType: getTypeAtPosition,
    getPromisedTypeOfPromise,
    getAwaitedType: (type) => getAwaitedType(type),
    getReturnTypeOfSignature,
    isNullableType,
    getNullableType,
    getNonNullableType,
    getNonOptionalType: removeOptionalTypeMarker,
    getTypeArguments,
    typeToTypeNode: nodeBuilder.typeToTypeNode,
    indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,
    signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,
    symbolToEntityName: nodeBuilder.symbolToEntityName,
    symbolToExpression: nodeBuilder.symbolToExpression,
    symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,
    symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,
    typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,
    getSymbolsInScope: (location, meaning) => {
      location = qc.get.parseTreeOf(location);
      return location ? getSymbolsInScope(location, meaning) : [];
    },
    getSymbolAtLocation: (node) => {
      node = qc.get.parseTreeOf(node);
      return node ? getSymbolAtLocation(node, true) : undefined;
    },
    getShorthandAssignmentValueSymbol: (node) => {
      node = qc.get.parseTreeOf(node);
      return node ? getShorthandAssignmentValueSymbol(node) : undefined;
    },
    getExportSpecifierLocalTargetSymbol: (nodeIn) => {
      const node = qc.get.parseTreeOf(nodeIn, isExportSpecifier);
      return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;
    },
    getExportSymbolOfSymbol(symbol) {
      return getMergedSymbol(symbol.exportSymbol || symbol);
    },
    getTypeAtLocation: (node) => {
      node = qc.get.parseTreeOf(node);
      return node ? getTypeOfNode(node) : errorType;
    },
    getTypeOfAssignmentPattern: (nodeIn) => {
      const node = qc.get.parseTreeOf(nodeIn, isAssignmentPattern);
      return (node && getTypeOfAssignmentPattern(node)) || errorType;
    },
    getPropertySymbolOfDestructuringAssignment: (locationIn) => {
      const location = qc.get.parseTreeOf(locationIn, isIdentifier);
      return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;
    },
    signatureToString: (signature, enclosingDeclaration, flags, kind) => {
      return signatureToString(signature, qc.get.parseTreeOf(enclosingDeclaration), flags, kind);
    },
    typeToString: (type, enclosingDeclaration, flags) => {
      return typeToString(type, qc.get.parseTreeOf(enclosingDeclaration), flags);
    },
    symbolToString: (symbol, enclosingDeclaration, meaning, flags) => {
      return symbol.symbolToString(qc.get.parseTreeOf(enclosingDeclaration), meaning, flags);
    },
    typePredicateToString: (predicate, enclosingDeclaration, flags) => {
      return typePredicateToString(predicate, qc.get.parseTreeOf(enclosingDeclaration), flags);
    },
    writeSignature: (signature, enclosingDeclaration, flags, kind, writer) => {
      return signatureToString(signature, qc.get.parseTreeOf(enclosingDeclaration), flags, kind, writer);
    },
    writeType: (type, enclosingDeclaration, flags, writer) => {
      return typeToString(type, qc.get.parseTreeOf(enclosingDeclaration), flags, writer);
    },
    writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => {
      return symbol.symbolToString(qc.get.parseTreeOf(enclosingDeclaration), meaning, flags, writer);
    },
    writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => {
      return typePredicateToString(predicate, qc.get.parseTreeOf(enclosingDeclaration), flags, writer);
    },
    getAugmentedPropertiesOfType,
    getRootSymbols,
    getContextualType: (nodeIn: Expression, contextFlags?: ContextFlags) => {
      const node = qc.get.parseTreeOf(nodeIn, isExpression);
      if (!node) return;
      const containingCall = Node.findAncestor(node, isCallLikeExpression);
      const containingCallResolvedSignature = containingCall && getNodeLinks(containingCall).resolvedSignature;
      if (contextFlags! & ContextFlags.Completions && containingCall) {
        let toMarkSkip = node as Node;
        do {
          getNodeLinks(toMarkSkip).skipDirectInference = true;
          toMarkSkip = toMarkSkip.parent;
        } while (toMarkSkip && toMarkSkip !== containingCall);
        getNodeLinks(containingCall).resolvedSignature = undefined;
      }
      const result = getContextualType(node, contextFlags);
      if (contextFlags! & ContextFlags.Completions && containingCall) {
        let toMarkSkip = node as Node;
        do {
          getNodeLinks(toMarkSkip).skipDirectInference = undefined;
          toMarkSkip = toMarkSkip.parent;
        } while (toMarkSkip && toMarkSkip !== containingCall);
        getNodeLinks(containingCall).resolvedSignature = containingCallResolvedSignature;
      }
      return result;
    },
    getContextualTypeForObjectLiteralElement: (nodeIn) => {
      const node = qc.get.parseTreeOf(nodeIn, isObjectLiteralElementLike);
      return node ? getContextualTypeForObjectLiteralElement(node) : undefined;
    },
    getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => {
      const node = qc.get.parseTreeOf(nodeIn, isCallLikeExpression);
      return node && getContextualTypeForArgumentAtIndex(node, argIndex);
    },
    getContextualTypeForJsxAttribute: (nodeIn) => {
      const node = qc.get.parseTreeOf(nodeIn, isJsxAttributeLike);
      return node && getContextualTypeForJsxAttribute(node);
    },
    isContextSensitive,
    getFullyQualifiedName,
    getResolvedSignature: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.Normal),
    getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.IsForSignatureHelp),
    getExpandedParameters,
    hasEffectiveRestParameter,
    getConstantValue: (nodeIn) => {
      const node = qc.get.parseTreeOf(nodeIn, canHaveConstantValue);
      return node ? getConstantValue(node) : undefined;
    },
    isValidPropertyAccess: (nodeIn, propertyName) => {
      const node = qc.get.parseTreeOf(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode);
      return !!node && isValidPropertyAccess(node, syntax.get.escUnderscores(propertyName));
    },
    isValidPropertyAccessForCompletions: (nodeIn, type, property) => {
      const node = qc.get.parseTreeOf(nodeIn, isPropertyAccessExpression);
      return !!node && isValidPropertyAccessForCompletions(node, type, property);
    },
    getSignatureFromDeclaration: (declarationIn) => {
      const declaration = qc.get.parseTreeOf(declarationIn, isFunctionLike);
      return declaration ? getSignatureFromDeclaration(declaration) : undefined;
    },
    isImplementationOfOverload: (node) => {
      const parsed = qc.get.parseTreeOf(node, isFunctionLike);
      return parsed ? isImplementationOfOverload(parsed) : undefined;
    },
    getImmediateAliasedSymbol,
    getAliasedSymbol: resolveAlias,
    getEmitResolver,
    getExportsOfModule: getExportsOfModuleAsArray,
    getExportsAndPropertiesOfModule,
    getSymbolWalker: createGetSymbolWalker(
      getRestTypeOfSignature,
      getTypePredicateOfSignature,
      getReturnTypeOfSignature,
      getBaseTypes,
      resolveStructuredTypeMembers,
      getTypeOfSymbol,
      getResolvedSymbol,
      getIndexTypeOfStructuredType,
      getConstraintOfTypeParameter,
      getFirstIdentifier,
      getTypeArguments
    ),
    getAmbientModules,
    getJsxIntrinsicTagNamesAt,
    isOptionalParameter: (nodeIn) => {
      const node = qc.get.parseTreeOf(nodeIn, isParameter);
      return node ? isOptionalParameter(node) : false;
    },
    tryGetMemberInModuleExports: (name, symbol) => tryGetMemberInModuleExports(syntax.get.escUnderscores(name), symbol),
    tryGetMemberInModuleExportsAndProperties: (name, symbol) => tryGetMemberInModuleExportsAndProperties(syntax.get.escUnderscores(name), symbol),
    tryFindAmbientModuleWithoutAugmentations: (moduleName) => {
      return tryFindAmbientModule(moduleName, false);
    },
    getApparentType,
    getUnionType,
    isTypeAssignableTo,
    createAnonymousType,
    createSignature,
    createSymbol,
    createIndexInfo,
    getAnyType: () => anyType,
    getStringType: () => stringType,
    getNumberType: () => numberType,
    createPromiseType,
    createArrayType,
    getElementTypeOfArrayType,
    getBooleanType: () => booleanType,
    getFalseType: (fresh?) => (fresh ? falseType : regularFalseType),
    getTrueType: (fresh?) => (fresh ? trueType : regularTrueType),
    getVoidType: () => voidType,
    getUndefinedType: () => undefinedType,
    getNullType: () => nullType,
    getESSymbolType: () => esSymbolType,
    getNeverType: () => neverType,
    getOptionalType: () => optionalType,
    isSymbolAccessible,
    isArrayType,
    isTupleType,
    isArrayLikeType,
    isTypeInvalidDueToUnionDiscriminant,
    getAllPossiblePropertiesOfTypes,
    getSuggestedSymbolForNonexistentProperty,
    getSuggestionForNonexistentProperty,
    getSuggestedSymbolForNonexistentSymbol: (location, name, meaning) => getSuggestedSymbolForNonexistentSymbol(location, syntax.get.escUnderscores(name), meaning),
    getSuggestionForNonexistentSymbol: (location, name, meaning) => getSuggestionForNonexistentSymbol(location, syntax.get.escUnderscores(name), meaning),
    getSuggestedSymbolForNonexistentModule,
    getSuggestionForNonexistentExport,
    getBaseConstraintOfType,
    getDefaultFromTypeParameter: (type) => (type && type.flags & TypeFlags.TypeParameter ? getDefaultFromTypeParameter(type as TypeParameter) : undefined),
    resolveName(name, location, meaning, excludeGlobals) {
      return resolveName(location, syntax.get.escUnderscores(name), meaning, undefined, undefined, false, excludeGlobals);
    },
    getJsxNamespace: (n) => syntax.get.unescUnderscores(getJsxNamespace(n)),
    getAccessibleSymbolChain,
    getTypePredicateOfSignature,
    resolveExternalModuleName: (moduleSpecifier) => {
      return resolveExternalModuleName(moduleSpecifier, moduleSpecifier, true);
    },
    resolveExternalModuleSymbol,
    tryGetThisTypeAt: (node, includeGlobalThis) => {
      node = qc.get.parseTreeOf(node);
      return node && tryGetThisTypeAt(node, includeGlobalThis);
    },
    getTypeArgumentConstraint: (nodeIn) => {
      const node = qc.get.parseTreeOf(nodeIn, isTypeNode);
      return node && getTypeArgumentConstraint(node);
    },
    getSuggestionDiagnostics: (file, ct) => {
      if (skipTypeChecking(file, compilerOptions, host)) return empty;
      let diagnostics: DiagnosticWithLocation[] | undefined;
      try {
        cancellationToken = ct;
        checkSourceFile(file);
        assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked));
        diagnostics = addRange(diagnostics, suggestionqd.getDiagnostics(file.fileName));
        checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => {
          if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient)))
            (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion });
        });
        return diagnostics || empty;
      } finally {
        cancellationToken = undefined;
      }
    },
    runWithCancellationToken: (token, callback) => {
      try {
        cancellationToken = token;
        return callback(checker);
      } finally {
        cancellationToken = undefined;
      }
    },
    getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,
    isDeclarationVisible,
  };
  function getResolvedSignatureWorker(nodeIn: CallLikeExpression, candidatesOutArray: Signature[] | undefined, argumentCount: number | undefined, checkMode: CheckMode): Signature | undefined {
    const node = qc.get.parseTreeOf(nodeIn, isCallLikeExpression);
    apparentArgumentCount = argumentCount;
    const res = node ? getResolvedSignature(node, candidatesOutArray, checkMode) : undefined;
    apparentArgumentCount = undefined;
    return res;
  }
  const tupleTypes = new qb.QMap<GenericType>();
  const unionTypes = new qb.QMap<UnionType>();
  const intersectionTypes = new qb.QMap<Type>();
  const literalTypes = new qb.QMap<LiteralType>();
  const indexedAccessTypes = new qb.QMap<IndexedAccessType>();
  const substitutionTypes = new qb.QMap<SubstitutionType>();
  const evolvingArrayTypes: EvolvingArrayType[] = [];
  const undefinedProperties = new qb.QMap<Symbol>() as UnderscoreEscapedMap<Symbol>;
  const unknownSymbol = new QSymbol(SymbolFlags.Property, 'unknown' as __String);
  const resolvingSymbol = new QSymbol(0, InternalSymbolName.Resolving);
  const anyType = createIntrinsicType(TypeFlags.Any, 'any');
  const autoType = createIntrinsicType(TypeFlags.Any, 'any');
  const wildcardType = createIntrinsicType(TypeFlags.Any, 'any');
  const errorType = createIntrinsicType(TypeFlags.Any, 'error');
  const nonInferrableAnyType = createIntrinsicType(TypeFlags.Any, 'any', ObjectFlags.ContainsWideningType);
  const unknownType = createIntrinsicType(TypeFlags.Unknown, 'unknown');
  const undefinedType = createIntrinsicType(TypeFlags.Undefined, 'undefined');
  const undefinedWideningType = strictNullChecks ? undefinedType : createIntrinsicType(TypeFlags.Undefined, 'undefined', ObjectFlags.ContainsWideningType);
  const optionalType = createIntrinsicType(TypeFlags.Undefined, 'undefined');
  const nullType = createIntrinsicType(TypeFlags.Null, 'null');
  const nullWideningType = strictNullChecks ? nullType : createIntrinsicType(TypeFlags.Null, 'null', ObjectFlags.ContainsWideningType);
  const stringType = createIntrinsicType(TypeFlags.String, 'string');
  const numberType = createIntrinsicType(TypeFlags.Number, 'number');
  const bigintType = createIntrinsicType(TypeFlags.BigInt, 'bigint');
  const falseType = createIntrinsicType(TypeFlags.BooleanLiteral, 'false') as FreshableIntrinsicType;
  const regularFalseType = createIntrinsicType(TypeFlags.BooleanLiteral, 'false') as FreshableIntrinsicType;
  const trueType = createIntrinsicType(TypeFlags.BooleanLiteral, 'true') as FreshableIntrinsicType;
  const regularTrueType = createIntrinsicType(TypeFlags.BooleanLiteral, 'true') as FreshableIntrinsicType;
  trueType.regularType = regularTrueType;
  trueType.freshType = trueType;
  regularTrueType.regularType = regularTrueType;
  regularTrueType.freshType = trueType;
  falseType.regularType = regularFalseType;
  falseType.freshType = falseType;
  regularFalseType.regularType = regularFalseType;
  regularFalseType.freshType = falseType;
  const booleanType = createBooleanType([regularFalseType, regularTrueType]);
  createBooleanType([regularFalseType, trueType]);
  createBooleanType([falseType, regularTrueType]);
  createBooleanType([falseType, trueType]);
  const esSymbolType = createIntrinsicType(TypeFlags.ESSymbol, 'symbol');
  const voidType = createIntrinsicType(TypeFlags.Void, 'void');
  const neverType = createIntrinsicType(TypeFlags.Never, 'never');
  const silentNeverType = createIntrinsicType(TypeFlags.Never, 'never');
  const nonInferrableType = createIntrinsicType(TypeFlags.Never, 'never', ObjectFlags.NonInferrableType);
  const implicitNeverType = createIntrinsicType(TypeFlags.Never, 'never');
  const unreachableNeverType = createIntrinsicType(TypeFlags.Never, 'never');
  const nonPrimitiveType = createIntrinsicType(TypeFlags.NonPrimitive, 'object');
  const stringNumberSymbolType = getUnionType([stringType, numberType, esSymbolType]);
  const keyofConstraintType = keyofStringsOnly ? stringType : stringNumberSymbolType;
  const numberOrBigIntType = getUnionType([numberType, bigintType]);
  const restrictiveMapper: TypeMapper = makeFunctionTypeMapper((t) => (t.flags & TypeFlags.TypeParameter ? getRestrictiveTypeParameter(<TypeParameter>t) : t));
  const permissiveMapper: TypeMapper = makeFunctionTypeMapper((t) => (t.flags & TypeFlags.TypeParameter ? wildcardType : t));
  const emptyObjectType = createAnonymousType(undefined, emptySymbols, empty, empty, undefined, undefined);
  const emptyJsxObjectType = createAnonymousType(undefined, emptySymbols, empty, empty, undefined, undefined);
  emptyJsxObjectType.objectFlags |= ObjectFlags.JsxAttributes;
  const emptyTypeLiteralSymbol = new QSymbol(SymbolFlags.TypeLiteral, InternalSymbolName.Type);
  emptyTypeLiteralSymbol.members = new SymbolTable();
  const emptyTypeLiteralType = createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, empty, empty, undefined, undefined);
  const emptyGenericType = <GenericType>(<ObjectType>createAnonymousType(undefined, emptySymbols, empty, empty, undefined, undefined));
  emptyGenericType.instantiations = new qb.QMap<TypeReference>();
  const anyFunctionType = createAnonymousType(undefined, emptySymbols, empty, empty, undefined, undefined);
  anyFunctionType.objectFlags |= ObjectFlags.NonInferrableType;
  const noConstraintType = createAnonymousType(undefined, emptySymbols, empty, empty, undefined, undefined);
  const circularConstraintType = createAnonymousType(undefined, emptySymbols, empty, empty, undefined, undefined);
  const resolvingDefaultType = createAnonymousType(undefined, emptySymbols, empty, empty, undefined, undefined);
  const markerSuperType = createTypeParameter();
  const markerSubType = createTypeParameter();
  markerSubType.constraint = markerSuperType;
  const markerOtherType = createTypeParameter();
  const noTypePredicate = createTypePredicate(TypePredicateKind.Identifier, '<<unresolved>>', 0, anyType);
  const anySignature = createSignature(undefined, undefined, undefined, empty, anyType, undefined, 0, SignatureFlags.None);
  const unknownSignature = createSignature(undefined, undefined, undefined, empty, errorType, undefined, 0, SignatureFlags.None);
  const resolvingSignature = createSignature(undefined, undefined, undefined, empty, anyType, undefined, 0, SignatureFlags.None);
  const silentNeverSignature = createSignature(undefined, undefined, undefined, empty, silentNeverType, undefined, 0, SignatureFlags.None);
  const enumNumberIndexInfo = createIndexInfo(stringType, true);
  const iterationTypesCache = new qb.QMap<IterationTypes>();
  const noIterationTypes: IterationTypes = {
    get yieldType(): Type {
      return fail('Not supported');
    },
    get returnType(): Type {
      return fail('Not supported');
    },
    get nextType(): Type {
      return fail('Not supported');
    },
  };
  const anyIterationTypes = createIterationTypes(anyType, anyType, anyType);
  const anyIterationTypesExceptNext = createIterationTypes(anyType, anyType, unknownType);
  const defaultIterationTypes = createIterationTypes(neverType, anyType, undefinedType);
  const asyncIterationTypesResolver: IterationTypesResolver = {
    iterableCacheKey: 'iterationTypesOfAsyncIterable',
    iteratorCacheKey: 'iterationTypesOfAsyncIterator',
    iteratorSymbolName: 'asyncIterator',
    getGlobalIteratorType: getGlobalAsyncIteratorType,
    getGlobalIterableType: getGlobalAsyncIterableType,
    getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,
    getGlobalGeneratorType: getGlobalAsyncGeneratorType,
    resolveIterationType: getAwaitedType,
    mustHaveANextMethodDiagnostic: qd.An_async_iterator_must_have_a_next_method,
    mustBeAMethodDiagnostic: qd.The_0_property_of_an_async_iterator_must_be_a_method,
    mustHaveAValueDiagnostic: qd.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,
  };
  const syncIterationTypesResolver: IterationTypesResolver = {
    iterableCacheKey: 'iterationTypesOfIterable',
    iteratorCacheKey: 'iterationTypesOfIterator',
    iteratorSymbolName: 'iterator',
    getGlobalIteratorType,
    getGlobalIterableType,
    getGlobalIterableIteratorType,
    getGlobalGeneratorType,
    resolveIterationType: (type, _errorNode) => type,
    mustHaveANextMethodDiagnostic: qd.An_iterator_must_have_a_next_method,
    mustBeAMethodDiagnostic: qd.The_0_property_of_an_iterator_must_be_a_method,
    mustHaveAValueDiagnostic: qd.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,
  };
  interface DuplicateInfoForSymbol {
    readonly firstFileLocations: Declaration[];
    readonly secondFileLocations: Declaration[];
    readonly isBlockScoped: boolean;
  }
  interface DuplicateInfoForFiles {
    readonly firstFile: SourceFile;
    readonly secondFile: SourceFile;
    readonly conflictingSymbols: qb.QMap<DuplicateInfoForSymbol>;
  }
  let amalgamatedDuplicates: qb.QMap<DuplicateInfoForFiles> | undefined;
  const reverseMappedCache = new qb.QMap<Type | undefined>();
  let inInferTypeForHomomorphicMappedType = false;
  let ambientModulesCache: Symbol[] | undefined;
  let patternAmbientModules: PatternAmbientModule[];
  let patternAmbientModuleAugmentations: qb.QMap<Symbol> | undefined;
  let globalObjectType: ObjectType;
  let globalFunctionType: ObjectType;
  let globalCallableFunctionType: ObjectType;
  let globalNewableFunctionType: ObjectType;
  let globalArrayType: GenericType;
  let globalReadonlyArrayType: GenericType;
  let globalStringType: ObjectType;
  let globalNumberType: ObjectType;
  let globalBooleanType: ObjectType;
  let globalRegExpType: ObjectType;
  let globalThisType: GenericType;
  let anyArrayType: Type;
  let autoArrayType: Type;
  let anyReadonlyArrayType: Type;
  let deferredGlobalNonNullableTypeAlias: Symbol;
  let deferredGlobalESSymbolConstructorSymbol: Symbol | undefined;
  let deferredGlobalESSymbolType: ObjectType;
  let deferredGlobalTypedPropertyDescriptorType: GenericType;
  let deferredGlobalPromiseType: GenericType;
  let deferredGlobalPromiseLikeType: GenericType;
  let deferredGlobalPromiseConstructorSymbol: Symbol | undefined;
  let deferredGlobalPromiseConstructorLikeType: ObjectType;
  let deferredGlobalIterableType: GenericType;
  let deferredGlobalIteratorType: GenericType;
  let deferredGlobalIterableIteratorType: GenericType;
  let deferredGlobalGeneratorType: GenericType;
  let deferredGlobalIteratorYieldResultType: GenericType;
  let deferredGlobalIteratorReturnResultType: GenericType;
  let deferredGlobalAsyncIterableType: GenericType;
  let deferredGlobalAsyncIteratorType: GenericType;
  let deferredGlobalAsyncIterableIteratorType: GenericType;
  let deferredGlobalAsyncGeneratorType: GenericType;
  let deferredGlobalTemplateStringsArrayType: ObjectType;
  let deferredGlobalImportMetaType: ObjectType;
  let deferredGlobalExtractSymbol: Symbol;
  let deferredGlobalOmitSymbol: Symbol;
  let deferredGlobalBigIntType: ObjectType;
  const allPotentiallyUnusedIdentifiers = new qb.QMap<PotentiallyUnusedIdentifier[]>();
  let flowLoopStart = 0;
  let flowLoopCount = 0;
  let sharedFlowCount = 0;
  let flowAnalysisDisabled = false;
  let flowInvocationCount = 0;
  let lastFlowNode: FlowNode | undefined;
  let lastFlowNodeReachable: boolean;
  let flowTypeCache: Type[] | undefined;
  const emptyStringType = getLiteralType('');
  const zeroType = getLiteralType(0);
  const zeroBigIntType = getLiteralType({ negative: false, base10Value: '0' });
  const resolutionTargets: TypeSystemEntity[] = [];
  const resolutionResults: boolean[] = [];
  const resolutionPropertyNames: TypeSystemPropertyName[] = [];
  let suggestionCount = 0;
  const maximumSuggestionCount = 10;
  const mergedSymbols: Symbol[] = [];
  const symbolLinks: SymbolLinks[] = [];
  const nodeLinks: NodeLinks[] = [];
  const flowLoopCaches: qb.QMap<Type>[] = [];
  const flowLoopNodes: FlowNode[] = [];
  const flowLoopKeys: string[] = [];
  const flowLoopTypes: Type[][] = [];
  const sharedFlowNodes: FlowNode[] = [];
  const sharedFlowTypes: FlowType[] = [];
  const flowNodeReachable: (boolean | undefined)[] = [];
  const flowNodePostSuper: (boolean | undefined)[] = [];
  const potentialThisCollisions: Node[] = [];
  const potentialNewTargetCollisions: Node[] = [];
  const potentialWeakMapCollisions: Node[] = [];
  const awaitedTypeStack: number[] = [];
  const diagnostics = createDiagnosticCollection();
  const suggestionDiagnostics = createDiagnosticCollection();
  const typeofTypesByName: qb.QReadonlyMap<Type> = new qb.QMap<Type>({
    string: stringType,
    number: numberType,
    bigint: bigintType,
    boolean: booleanType,
    symbol: esSymbolType,
    undefined: undefinedType,
  });
  const typeofType = createTypeofType();
  let _jsxNamespace: __String;
  let _jsxFactoryEntity: EntityName | undefined;
  let outofbandVarianceMarkerHandler: ((onlyUnreliable: boolean) => void) | undefined;
  const subtypeRelation = new qb.QMap<RelationComparisonResult>();
  const strictSubtypeRelation = new qb.QMap<RelationComparisonResult>();
  const assignableRelation = new qb.QMap<RelationComparisonResult>();
  const comparableRelation = new qb.QMap<RelationComparisonResult>();
  const identityRelation = new qb.QMap<RelationComparisonResult>();
  const enumRelation = new qb.QMap<RelationComparisonResult>();
  const builtinGlobals = new SymbolTable();
  builtinGlobals.set(undefinedSymbol.escName, undefinedSymbol);
  initializeTypeChecker();
  return checker;
  function getJsxNamespace(location: Node | undefined): __String {
    if (location) {
      const file = qc.get.sourceFileOf(location);
      if (file) {
        if (file.localJsxNamespace) return file.localJsxNamespace;
        const jsxPragma = file.pragmas.get('jsx');
        if (jsxPragma) {
          const chosenpragma = isArray(jsxPragma) ? jsxPragma[0] : jsxPragma;
          file.localJsxFactory = qp_parseIsolatedEntityName(chosenpragma.arguments.factory, languageVersion);
          visitNode(file.localJsxFactory, markAsSynthetic);
          if (file.localJsxFactory) return (file.localJsxNamespace = getFirstIdentifier(file.localJsxFactory).escapedText);
        }
      }
    }
    if (!_jsxNamespace) {
      _jsxNamespace = 'React' as __String;
      if (compilerOptions.jsxFactory) {
        _jsxFactoryEntity = qp_parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion);
        visitNode(_jsxFactoryEntity, markAsSynthetic);
        if (_jsxFactoryEntity) _jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText;
      } else if (compilerOptions.reactNamespace) {
        _jsxNamespace = syntax.get.escUnderscores(compilerOptions.reactNamespace);
      }
    }
    if (!_jsxFactoryEntity) _jsxFactoryEntity = QualifiedName.create(new Identifier(syntax.get.unescUnderscores(_jsxNamespace)), 'createElement');
    return _jsxNamespace;
    function markAsSynthetic(node: Node): VisitResult<Node> {
      node.pos = -1;
      node.end = -1;
      return visitEachChild(node, markAsSynthetic, nullTransformationContext);
    }
  }
  function getEmitResolver(sourceFile: SourceFile, cancellationToken: CancellationToken) {
    getDiagnostics(sourceFile, cancellationToken);
    return emitResolver;
  }
  function lookupOrIssueError(location: Node | undefined, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number): Diagnostic {
    const diagnostic = location ? createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3) : createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
    const existing = diagnostics.lookup(diagnostic);
    if (existing) return existing;
    else {
      diagnostics.add(diagnostic);
      return diagnostic;
    }
  }
  function error(location: Node | undefined, message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number): Diagnostic {
    const diagnostic = location ? createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3) : createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
    diagnostics.add(diagnostic);
    return diagnostic;
  }
  function addErrorOrSuggestion(isError: boolean, diagnostic: DiagnosticWithLocation) {
    if (isError) diagnostics.add(diagnostic);
    else {
      suggestionqd.add({ ...diagnostic, category: DiagnosticCategory.Suggestion });
    }
  }
  function errorOrSuggestion(
    isError: boolean,
    location: Node,
    message: DiagnosticMessage | DiagnosticMessageChain,
    arg0?: string | number,
    arg1?: string | number,
    arg2?: string | number,
    arg3?: string | number
  ): void {
    addErrorOrSuggestion(isError, 'message' in message ? createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3) : createDiagnosticForNodeFromMessageChain(location, message));
  }
  function errorAndMaybeSuggestAwait(
    location: Node,
    maybeMissingAwait: boolean,
    message: DiagnosticMessage,
    arg0?: string | number | undefined,
    arg1?: string | number | undefined,
    arg2?: string | number | undefined,
    arg3?: string | number | undefined
  ): Diagnostic {
    const diagnostic = error(location, message, arg0, arg1, arg2, arg3);
    if (maybeMissingAwait) {
      const related = createDiagnosticForNode(location, qd.Did_you_forget_to_use_await);
      addRelatedInfo(diagnostic, related);
    }
    return diagnostic;
  }
  function addDuplicateDeclarationError(node: Declaration, message: DiagnosticMessage, symbolName: string, relatedNodes: readonly Declaration[] | undefined) {
    const errorNode = (getExpandoInitializer(node, false) ? getNameOfExpando(node) : getNameOfDeclaration(node)) || node;
    const err = lookupOrIssueError(errorNode, message, symbolName);
    for (const relatedNode of relatedNodes || empty) {
      const adjustedNode = (getExpandoInitializer(relatedNode, false) ? getNameOfExpando(relatedNode) : getNameOfDeclaration(relatedNode)) || relatedNode;
      if (adjustedNode === errorNode) continue;
      err.relatedInformation = err.relatedInformation || [];
      const leadingMessage = createDiagnosticForNode(adjustedNode, qd._0_was_also_declared_here, symbolName);
      const followOnMessage = createDiagnosticForNode(adjustedNode, qd.and_here);
      if (
        length(err.relatedInformation) >= 5 ||
        some(err.relatedInformation, (r) => compareDiagnostics(r, followOnMessage) === Comparison.EqualTo || compareDiagnostics(r, leadingMessage) === Comparison.EqualTo)
      )
        continue;
      addRelatedInfo(err, !length(err.relatedInformation) ? leadingMessage : followOnMessage);
    }
  }
  function mergeModuleAugmentation(moduleName: StringLiteral | Identifier): void {
    const moduleAugmentation = <ModuleDeclaration>moduleName.parent;
    if (moduleAugmentation.symbol.declarations[0] !== moduleAugmentation) {
      assert(moduleAugmentation.symbol.declarations.length > 1);
      return;
    }
    if (isGlobalScopeAugmentation(moduleAugmentation)) globals.merge(moduleAugmentation.symbol.exports!);
    else {
      const moduleNotFoundError = !(moduleName.parent.parent.flags & NodeFlags.Ambient) ? qd.Invalid_module_name_in_augmentation_module_0_cannot_be_found : undefined;
      let mainModule = resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError, true);
      if (!mainModule) return;
      mainModule = resolveExternalModuleSymbol(mainModule);
      if (mainModule.flags & SymbolFlags.Namespace) {
        if (some(patternAmbientModules, (module) => mainModule === module.symbol)) {
          const merged = mainModule.merge(moduleAugmentation.symbol, true);
          if (!patternAmbientModuleAugmentations) patternAmbientModuleAugmentations = new qb.QMap();
          patternAmbientModuleAugmentations.set((moduleName as StringLiteral).text, merged);
        } else {
          if (mainModule.exports?.get(InternalSymbolName.ExportStar) && moduleAugmentation.symbol.exports?.size) {
            const resolvedExports = getResolvedMembersOrExportsOfSymbol(mainModule, MembersOrExportsResolutionKind.resolvedExports);
            for (const [key, value] of arrayFrom(moduleAugmentation.symbol.exports.entries())) {
              if (resolvedExports.has(key) && !mainModule.exports.has(key)) value.merge(resolvedExports.get(key)!);
            }
          }
          moduleAugmentation.symbol.merge(mainModule);
        }
      } else error(moduleName, qd.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, (moduleName as StringLiteral).text);
    }
  }
  function getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: __String): [Symbol, Symbol] {
    const constructorDeclaration = parameter.parent;
    const classDeclaration = parameter.parent.parent;
    const parameterSymbol = getSymbol(constructorDeclaration.locals!, parameterName, SymbolFlags.Value);
    const propertySymbol = getSymbol(getMembersOfSymbol(classDeclaration.symbol), parameterName, SymbolFlags.Value);
    if (parameterSymbol && propertySymbol) return [parameterSymbol, propertySymbol];
    return fail('There should exist two symbols, one as property declaration and one as parameter declaration');
  }
  function isBlockScopedNameDeclaredBeforeUse(declaration: Declaration, usage: Node): boolean {
    const declarationFile = qc.get.sourceFileOf(declaration);
    const useFile = qc.get.sourceFileOf(usage);
    const declContainer = qc.get.enclosingBlockScopeContainer(declaration);
    if (declarationFile !== useFile) {
      if (
        (moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) ||
        (!compilerOptions.outFile && !compilerOptions.out) ||
        isInTypeQuery(usage) ||
        declaration.flags & NodeFlags.Ambient
      ) {
        return true;
      }
      if (isUsedInFunctionOrInstanceProperty(usage, declaration)) return true;
      const sourceFiles = host.getSourceFiles();
      return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile);
    }
    if (declaration.pos <= usage.pos && !(qc.is.kind(PropertyDeclaration, declaration) && qc.is.thisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken)) {
      if (declaration.kind === Syntax.BindingElement) {
        const errorBindingElement = getAncestor(usage, Syntax.BindingElement) as BindingElement;
        if (errorBindingElement)
          return Node.findAncestor(errorBindingElement, BindingElement.kind) !== Node.findAncestor(declaration, BindingElement.kind) || declaration.pos < errorBindingElement.pos;
        return isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration, Syntax.VariableDeclaration) as Declaration, usage);
      } else if (declaration.kind === Syntax.VariableDeclaration) {
        return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration as VariableDeclaration, usage);
      } else if (qc.is.kind(ClassDeclaration, declaration)) {
        return !Node.findAncestor(usage, (n) => qc.is.kind(ComputedPropertyName, n) && n.parent.parent === declaration);
      } else if (qc.is.kind(PropertyDeclaration, declaration)) {
        return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, false);
      } else if (qc.is.parameterPropertyDeclaration(declaration, declaration.parent)) {
        return !(
          compilerOptions.target === ScriptTarget.ESNext &&
          !!compilerOptions.useDefineForClassFields &&
          qc.get.containingClass(declaration) === qc.get.containingClass(usage) &&
          isUsedInFunctionOrInstanceProperty(usage, declaration)
        );
      }
      return true;
    }
    if (usage.parent.kind === Syntax.ExportSpecifier || (usage.parent.kind === Syntax.ExportAssignment && (usage.parent as ExportAssignment).isExportEquals)) return true;
    if (usage.kind === Syntax.ExportAssignment && (usage as ExportAssignment).isExportEquals) return true;
    if (!!(usage.flags & NodeFlags.JSDoc) || isInTypeQuery(usage) || usageInTypeDeclaration()) return true;
    if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
      if (
        compilerOptions.target === ScriptTarget.ESNext &&
        !!compilerOptions.useDefineForClassFields &&
        qc.get.containingClass(declaration) &&
        (qc.is.kind(PropertyDeclaration, declaration) || qc.is.parameterPropertyDeclaration(declaration, declaration.parent))
      ) {
        return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, true);
      }
      return true;
    }
    return false;
    function usageInTypeDeclaration() {
      return !!Node.findAncestor(usage, (node) => qc.is.kind(InterfaceDeclaration, node) || qc.is.kind(TypeAliasDeclaration, node));
    }
    function isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration: VariableDeclaration, usage: Node): boolean {
      switch (declaration.parent.parent.kind) {
        case Syntax.VariableStatement:
        case Syntax.ForStatement:
        case Syntax.ForOfStatement:
          if (isSameScopeDescendentOf(usage, declaration, declContainer)) return true;
          break;
      }
      const grandparent = declaration.parent.parent;
      return qc.is.forInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage, grandparent.expression, declContainer);
    }
    function isUsedInFunctionOrInstanceProperty(usage: Node, declaration: Node): boolean {
      return !!Node.findAncestor(usage, (current) => {
        if (current === declContainer) return 'quit';
        if (qc.is.functionLike(current)) return true;
        const initializerOfProperty = current.parent && current.parent.kind === Syntax.PropertyDeclaration && (<PropertyDeclaration>current.parent).initializer === current;
        if (initializerOfProperty) {
          if (hasSyntacticModifier(current.parent, ModifierFlags.Static)) {
            if (declaration.kind === Syntax.MethodDeclaration) return true;
          } else {
            const isDeclarationInstanceProperty = declaration.kind === Syntax.PropertyDeclaration && !hasSyntacticModifier(declaration, ModifierFlags.Static);
            if (!isDeclarationInstanceProperty || qc.get.containingClass(usage) !== qc.get.containingClass(declaration)) return true;
          }
        }
        return false;
      });
    }
    function isPropertyImmediatelyReferencedWithinDeclaration(declaration: PropertyDeclaration | ParameterPropertyDeclaration, usage: Node, stopAtAnyPropertyDeclaration: boolean) {
      if (usage.end > declaration.end) return false;
      const ancestorChangingReferenceScope = Node.findAncestor(usage, (node: Node) => {
        if (node === declaration) return 'quit';
        switch (node.kind) {
          case Syntax.ArrowFunction:
            return true;
          case Syntax.PropertyDeclaration:
            return stopAtAnyPropertyDeclaration &&
              ((qc.is.kind(PropertyDeclaration, declaration) && node.parent === declaration.parent) ||
                (qc.is.parameterPropertyDeclaration(declaration, declaration.parent) && node.parent === declaration.parent.parent))
              ? 'quit'
              : true;
          case Syntax.Block:
            switch (node.parent.kind) {
              case Syntax.GetAccessor:
              case Syntax.MethodDeclaration:
              case Syntax.SetAccessor:
                return true;
              default:
                return false;
            }
          default:
            return false;
        }
      });
      return ancestorChangingReferenceScope === undefined;
    }
  }
  function useOuterVariableScopeInParameter(result: Symbol, location: Node, lastLocation: Node) {
    const target = getEmitScriptTarget(compilerOptions);
    const functionLocation = <FunctionLikeDeclaration>location;
    if (
      qc.is.kind(ParameterDeclaration, lastLocation) &&
      functionLocation.body &&
      result.valueDeclaration.pos >= functionLocation.body.pos &&
      result.valueDeclaration.end <= functionLocation.body.end
    ) {
      const ls = getNodeLinks(functionLocation);
      if (ls.declarationRequiresScopeChange === undefined) ls.declarationRequiresScopeChange = forEach(functionLocation.parameters, requiresScopeChange) || false;
      return !ls.declarationRequiresScopeChange;
    }
    return false;
    function requiresScopeChange(node: ParameterDeclaration): boolean {
      return requiresScopeChangeWorker(node.name) || (!!node.initializer && requiresScopeChangeWorker(node.initializer));
    }
    function requiresScopeChangeWorker(node: Node): boolean {
      switch (node.kind) {
        case Syntax.ArrowFunction:
        case Syntax.FunctionExpression:
        case Syntax.FunctionDeclaration:
        case Syntax.Constructor:
          return false;
        case Syntax.MethodDeclaration:
        case Syntax.GetAccessor:
        case Syntax.SetAccessor:
        case Syntax.PropertyAssignment:
          return requiresScopeChangeWorker((node as MethodDeclaration | AccessorDeclaration | PropertyAssignment).name);
        case Syntax.PropertyDeclaration:
          if (hasStaticModifier(node)) return target < ScriptTarget.ESNext || !compilerOptions.useDefineForClassFields;
          return requiresScopeChangeWorker((node as PropertyDeclaration).name);
        default:
          if (qc.is.nullishCoalesce(node) || qc.is.optionalChain(node)) return false;
          if (qc.is.kind(BindingElement, node) && node.dot3Token && qc.is.kind(ObjectBindingPattern, node.parent)) return false;
          if (qc.is.typeNode(node)) return false;
          return qc.forEach.child(node, requiresScopeChangeWorker) || false;
      }
    }
  }
  function resolveName(
    location: Node | undefined,
    name: __String,
    meaning: SymbolFlags,
    nameNotFoundMessage: DiagnosticMessage | undefined,
    nameArg: __String | Identifier | undefined,
    isUse: boolean,
    excludeGlobals = false,
    suggestedNameNotFoundMessage?: DiagnosticMessage
  ): Symbol | undefined {
    return resolveNameHelper(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals, getSymbol, suggestedNameNotFoundMessage);
  }
  function resolveNameHelper(
    location: Node | undefined,
    name: __String,
    meaning: SymbolFlags,
    nameNotFoundMessage: DiagnosticMessage | undefined,
    nameArg: __String | Identifier | undefined,
    isUse: boolean,
    excludeGlobals: boolean,
    lookup: typeof getSymbol,
    suggestedNameNotFoundMessage?: DiagnosticMessage
  ): Symbol | undefined {
    const originalLocation = location;
    let result: Symbol | undefined;
    let lastLocation: Node | undefined;
    let lastSelfReferenceLocation: Node | undefined;
    let propertyWithInvalidInitializer: Node | undefined;
    let associatedDeclarationForContainingInitializerOrBindingName: ParameterDeclaration | BindingElement | undefined;
    let withinDeferredContext = false;
    const errorLocation = location;
    let grandparent: Node;
    let isInExternalModule = false;
    loop: while (location) {
      if (location.locals && !isGlobalSourceFile(location)) {
        if ((result = lookup(location.locals, name, meaning))) {
          let useResult = true;
          if (qc.is.functionLike(location) && lastLocation && lastLocation !== (<FunctionLikeDeclaration>location).body) {
            if (meaning & result.flags & SymbolFlags.Type && lastLocation.kind !== Syntax.JSDocComment) {
              useResult =
                result.flags & SymbolFlags.TypeParameter
                  ? lastLocation === (<FunctionLikeDeclaration>location).type || lastLocation.kind === Syntax.Parameter || lastLocation.kind === Syntax.TypeParameter
                  : false;
            }
            if (meaning & result.flags & SymbolFlags.Variable) {
              if (useOuterVariableScopeInParameter(result, location, lastLocation)) useResult = false;
              else if (result.flags & SymbolFlags.FunctionScopedVariable) {
                useResult = lastLocation.kind === Syntax.Parameter || (lastLocation === (<FunctionLikeDeclaration>location).type && !!Node.findAncestor(result.valueDeclaration, isParameter));
              }
            }
          } else if (location.kind === Syntax.ConditionalType) {
            useResult = lastLocation === (<ConditionalTypeNode>location).trueType;
          }
          if (useResult) break loop;
          else {
            result = undefined;
          }
        }
      }
      withinDeferredContext = withinDeferredContext || getIsDeferredContext(location, lastLocation);
      switch (location.kind) {
        case Syntax.SourceFile:
          if (!isExternalOrCommonJsModule(<SourceFile>location)) break;
          isInExternalModule = true;
        case Syntax.ModuleDeclaration:
          const moduleExports = getSymbolOfNode(location as SourceFile | ModuleDeclaration).exports || emptySymbols;
          if (location.kind === Syntax.SourceFile || (qc.is.kind(ModuleDeclaration, location) && location.flags & NodeFlags.Ambient && !isGlobalScopeAugmentation(location))) {
            if ((result = moduleExports.get(InternalSymbolName.Default))) {
              const localSymbol = getLocalSymbolForExportDefault(result);
              if (localSymbol && result.flags & meaning && localSymbol.escName === name) break loop;
              result = undefined;
            }
            const moduleExport = moduleExports.get(name);
            if (
              moduleExport &&
              moduleExport.flags === SymbolFlags.Alias &&
              (getDeclarationOfKind(moduleExport, Syntax.ExportSpecifier) || getDeclarationOfKind(moduleExport, Syntax.NamespaceExport))
            ) {
              break;
            }
          }
          if (name !== InternalSymbolName.Default && (result = lookup(moduleExports, name, meaning & SymbolFlags.ModuleMember))) {
            if (qc.is.kind(SourceFile, location) && location.commonJsModuleIndicator && !result.declarations.some(isJSDocTypeAlias)) result = undefined;
            else {
              break loop;
            }
          }
          break;
        case Syntax.EnumDeclaration:
          if ((result = lookup(getSymbolOfNode(location)!.exports!, name, meaning & SymbolFlags.EnumMember))) break loop;
          break;
        case Syntax.PropertyDeclaration:
          if (!hasSyntacticModifier(location, ModifierFlags.Static)) {
            const ctor = findConstructorDeclaration(location.parent as ClassLikeDeclaration);
            if (ctor && ctor.locals) {
              if (lookup(ctor.locals, name, meaning & SymbolFlags.Value)) propertyWithInvalidInitializer = location;
            }
          }
          break;
        case Syntax.ClassDeclaration:
        case Syntax.ClassExpression:
        case Syntax.InterfaceDeclaration:
          if ((result = lookup(getSymbolOfNode(location as ClassLikeDeclaration | InterfaceDeclaration).members || emptySymbols, name, meaning & SymbolFlags.Type))) {
            if (!isTypeParameterSymbolDeclaredInContainer(result, location)) {
              result = undefined;
              break;
            }
            if (lastLocation && hasSyntacticModifier(lastLocation, ModifierFlags.Static)) {
              error(errorLocation, qd.Static_members_cannot_reference_class_type_parameters);
              return;
            }
            break loop;
          }
          if (location.kind === Syntax.ClassExpression && meaning & SymbolFlags.Class) {
            const className = (<ClassExpression>location).name;
            if (className && name === className.escapedText) {
              result = location.symbol;
              break loop;
            }
          }
          break;
        case Syntax.ExpressionWithTypeArguments:
          if (lastLocation === (<ExpressionWithTypeArguments>location).expression && (<HeritageClause>location.parent).token === Syntax.ExtendsKeyword) {
            const container = location.parent.parent;
            if (qc.is.classLike(container) && (result = lookup(getSymbolOfNode(container).members!, name, meaning & SymbolFlags.Type))) {
              if (nameNotFoundMessage) error(errorLocation, qd.Base_class_expressions_cannot_reference_class_type_parameters);
              return;
            }
          }
          break;
        case Syntax.ComputedPropertyName:
          grandparent = location.parent.parent;
          if (qc.is.classLike(grandparent) || grandparent.kind === Syntax.InterfaceDeclaration) {
            if ((result = lookup(getSymbolOfNode(grandparent as ClassLikeDeclaration | InterfaceDeclaration).members!, name, meaning & SymbolFlags.Type))) {
              error(errorLocation, qd.A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type);
              return;
            }
          }
          break;
        case Syntax.ArrowFunction:
          if (true) break;
        case Syntax.MethodDeclaration:
        case Syntax.Constructor:
        case Syntax.GetAccessor:
        case Syntax.SetAccessor:
        case Syntax.FunctionDeclaration:
          if (meaning & SymbolFlags.Variable && name === 'arguments') {
            result = argumentsSymbol;
            break loop;
          }
          break;
        case Syntax.FunctionExpression:
          if (meaning & SymbolFlags.Variable && name === 'arguments') {
            result = argumentsSymbol;
            break loop;
          }
          if (meaning & SymbolFlags.Function) {
            const functionName = (<FunctionExpression>location).name;
            if (functionName && name === functionName.escapedText) {
              result = location.symbol;
              break loop;
            }
          }
          break;
        case Syntax.Decorator:
          if (location.parent && location.parent.kind === Syntax.Parameter) location = location.parent;
          if (location.parent && (qc.is.classElement(location.parent) || location.parent.kind === Syntax.ClassDeclaration)) location = location.parent;
          break;
        case Syntax.JSDocTypedefTag:
        case Syntax.JSDocCallbackTag:
        case Syntax.JSDocEnumTag:
          location = qc.getDoc.host(location);
          break;
        case Syntax.Parameter:
          if (
            lastLocation &&
            (lastLocation === (location as ParameterDeclaration).initializer || (lastLocation === (location as ParameterDeclaration).name && qc.is.kind(BindingPattern, lastLocation)))
          ) {
            if (!associatedDeclarationForContainingInitializerOrBindingName) associatedDeclarationForContainingInitializerOrBindingName = location as ParameterDeclaration;
          }
          break;
        case Syntax.BindingElement:
          if (lastLocation && (lastLocation === (location as BindingElement).initializer || (lastLocation === (location as BindingElement).name && qc.is.kind(BindingPattern, lastLocation)))) {
            const root = getRootDeclaration(location);
            if (root.kind === Syntax.Parameter) {
              if (!associatedDeclarationForContainingInitializerOrBindingName) associatedDeclarationForContainingInitializerOrBindingName = location as BindingElement;
            }
          }
          break;
      }
      if (isSelfReferenceLocation(location)) lastSelfReferenceLocation = location;
      lastLocation = location;
      location = location.parent;
    }
    if (isUse && result && (!lastSelfReferenceLocation || result !== lastSelfReferenceLocation.symbol)) result.isReferenced! |= meaning;
    if (!result) {
      if (lastLocation) {
        assert(lastLocation.kind === Syntax.SourceFile);
        if ((lastLocation as SourceFile).commonJsModuleIndicator && name === 'exports' && meaning & lastLocation.symbol.flags) return lastLocation.symbol;
      }
      if (!excludeGlobals) result = lookup(globals, name, meaning);
    }
    if (!result) {
      if (originalLocation && isInJSFile(originalLocation) && originalLocation.parent) {
        if (isRequireCall(originalLocation.parent, false)) return requireSymbol;
      }
    }
    if (!result) {
      if (nameNotFoundMessage) {
        if (
          !errorLocation ||
          (!checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg!) &&
            !checkAndReportErrorForExtendingInterface(errorLocation) &&
            !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) &&
            !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) &&
            !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) &&
            !checkAndReportErrorForUsingNamespaceModuleAsValue(errorLocation, name, meaning) &&
            !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning))
        ) {
          let suggestion: Symbol | undefined;
          if (suggestedNameNotFoundMessage && suggestionCount < maximumSuggestionCount) {
            suggestion = getSuggestedSymbolForNonexistentSymbol(originalLocation, name, meaning);
            if (suggestion) {
              const suggestionName = suggestion.symbolToString();
              const diagnostic = error(errorLocation, suggestedNameNotFoundMessage, diagnosticName(nameArg!), suggestionName);
              if (suggestion.valueDeclaration) addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, qd._0_is_declared_here, suggestionName));
            }
          }
          if (!suggestion) error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg!));
          suggestionCount++;
        }
      }
      return;
    }
    if (nameNotFoundMessage) {
      if (propertyWithInvalidInitializer && !(compilerOptions.target === ScriptTarget.ESNext && compilerOptions.useDefineForClassFields)) {
        const propertyName = (<PropertyDeclaration>propertyWithInvalidInitializer).name;
        error(errorLocation, qd.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, declarationNameToString(propertyName), diagnosticName(nameArg!));
        return;
      }
      if (errorLocation && (meaning & SymbolFlags.BlockScopedVariable || ((meaning & SymbolFlags.Class || meaning & SymbolFlags.Enum) && (meaning & SymbolFlags.Value) === SymbolFlags.Value))) {
        const exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(result);
        if (exportOrLocalSymbol.flags & SymbolFlags.BlockScopedVariable || exportOrLocalSymbol.flags & SymbolFlags.Class || exportOrLocalSymbol.flags & SymbolFlags.Enum)
          checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);
      }
      if (result && isInExternalModule && (meaning & SymbolFlags.Value) === SymbolFlags.Value && !(originalLocation!.flags & NodeFlags.JSDoc)) {
        const merged = getMergedSymbol(result);
        if (length(merged.declarations) && every(merged.declarations, (d) => qc.is.kind(NamespaceExportDeclaration, d) || (qc.is.kind(SourceFile, d) && !!d.symbol.globalExports))) {
          errorOrSuggestion(
            !compilerOptions.allowUmdGlobalAccess,
            errorLocation!,
            qd._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead,
            syntax.get.unescUnderscores(name)
          );
        }
      }
      if (result && associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning & SymbolFlags.Value) === SymbolFlags.Value) {
        const candidate = getMergedSymbol(getLateBoundSymbol(result));
        const root = getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName) as ParameterDeclaration;
        if (candidate === getSymbolOfNode(associatedDeclarationForContainingInitializerOrBindingName))
          error(errorLocation, qd.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name));
        else if (
          candidate.valueDeclaration &&
          candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos &&
          root.parent.locals &&
          lookup(root.parent.locals, candidate.escName, meaning) === candidate
        ) {
          error(
            errorLocation,
            qd.Parameter_0_cannot_reference_identifier_1_declared_after_it,
            declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name),
            declarationNameToString(<Identifier>errorLocation)
          );
        }
      }
      if (result && errorLocation && meaning & SymbolFlags.Value && result.flags & SymbolFlags.Alias) checkSymbolUsageInExpressionContext(result, name, errorLocation);
    }
    return result;
  }
  function getIsDeferredContext(location: Node, lastLocation: Node | undefined): boolean {
    if (location.kind !== Syntax.ArrowFunction && location.kind !== Syntax.FunctionExpression) {
      return (
        qc.is.kind(TypeQueryNode, location) ||
        ((qc.is.functionLikeDeclaration(location) || (location.kind === Syntax.PropertyDeclaration && !hasSyntacticModifier(location, ModifierFlags.Static))) &&
          (!lastLocation || lastLocation !== (location as FunctionLike | PropertyDeclaration).name))
      );
    }
    if (lastLocation && lastLocation === (location as FunctionExpression | ArrowFunction).name) return false;
    if ((location as FunctionExpression | ArrowFunction).asteriskToken || hasSyntacticModifier(location, ModifierFlags.Async)) return true;
    return !qc.get.immediatelyInvokedFunctionExpression(location);
  }
  function diagnosticName(nameArg: __String | Identifier | PrivateIdentifier) {
    return isString(nameArg) ? syntax.get.unescUnderscores(nameArg as __String) : declarationNameToString(nameArg as Identifier);
  }
  function checkAndReportErrorForMissingPrefix(errorLocation: Node, name: __String, nameArg: __String | Identifier): boolean {
    if (!qc.is.kind(Identifier, errorLocation) || errorLocation.escapedText !== name || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation)) return false;
    const container = qc.get.thisContainer(errorLocation, false);
    let location = container;
    while (location) {
      if (qc.is.classLike(location.parent)) {
        const classSymbol = getSymbolOfNode(location.parent);
        if (!classSymbol) break;
        const constructorType = getTypeOfSymbol(classSymbol);
        if (getPropertyOfType(constructorType, name)) {
          error(errorLocation, qd.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), classSymbol.symbolToString());
          return true;
        }
        if (location === container && !hasSyntacticModifier(location, ModifierFlags.Static)) {
          const instanceType = (<InterfaceType>getDeclaredTypeOfSymbol(classSymbol)).thisType!;
          if (getPropertyOfType(instanceType, name)) {
            error(errorLocation, qd.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg));
            return true;
          }
        }
      }
      location = location.parent;
    }
    return false;
  }
  function checkAndReportErrorForExtendingInterface(errorLocation: Node): boolean {
    const expression = getEntityNameForExtendingInterface(errorLocation);
    if (expression && resolveEntityName(expression, SymbolFlags.Interface, true)) {
      error(errorLocation, qd.Cannot_extend_an_interface_0_Did_you_mean_implements, qc.get.textOf(expression));
      return true;
    }
    return false;
  }
  function getEntityNameForExtendingInterface(node: Node): EntityNameExpression | undefined {
    switch (node.kind) {
      case Syntax.Identifier:
      case Syntax.PropertyAccessExpression:
        return node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined;
      case Syntax.ExpressionWithTypeArguments:
        if (isEntityNameExpression((<ExpressionWithTypeArguments>node).expression)) return <EntityNameExpression>(<ExpressionWithTypeArguments>node).expression;
      default:
        return;
    }
  }
  function checkAndReportErrorForUsingTypeAsNamespace(errorLocation: Node, name: __String, meaning: SymbolFlags): boolean {
    const namespaceMeaning = SymbolFlags.Namespace | (isInJSFile(errorLocation) ? SymbolFlags.Value : 0);
    if (meaning === namespaceMeaning) {
      const symbol = resolveSymbol(resolveName(errorLocation, name, SymbolFlags.Type & ~namespaceMeaning, undefined, undefined, false));
      const parent = errorLocation.parent;
      if (symbol) {
        if (qc.is.kind(QualifiedName, parent)) {
          assert(parent.left === errorLocation, 'Should only be resolving left side of qualified name as a namespace');
          const propName = parent.right.escapedText;
          const propType = getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName);
          if (propType) {
            error(
              parent,
              qd.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1,
              syntax.get.unescUnderscores(name),
              syntax.get.unescUnderscores(propName)
            );
            return true;
          }
        }
        error(errorLocation, qd._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, syntax.get.unescUnderscores(name));
        return true;
      }
    }
    return false;
  }
  function checkAndReportErrorForUsingValueAsType(errorLocation: Node, name: __String, meaning: SymbolFlags): boolean {
    if (meaning & (SymbolFlags.Type & ~SymbolFlags.Namespace)) {
      const n = resolveName(errorLocation, name, ~SymbolFlags.Type & SymbolFlags.Value, undefined, undefined, false);
      const symbol = resolveSymbol(n);
      if (symbol && !(symbol.flags & SymbolFlags.Namespace)) {
        error(errorLocation, qd._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, syntax.get.unescUnderscores(name));
        return true;
      }
    }
    return false;
  }
  function isPrimitiveTypeName(name: __String) {
    return name === 'any' || name === 'string' || name === 'number' || name === 'boolean' || name === 'never' || name === 'unknown';
  }
  function checkAndReportErrorForExportingPrimitiveType(errorLocation: Node, name: __String): boolean {
    if (isPrimitiveTypeName(name) && errorLocation.parent.kind === Syntax.ExportSpecifier) {
      error(errorLocation, qd.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name as string);
      return true;
    }
    return false;
  }
  function checkAndReportErrorForUsingTypeAsValue(errorLocation: Node, name: __String, meaning: SymbolFlags): boolean {
    if (meaning & (SymbolFlags.Value & ~SymbolFlags.NamespaceModule)) {
      if (isPrimitiveTypeName(name)) {
        error(errorLocation, qd._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, syntax.get.unescUnderscores(name));
        return true;
      }
      const n = resolveName(errorLocation, name, SymbolFlags.Type & ~SymbolFlags.Value, undefined, undefined, false);
      const symbol = resolveSymbol(n);
      if (symbol && !(symbol.flags & SymbolFlags.NamespaceModule)) {
        const message = isES2015OrLaterConstructorName(name)
          ? qd._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later
          : qd._0_only_refers_to_a_type_but_is_being_used_as_a_value_here;
        error(errorLocation, message, syntax.get.unescUnderscores(name));
        return true;
      }
    }
    return false;
  }
  function isES2015OrLaterConstructorName(n: __String) {
    switch (n) {
      case 'Promise':
      case 'Symbol':
      case 'Map':
      case 'WeakMap':
      case 'Set':
      case 'WeakSet':
        return true;
    }
    return false;
  }
  function checkAndReportErrorForUsingNamespaceModuleAsValue(errorLocation: Node, name: __String, meaning: SymbolFlags): boolean {
    if (meaning & (SymbolFlags.Value & ~SymbolFlags.NamespaceModule & ~SymbolFlags.Type)) {
      const n = resolveName(errorLocation, name, SymbolFlags.NamespaceModule & ~SymbolFlags.Value, undefined, undefined, false);
      const symbol = resolveSymbol(n);
      if (symbol) {
        error(errorLocation, qd.Cannot_use_namespace_0_as_a_value, syntax.get.unescUnderscores(name));
        return true;
      }
    } else if (meaning & (SymbolFlags.Type & ~SymbolFlags.NamespaceModule & ~SymbolFlags.Value)) {
      const n = resolveName(errorLocation, name, (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) & ~SymbolFlags.Type, undefined, undefined, false);
      const symbol = resolveSymbol(n);
      if (symbol) {
        error(errorLocation, qd.Cannot_use_namespace_0_as_a_type, syntax.get.unescUnderscores(name));
        return true;
      }
    }
    return false;
  }
  function checkResolvedBlockScopedVariable(result: Symbol, errorLocation: Node): void {
    assert(!!(result.flags & SymbolFlags.BlockScopedVariable || result.flags & SymbolFlags.Class || result.flags & SymbolFlags.Enum));
    if (result.flags & (SymbolFlags.Function | SymbolFlags.FunctionScopedVariable | SymbolFlags.Assignment) && result.flags & SymbolFlags.Class) return;
    const declaration = find(result.declarations, (d) => isBlockOrCatchScoped(d) || qc.is.classLike(d) || d.kind === Syntax.EnumDeclaration);
    if (declaration === undefined) return fail('checkResolvedBlockScopedVariable could not find block-scoped declaration');
    if (!(declaration.flags & NodeFlags.Ambient) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation)) {
      let diagnosticMessage;
      const declarationName = declarationNameToString(getNameOfDeclaration(declaration));
      if (result.flags & SymbolFlags.BlockScopedVariable) diagnosticMessage = error(errorLocation, qd.Block_scoped_variable_0_used_before_its_declaration, declarationName);
      else if (result.flags & SymbolFlags.Class) {
        diagnosticMessage = error(errorLocation, qd.Class_0_used_before_its_declaration, declarationName);
      } else if (result.flags & SymbolFlags.RegularEnum) {
        diagnosticMessage = error(errorLocation, qd.Enum_0_used_before_its_declaration, declarationName);
      } else {
        assert(!!(result.flags & SymbolFlags.ConstEnum));
        if (compilerOptions.preserveConstEnums) diagnosticMessage = error(errorLocation, qd.Enum_0_used_before_its_declaration, declarationName);
      }
      if (diagnosticMessage) addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration, qd._0_is_declared_here, declarationName));
    }
  }
  function isSameScopeDescendentOf(initial: Node, parent: Node | undefined, stopAt: Node): boolean {
    return !!parent && !!Node.findAncestor(initial, (n) => (n === stopAt || qc.is.functionLike(n) ? 'quit' : n === parent));
  }
  function getAnyImportSyntax(node: Node): AnyImportSyntax | undefined {
    switch (node.kind) {
      case Syntax.ImportEqualsDeclaration:
        return node as ImportEqualsDeclaration;
      case Syntax.ImportClause:
        return (node as ImportClause).parent;
      case Syntax.NamespaceImport:
        return (node as NamespaceImport).parent.parent;
      case Syntax.ImportSpecifier:
        return (node as ImportSpecifier).parent.parent.parent;
      default:
        return;
    }
  }
  function isAliasSymbolDeclaration(node: Node): boolean {
    return (
      node.kind === Syntax.ImportEqualsDeclaration ||
      node.kind === Syntax.NamespaceExportDeclaration ||
      (node.kind === Syntax.ImportClause && !!(<ImportClause>node).name) ||
      node.kind === Syntax.NamespaceImport ||
      node.kind === Syntax.NamespaceExport ||
      node.kind === Syntax.ImportSpecifier ||
      node.kind === Syntax.ExportSpecifier ||
      (node.kind === Syntax.ExportAssignment && exportAssignmentIsAlias(<ExportAssignment>node)) ||
      (qc.is.kind(BinaryExpression, node) && getAssignmentDeclarationKind(node) === AssignmentDeclarationKind.ModuleExports && exportAssignmentIsAlias(node)) ||
      (qc.is.kind(PropertyAccessExpression, node) &&
        qc.is.kind(BinaryExpression, node.parent) &&
        node.parent.left === node &&
        node.parent.operatorToken.kind === Syntax.EqualsToken &&
        isAliasableOrJsExpression(node.parent.right)) ||
      node.kind === Syntax.ShorthandPropertyAssignment ||
      (node.kind === Syntax.PropertyAssignment && isAliasableOrJsExpression((node as PropertyAssignment).initializer))
    );
  }
  function isAliasableOrJsExpression(e: Expression) {
    return isAliasableExpression(e) || (qc.is.kind(FunctionExpression, e) && isJSConstructor(e));
  }
  function getTargetOfImportEqualsDeclaration(node: ImportEqualsDeclaration, dontResolveAlias: boolean): Symbol | undefined {
    if (node.moduleReference.kind === Syntax.ExternalModuleReference) {
      const immediate = resolveExternalModuleName(node, getExternalModuleImportEqualsDeclarationExpression(node));
      const resolved = resolveExternalModuleSymbol(immediate);
      markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false);
      return resolved;
    }
    const resolved = getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias);
    checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved);
    return resolved;
  }
  function checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node: ImportEqualsDeclaration, resolved: Symbol | undefined) {
    if (markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false)) {
      const typeOnlyDeclaration = getSymbolOfNode(node).getTypeOnlyAliasDeclaration()!;
      const isExport = typeOnlyDeclarationIsExport(typeOnlyDeclaration);
      const message = isExport
        ? qd.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type
        : qd.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type;
      const relatedMessage = isExport ? qd._0_was_exported_here : qd._0_was_imported_here;
      const name = syntax.get.unescUnderscores(typeOnlyDeclaration.name!.escapedText);
      addRelatedInfo(error(node.moduleReference, message), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name));
    }
  }
  function resolveExportByName(moduleSymbol: Symbol, name: __String, sourceNode: TypeOnlyCompatibleAliasDeclaration | undefined, dontResolveAlias: boolean) {
    const exportValue = moduleSymbol.exports!.get(InternalSymbolName.ExportEquals);
    if (exportValue) return getPropertyOfType(getTypeOfSymbol(exportValue), name);
    const exportSymbol = moduleSymbol.exports!.get(name);
    const resolved = exportSymbol.resolveSymbol(dontResolveAlias);
    markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved, false);
    return resolved;
  }
  function isSyntacticDefault(node: Node) {
    return (qc.is.kind(ExportAssignment, node) && !node.isExportEquals) || hasSyntacticModifier(node, ModifierFlags.Default) || qc.is.kind(ExportSpecifier, node);
  }
  function canHaveSyntheticDefault(file: SourceFile | undefined, moduleSymbol: Symbol, dontResolveAlias: boolean) {
    if (!allowSyntheticDefaultImports) return false;
    if (!file || file.isDeclarationFile) {
      const defaultExportSymbol = resolveExportByName(moduleSymbol, InternalSymbolName.Default, undefined, true);
      if (defaultExportSymbol && some(defaultExportSymbol.declarations, isSyntacticDefault)) return false;
      if (resolveExportByName(moduleSymbol, syntax.get.escUnderscores('__esModule'), undefined, dontResolveAlias)) return false;
      return true;
    }
    if (!isSourceFileJS(file)) return hasExportAssignmentSymbol(moduleSymbol);
    return !file.externalModuleIndicator && !resolveExportByName(moduleSymbol, syntax.get.escUnderscores('__esModule'), undefined, dontResolveAlias);
  }
  function getTargetOfImportClause(node: ImportClause, dontResolveAlias: boolean): Symbol | undefined {
    const moduleSymbol = resolveExternalModuleName(node, node.parent.moduleSpecifier);
    if (moduleSymbol) {
      let exportDefaultSymbol: Symbol | undefined;
      if (isShorthandAmbientModuleSymbol(moduleSymbol)) exportDefaultSymbol = moduleSymbol;
      else {
        exportDefaultSymbol = resolveExportByName(moduleSymbol, InternalSymbolName.Default, node, dontResolveAlias);
      }
      const file = find(moduleSymbol.declarations, isSourceFile);
      const hasSyntheticDefault = canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias);
      if (!exportDefaultSymbol && !hasSyntheticDefault) {
        if (hasExportAssignmentSymbol(moduleSymbol)) {
          const compilerOptionName = moduleKind >= ModuleKind.ES2015 ? 'allowSyntheticDefaultImports' : 'esModuleInterop';
          const exportEqualsSymbol = moduleSymbol.exports!.get(InternalSymbolName.ExportEquals);
          const exportAssignment = exportEqualsSymbol!.valueDeclaration;
          const err = error(node.name, qd.Module_0_can_only_be_default_imported_using_the_1_flag, moduleSymbol.symbolToString(), compilerOptionName);
          addRelatedInfo(
            err,
            createDiagnosticForNode(exportAssignment, qd.This_module_is_declared_with_using_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag, compilerOptionName)
          );
        } else {
          reportNonDefaultExport(moduleSymbol, node);
        }
      } else if (hasSyntheticDefault) {
        const resolved = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || moduleSymbol.resolveSymbol(dontResolveAlias);
        markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved, false);
        return resolved;
      }
      markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol, false);
      return exportDefaultSymbol;
    }
  }
  function reportNonDefaultExport(moduleSymbol: Symbol, node: ImportClause) {
    if (moduleSymbol.exports?.has(node.symbol.escName))
      error(node.name, qd.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead, moduleSymbol.symbolToString(), node.symbol.symbolToString());
    else {
      const diagnostic = error(node.name, qd.Module_0_has_no_default_export, moduleSymbol.symbolToString());
      const exportStar = moduleSymbol.exports?.get(InternalSymbolName.ExportStar);
      if (exportStar) {
        const defaultExport = find(
          exportStar.declarations,
          (decl) => !!(qc.is.kind(ExportDeclaration, decl) && decl.moduleSpecifier && resolveExternalModuleName(decl, decl.moduleSpecifier)?.exports?.has(InternalSymbolName.Default))
        );
        if (defaultExport) addRelatedInfo(diagnostic, createDiagnosticForNode(defaultExport, qd.export_Asterisk_does_not_re_export_a_default));
      }
    }
  }
  function getTargetOfNamespaceImport(node: NamespaceImport, dontResolveAlias: boolean): Symbol | undefined {
    const moduleSpecifier = node.parent.parent.moduleSpecifier;
    const immediate = resolveExternalModuleName(node, moduleSpecifier);
    const resolved = resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false);
    markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false);
    return resolved;
  }
  function getTargetOfNamespaceExport(node: NamespaceExport, dontResolveAlias: boolean): Symbol | undefined {
    const moduleSpecifier = node.parent.moduleSpecifier;
    const immediate = moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier);
    const resolved = moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false);
    markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false);
    return resolved;
  }
  function combineValueAndTypeSymbols(valueSymbol: Symbol, typeSymbol: Symbol): Symbol {
    if (valueSymbol === unknownSymbol && typeSymbol === unknownSymbol) return unknownSymbol;
    if (valueSymbol.flags & (SymbolFlags.Type | SymbolFlags.Namespace)) return valueSymbol;
    const result = new QSymbol(valueSymbol.flags | typeSymbol.flags, valueSymbol.escName);
    result.declarations = deduplicate(concatenate(valueSymbol.declarations, typeSymbol.declarations), equateValues);
    result.parent = valueSymbol.parent || typeSymbol.parent;
    if (valueSymbol.valueDeclaration) result.valueDeclaration = valueSymbol.valueDeclaration;
    if (typeSymbol.members) result.members = cloneMap(typeSymbol.members);
    if (valueSymbol.exports) result.exports = cloneMap(valueSymbol.exports);
    return result;
  }
  function getExternalModuleMember(node: ImportDeclaration | ExportDeclaration, specifier: ImportOrExportSpecifier, dontResolveAlias = false): Symbol | undefined {
    const moduleSymbol = resolveExternalModuleName(node, node.moduleSpecifier!)!;
    const name = specifier.propertyName || specifier.name;
    const suppressInteropError = name.escapedText === InternalSymbolName.Default && !!(compilerOptions.allowSyntheticDefaultImports || compilerOptions.esModuleInterop);
    const targetSymbol = resolveESModuleSymbol(moduleSymbol, node.moduleSpecifier!, dontResolveAlias, suppressInteropError);
    if (targetSymbol) {
      if (name.escapedText) {
        if (isShorthandAmbientModuleSymbol(moduleSymbol)) return moduleSymbol;
        let symbolFromVariable: Symbol | undefined;
        if (moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get(InternalSymbolName.ExportEquals)) symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), name.escapedText);
        else {
          symbolFromVariable = getPropertyOfVariable(targetSymbol, name.escapedText);
        }
        symbolFromVariable = symbolFromVariable.resolveSymbol(dontResolveAlias);
        let symbolFromModule = getExportOfModule(targetSymbol, specifier, dontResolveAlias);
        if (symbolFromModule === undefined && name.escapedText === InternalSymbolName.Default) {
          const file = find(moduleSymbol.declarations, isSourceFile);
          if (canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias))
            symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || moduleSymbol.resolveSymbol(dontResolveAlias);
        }
        const symbol =
          symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ? combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) : symbolFromModule || symbolFromVariable;
        if (!symbol) {
          const moduleName = getFullyQualifiedName(moduleSymbol, node);
          const declarationName = declarationNameToString(name);
          const suggestion = getSuggestedSymbolForNonexistentModule(name, targetSymbol);
          if (suggestion !== undefined) {
            const suggestionName = suggestion.symbolToString();
            const diagnostic = error(name, qd.Module_0_has_no_exported_member_1_Did_you_mean_2, moduleName, declarationName, suggestionName);
            if (suggestion.valueDeclaration) addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, qd._0_is_declared_here, suggestionName));
          } else {
            if (moduleSymbol.exports?.has(InternalSymbolName.Default)) error(name, qd.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead, moduleName, declarationName);
            else {
              reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName);
            }
          }
        }
        return symbol;
      }
    }
  }
  function reportNonExportedMember(node: ImportDeclaration | ExportDeclaration, name: Identifier, declarationName: string, moduleSymbol: Symbol, moduleName: string): void {
    const localSymbol = moduleSymbol.valueDeclaration.locals?.get(name.escapedText);
    const exports = moduleSymbol.exports;
    if (localSymbol) {
      const exportedEqualsSymbol = exports?.get(InternalSymbolName.ExportEquals);
      if (exportedEqualsSymbol) {
        getSymbolIfSameReference(exportedEqualsSymbol, localSymbol)
          ? reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName)
          : error(name, qd.Module_0_has_no_exported_member_1, moduleName, declarationName);
      } else {
        const exportedSymbol = exports ? find(symbolsToArray(exports), (symbol) => !!getSymbolIfSameReference(symbol, localSymbol)) : undefined;
        const diagnostic = exportedSymbol
          ? error(name, qd.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, exportedSymbol.symbolToString())
          : error(name, qd.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName);
        addRelatedInfo(diagnostic, ...map(localSymbol.declarations, (decl, index) => createDiagnosticForNode(decl, index === 0 ? qd._0_is_declared_here : qd.and_here, declarationName)));
      }
    } else {
      error(name, qd.Module_0_has_no_exported_member_1, moduleName, declarationName);
    }
  }
  function reportInvalidImportEqualsExportMember(node: ImportDeclaration | ExportDeclaration, name: Identifier, declarationName: string, moduleName: string) {
    if (moduleKind >= ModuleKind.ES2015) {
      const message = compilerOptions.esModuleInterop
        ? qd._0_can_only_be_imported_by_using_a_default_import
        : qd._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
      error(name, message, declarationName);
    } else {
      if (isInJSFile(node)) {
        const message = compilerOptions.esModuleInterop
          ? qd._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import
          : qd._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
        error(name, message, declarationName);
      } else {
        const message = compilerOptions.esModuleInterop
          ? qd._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import
          : qd._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
        error(name, message, declarationName, declarationName, moduleName);
      }
    }
  }
  function getTargetOfImportSpecifier(node: ImportSpecifier, dontResolveAlias: boolean): Symbol | undefined {
    const resolved = getExternalModuleMember(node.parent.parent.parent, node, dontResolveAlias);
    markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
    return resolved;
  }
  function getTargetOfNamespaceExportDeclaration(node: NamespaceExportDeclaration, dontResolveAlias: boolean): Symbol {
    const resolved = resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias);
    markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
    return resolved;
  }
  function getTargetOfExportSpecifier(node: ExportSpecifier, meaning: SymbolFlags, dontResolveAlias?: boolean) {
    const resolved = node.parent.parent.moduleSpecifier
      ? getExternalModuleMember(node.parent.parent, node, dontResolveAlias)
      : resolveEntityName(node.propertyName || node.name, meaning, false, dontResolveAlias);
    markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
    return resolved;
  }
  function getTargetOfExportAssignment(node: ExportAssignment | BinaryExpression, dontResolveAlias: boolean): Symbol | undefined {
    const expression = qc.is.kind(ExportAssignment, node) ? node.expression : node.right;
    const resolved = getTargetOfAliasLikeExpression(expression, dontResolveAlias);
    markSymbolOfAliasDeclarationIfTypeOnly(node, undefined, resolved, false);
    return resolved;
  }
  function getTargetOfAliasLikeExpression(expression: Expression, dontResolveAlias: boolean) {
    if (qc.is.kind(ClassExpression, expression)) return checkExpressionCached(expression).symbol;
    if (!qc.is.entityName(expression) && !isEntityNameExpression(expression)) return;
    const aliasLike = resolveEntityName(expression, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, true, dontResolveAlias);
    if (aliasLike) return aliasLike;
    checkExpressionCached(expression);
    return getNodeLinks(expression).resolvedSymbol;
  }
  function getTargetOfPropertyAssignment(node: PropertyAssignment, dontRecursivelyResolve: boolean): Symbol | undefined {
    const expression = node.initializer;
    return getTargetOfAliasLikeExpression(expression, dontRecursivelyResolve);
  }
  function getTargetOfPropertyAccessExpression(node: PropertyAccessExpression, dontRecursivelyResolve: boolean): Symbol | undefined {
    if (!(qc.is.kind(BinaryExpression, node.parent) && node.parent.left === node && node.parent.operatorToken.kind === Syntax.EqualsToken)) return;
    return getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve);
  }
  function getTargetOfAliasDeclaration(node: Declaration, dontRecursivelyResolve = false): Symbol | undefined {
    switch (node.kind) {
      case Syntax.ImportEqualsDeclaration:
        return getTargetOfImportEqualsDeclaration(<ImportEqualsDeclaration>node, dontRecursivelyResolve);
      case Syntax.ImportClause:
        return getTargetOfImportClause(<ImportClause>node, dontRecursivelyResolve);
      case Syntax.NamespaceImport:
        return getTargetOfNamespaceImport(<NamespaceImport>node, dontRecursivelyResolve);
      case Syntax.NamespaceExport:
        return getTargetOfNamespaceExport(<NamespaceExport>node, dontRecursivelyResolve);
      case Syntax.ImportSpecifier:
        return getTargetOfImportSpecifier(<ImportSpecifier>node, dontRecursivelyResolve);
      case Syntax.ExportSpecifier:
        return getTargetOfExportSpecifier(<ExportSpecifier>node, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, dontRecursivelyResolve);
      case Syntax.ExportAssignment:
      case Syntax.BinaryExpression:
        return getTargetOfExportAssignment(<ExportAssignment | BinaryExpression>node, dontRecursivelyResolve);
      case Syntax.NamespaceExportDeclaration:
        return getTargetOfNamespaceExportDeclaration(<NamespaceExportDeclaration>node, dontRecursivelyResolve);
      case Syntax.ShorthandPropertyAssignment:
        return resolveEntityName((node as ShorthandPropertyAssignment).name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, true, dontRecursivelyResolve);
      case Syntax.PropertyAssignment:
        return getTargetOfPropertyAssignment(node as PropertyAssignment, dontRecursivelyResolve);
      case Syntax.PropertyAccessExpression:
        return getTargetOfPropertyAccessExpression(node as PropertyAccessExpression, dontRecursivelyResolve);
      default:
        return fail();
    }
  }
  function markSymbolOfAliasDeclarationIfTypeOnly(aliasDeclaration: Declaration | undefined, immediateTarget: Symbol | undefined, finalTarget: Symbol | undefined, overwriteEmpty: boolean): boolean {
    if (!aliasDeclaration) return false;
    const sourceSymbol = getSymbolOfNode(aliasDeclaration);
    if (qc.is.typeOnlyImportOrExportDeclaration(aliasDeclaration)) {
      const ls = sourceSymbol.getLinks();
      ls.typeOnlyDeclaration = aliasDeclaration;
      return true;
    }
    const ls = sourceSymbol.getLinks();
    return markSymbolOfAliasDeclarationIfTypeOnlyWorker(ls, immediateTarget, overwriteEmpty) || markSymbolOfAliasDeclarationIfTypeOnlyWorker(ls, finalTarget, overwriteEmpty);
  }
  function markSymbolOfAliasDeclarationIfTypeOnlyWorker(aliasDeclarationLinks: SymbolLinks, target: Symbol | undefined, overwriteEmpty: boolean): boolean {
    if (target && (aliasDeclarationLinks.typeOnlyDeclaration === undefined || (overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration === false))) {
      const exportSymbol = target.exports?.get(InternalSymbolName.ExportEquals) ?? target;
      const typeOnly = exportSymbol.declarations && find(exportSymbol.declarations, isTypeOnlyImportOrExportDeclaration);
      aliasDeclarationLinks.typeOnlyDeclaration = typeOnly ?? s.getLinks(exportSymbol).typeOnlyDeclaration ?? false;
    }
    return !!aliasDeclarationLinks.typeOnlyDeclaration;
  }
  function markExportAsReferenced(node: ImportEqualsDeclaration | ExportSpecifier) {
    const symbol = getSymbolOfNode(node);
    const target = this.resolveAlias();
    if (target) {
      const markAlias = target === unknownSymbol || (target.flags & SymbolFlags.Value && !isConstEnumOrConstEnumOnlyModule(target) && !this.getTypeOnlyAliasDeclaration());
      if (markAlias) symbol.markAliasSymbolAsReferenced();
    }
  }
  function getSymbolOfPartOfRightHandSideOfImportEquals(entityName: EntityName, dontResolveAlias?: boolean): Symbol | undefined {
    if (entityName.kind === Syntax.Identifier && isRightSideOfQualifiedNameOrPropertyAccess(entityName)) entityName = <QualifiedName>entityName.parent;
    if (entityName.kind === Syntax.Identifier || entityName.parent.kind === Syntax.QualifiedName) return resolveEntityName(entityName, SymbolFlags.Namespace, false, dontResolveAlias);
    else {
      assert(entityName.parent.kind === Syntax.ImportEqualsDeclaration);
      return resolveEntityName(entityName, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, false, dontResolveAlias);
    }
  }
  function resolveEntityName(name: EntityNameOrEntityNameExpression, meaning: SymbolFlags, ignoreErrors?: boolean, dontResolveAlias?: boolean, location?: Node): Symbol | undefined {
    if (qc.is.missing(name)) return;
    const namespaceMeaning = SymbolFlags.Namespace | (isInJSFile(name) ? meaning & SymbolFlags.Value : 0);
    let symbol: Symbol | undefined;
    if (name.kind === Syntax.Identifier) {
      const message = meaning === namespaceMeaning || isSynthesized(name) ? qd.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(getFirstIdentifier(name));
      const symbolFromJSPrototype = isInJSFile(name) && !isSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : undefined;
      symbol = getMergedSymbol(resolveName(location || name, name.escapedText, meaning, ignoreErrors || symbolFromJSPrototype ? undefined : message, name, true));
      if (!symbol) return getMergedSymbol(symbolFromJSPrototype);
    } else if (name.kind === Syntax.QualifiedName || name.kind === Syntax.PropertyAccessExpression) {
      const left = name.kind === Syntax.QualifiedName ? name.left : name.expression;
      const right = name.kind === Syntax.QualifiedName ? name.right : name.name;
      let namespace = resolveEntityName(left, namespaceMeaning, ignoreErrors, false, location);
      if (!namespace || qc.is.missing(right)) return;
      else if (namespace === unknownSymbol) return namespace;
      if (isInJSFile(name)) {
        if (
          namespace.valueDeclaration &&
          qc.is.kind(VariableDeclaration, namespace.valueDeclaration) &&
          namespace.valueDeclaration.initializer &&
          isCommonJsRequire(namespace.valueDeclaration.initializer)
        ) {
          const moduleName = (namespace.valueDeclaration.initializer as CallExpression).arguments[0] as StringLiteral;
          const moduleSym = resolveExternalModuleName(moduleName, moduleName);
          if (moduleSym) {
            const resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
            if (resolvedModuleSymbol) namespace = resolvedModuleSymbol;
          }
        }
      }
      symbol = getMergedSymbol(getSymbol(namespace.getExportsOfSymbol(), right.escapedText, meaning));
      if (!symbol) {
        if (!ignoreErrors) error(right, qd.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(namespace), declarationNameToString(right));
        return;
      }
    } else throw Debug.assertNever(name, 'Unknown entity name kind.');
    assert((this.getCheckFlags() & CheckFlags.Instantiated) === 0, 'Should never get an instantiated symbol here.');
    if (!isSynthesized(name) && qc.is.entityName(name) && (symbol.flags & SymbolFlags.Alias || name.parent.kind === Syntax.ExportAssignment))
      markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol, undefined, true);
    return symbol.flags & meaning || dontResolveAlias ? symbol : symbol.resolveAlias();
  }
  function resolveEntityNameFromAssignmentDeclaration(name: Identifier, meaning: SymbolFlags) {
    if (isJSDocTypeReference(name.parent)) {
      const secondaryLocation = getAssignmentDeclarationLocation(name.parent);
      if (secondaryLocation) return resolveName(secondaryLocation, name.escapedText, meaning, undefined, name, true);
    }
  }
  function getAssignmentDeclarationLocation(node: TypeReferenceNode): Node | undefined {
    const typeAlias = Node.findAncestor(node, (node) => (!(qc.isDoc.node(node) || node.flags & NodeFlags.JSDoc) ? 'quit' : qc.isDoc.typeAlias(node)));
    if (typeAlias) return;
    const host = qc.getDoc.host(node);
    if (qc.is.kind(ExpressionStatement, host) && qc.is.kind(BinaryExpression, host.expression) && getAssignmentDeclarationKind(host.expression) === AssignmentDeclarationKind.PrototypeProperty) {
      const s = getSymbolOfNode(host.expression.left);
      if (s) return s.getDeclarationOfJSPrototypeContainer();
    }
    if (
      (qc.is.objectLiteralMethod(host) || qc.is.kind(PropertyAssignment, host)) &&
      qc.is.kind(BinaryExpression, host.parent.parent) &&
      getAssignmentDeclarationKind(host.parent.parent) === AssignmentDeclarationKind.Prototype
    ) {
      const s = getSymbolOfNode(host.parent.parent.left);
      if (s) return s.getDeclarationOfJSPrototypeContainer();
    }
    const sig = getEffectiveJSDocHost(node);
    if (sig && qc.is.functionLike(sig)) {
      const s = getSymbolOfNode(sig);
      return s && s.valueDeclaration;
    }
  }
  function resolveExternalModuleName(location: Node, moduleReferenceExpression: Expression, ignoreErrors?: boolean): Symbol | undefined {
    return resolveExternalModuleNameWorker(location, moduleReferenceExpression, ignoreErrors ? undefined : qd.Cannot_find_module_0_or_its_corresponding_type_declarations);
  }
  function resolveExternalModuleNameWorker(location: Node, moduleReferenceExpression: Expression, moduleNotFoundError: DiagnosticMessage | undefined, isForAugmentation = false): Symbol | undefined {
    return StringLiteral.like(moduleReferenceExpression)
      ? resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, moduleReferenceExpression, isForAugmentation)
      : undefined;
  }
  function resolveExternalModule(location: Node, moduleReference: string, moduleNotFoundError: DiagnosticMessage | undefined, errorNode: Node, isForAugmentation = false): Symbol | undefined {
    if (startsWith(moduleReference, '@types/')) {
      const diag = qd.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1;
      const withoutAtTypePrefix = removePrefix(moduleReference, '@types/');
      error(errorNode, diag, withoutAtTypePrefix, moduleReference);
    }
    const ambientModule = tryFindAmbientModule(moduleReference, true);
    if (ambientModule) return ambientModule;
    const currentSourceFile = qc.get.sourceFileOf(location);
    const resolvedModule = getResolvedModule(currentSourceFile, moduleReference)!;
    const resolutionDiagnostic = resolvedModule && getResolutionDiagnostic(compilerOptions, resolvedModule);
    const sourceFile = resolvedModule && !resolutionDiagnostic && host.getSourceFile(resolvedModule.resolvedFileName);
    if (sourceFile) {
      if (sourceFile.symbol) {
        if (resolvedModule.isExternalLibraryImport && !resolutionExtensionIsTSOrJson(resolvedModule.extension)) errorOnImplicitAnyModule(false, errorNode, resolvedModule, moduleReference);
        return getMergedSymbol(sourceFile.symbol);
      }
      if (moduleNotFoundError) error(errorNode, qd.File_0_is_not_a_module, sourceFile.fileName);
      return;
    }
    if (patternAmbientModules) {
      const pattern = findBestPatternMatch(patternAmbientModules, (_) => _.pattern, moduleReference);
      if (pattern) {
        const augmentation = patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(moduleReference);
        if (augmentation) return getMergedSymbol(augmentation);
        return getMergedSymbol(pattern.symbol);
      }
    }
    if (
      (resolvedModule && !resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic === undefined) ||
      resolutionDiagnostic === qd.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type
    ) {
      if (isForAugmentation) {
        const diag = qd.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented;
        error(errorNode, diag, moduleReference, resolvedModule.resolvedFileName);
      } else {
        errorOnImplicitAnyModule(noImplicitAny && !!moduleNotFoundError, errorNode, resolvedModule, moduleReference);
      }
      return;
    }
    if (moduleNotFoundError) {
      if (resolvedModule) {
        const redirect = host.getProjectReferenceRedirect(resolvedModule.resolvedFileName);
        if (redirect) {
          error(errorNode, qd.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName);
          return;
        }
      }
      if (resolutionDiagnostic) error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
      else {
        const tsExtension = tryExtractTSExtension(moduleReference);
        if (tsExtension) {
          const diag = qd.An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead;
          error(errorNode, diag, tsExtension, removeExtension(moduleReference, tsExtension));
        } else if (
          !compilerOptions.resolveJsonModule &&
          fileExtensionIs(moduleReference, Extension.Json) &&
          getEmitModuleResolutionKind(compilerOptions) === ModuleResolutionKind.NodeJs &&
          hasJsonModuleEmitEnabled(compilerOptions)
        ) {
          error(errorNode, qd.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference);
        } else {
          error(errorNode, moduleNotFoundError, moduleReference);
        }
      }
    }
    return;
  }
  function errorOnImplicitAnyModule(isError: boolean, errorNode: Node, { packageId, resolvedFileName }: ResolvedModuleFull, moduleReference: string): void {
    const errorInfo =
      !qp_isExternalModuleNameRelative(moduleReference) && packageId
        ? typesPackageExists(packageId.name)
          ? chainDiagnosticMessages(
              undefined,
              qd.If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1,
              packageId.name,
              mangleScopedPackageName(packageId.name)
            )
          : chainDiagnosticMessages(
              undefined,
              qd.Try_npm_install_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0,
              moduleReference,
              mangleScopedPackageName(packageId.name)
            )
        : undefined;
    errorOrSuggestion(isError, errorNode, chainDiagnosticMessages(errorInfo, qd.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type, moduleReference, resolvedFileName));
  }
  function typesPackageExists(packageName: string): boolean {
    return getPackagesSet().has(getTypesPackageName(packageName));
  }
  function resolveExternalModuleSymbol(moduleSymbol: Symbol, dontResolveAlias?: boolean): Symbol;
  function resolveExternalModuleSymbol(moduleSymbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined;
  function resolveExternalModuleSymbol(moduleSymbol: Symbol, dontResolveAlias?: boolean): Symbol {
    if (moduleSymbol?.exports) {
      const exportEquals = moduleSymbol.exports.get(InternalSymbolName.ExportEquals)?.resolveSymbol(dontResolveAlias);
      const exported = getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol));
      return getMergedSymbol(exported) || moduleSymbol;
    }
    return undefined!;
  }
  function getCommonJsExportEquals(exported: Symbol | undefined, moduleSymbol: Symbol): Symbol | undefined {
    if (!exported || exported === unknownSymbol || exported === moduleSymbol || moduleSymbol.exports!.size === 1 || exported.flags & SymbolFlags.Alias) return exported;
    const ls = exported.getLinks();
    if (ls.cjsExportMerged) return ls.cjsExportMerged;
    const merged = exported.flags & SymbolFlags.Transient ? exported : exported.clone();
    merged.flags = merged.flags | SymbolFlags.ValueModule;
    if (merged.exports === undefined) merged.exports = new SymbolTable();
    moduleSymbol.exports!.forEach((s, name) => {
      if (name === InternalSymbolName.ExportEquals) return;
      merged.exports!.set(name, merged.exports!.has(name) ? s.merge(merged.exports!.get(name)!) : s);
    });
    merged.getLinks().cjsExportMerged = merged;
    return (ls.cjsExportMerged = merged);
  }
  function resolveESModuleSymbol(moduleSymbol: Symbol | undefined, referencingLocation: Node, dontResolveAlias: boolean, suppressInteropError: boolean): Symbol | undefined {
    const symbol = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias);
    if (!dontResolveAlias && symbol) {
      if (!suppressInteropError && !(symbol.flags & (SymbolFlags.Module | SymbolFlags.Variable)) && !getDeclarationOfKind(symbol, Syntax.SourceFile)) {
        const compilerOptionName = moduleKind >= ModuleKind.ES2015 ? 'allowSyntheticDefaultImports' : 'esModuleInterop';
        error(referencingLocation, qd.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName);
        return symbol;
      }
      if (compilerOptions.esModuleInterop) {
        const referenceParent = referencingLocation.parent;
        if ((qc.is.kind(ImportDeclaration, referenceParent) && getNamespaceDeclarationNode(referenceParent)) || qc.is.importCall(referenceParent)) {
          const type = this.getTypeOfSymbol();
          let sigs = getSignaturesOfStructuredType(type, SignatureKind.Call);
          if (!sigs || !sigs.length) sigs = getSignaturesOfStructuredType(type, SignatureKind.Construct);
          if (sigs && sigs.length) {
            const moduleType = getTypeWithSyntheticDefaultImportType(type, symbol, moduleSymbol!);
            const result = new QSymbol(symbol.flags, symbol.escName);
            result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
            result.parent = symbol.parent;
            result.target = symbol;
            result.originatingImport = referenceParent;
            if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;
            if (symbol.constEnumOnlyModule) result.constEnumOnlyModule = true;
            if (symbol.members) result.members = cloneMap(symbol.members);
            if (symbol.exports) result.exports = cloneMap(symbol.exports);
            const resolvedModuleType = resolveStructuredTypeMembers(moduleType as StructuredType);
            result.type = createAnonymousType(result, resolvedModuleType.members, empty, empty, resolvedModuleType.stringIndexInfo, resolvedModuleType.numberIndexInfo);
            return result;
          }
        }
      }
    }
    return symbol;
  }
  function hasExportAssignmentSymbol(moduleSymbol: Symbol): boolean {
    return moduleSymbol.exports!.get(InternalSymbolName.ExportEquals) !== undefined;
  }
  function getExportsOfModuleAsArray(moduleSymbol: Symbol): Symbol[] {
    return symbolsToArray(getExportsOfModule(moduleSymbol));
  }
  function getExportsAndPropertiesOfModule(moduleSymbol: Symbol): Symbol[] {
    const exports = getExportsOfModuleAsArray(moduleSymbol);
    const exportEquals = resolveExternalModuleSymbol(moduleSymbol);
    if (exportEquals !== moduleSymbol) addRange(exports, getPropertiesOfType(getTypeOfSymbol(exportEquals)));
    return exports;
  }
  function tryGetMemberInModuleExports(memberName: __String, moduleSymbol: Symbol): Symbol | undefined {
    const symbolTable = getExportsOfModule(moduleSymbol);
    if (symbolTable) return symbolTable.get(memberName);
  }
  function tryGetMemberInModuleExportsAndProperties(memberName: __String, moduleSymbol: Symbol): Symbol | undefined {
    const symbol = tryGetMemberInModuleExports(memberName, moduleSymbol);
    if (symbol) return symbol;
    const exportEquals = resolveExternalModuleSymbol(moduleSymbol);
    if (exportEquals === moduleSymbol) return;
    const type = getTypeOfSymbol(exportEquals);
    return type.flags & TypeFlags.Primitive || getObjectFlags(type) & ObjectFlags.Class || isArrayOrTupleLikeType(type) ? undefined : getPropertyOfType(type, memberName);
  }
  interface ExportCollisionTracker {
    specifierText: string;
    exportsWithDuplicate: ExportDeclaration[];
  }
  type ExportCollisionTrackerTable = UnderscoreEscapedMap<ExportCollisionTracker>;
  function extendExportSymbols(target: SymbolTable, source: SymbolTable | undefined, lookupTable?: ExportCollisionTrackerTable, exportNode?: ExportDeclaration) {
    if (!source) return;
    source.forEach((sourceSymbol, id) => {
      if (id === InternalSymbolName.Default) return;
      const targetSymbol = target.get(id);
      if (!targetSymbol) {
        target.set(id, sourceSymbol);
        if (lookupTable && exportNode) {
          lookupTable.set(id, {
            specifierText: qc.get.textOf(exportNode.moduleSpecifier!),
          } as ExportCollisionTracker);
        }
      } else if (lookupTable && exportNode && targetSymbol && targetSymbol.resolveSymbol() !== sourceSymbol.resolveSymbol()) {
        const collisionTracker = lookupTable.get(id)!;
        if (!collisionTracker.exportsWithDuplicate) collisionTracker.exportsWithDuplicate = [exportNode];
        else {
          collisionTracker.exportsWithDuplicate.push(exportNode);
        }
      }
    });
  }
  function getSymbolOfNode(node: Declaration): Symbol;
  function getSymbolOfNode(node: Node): Symbol | undefined;
  function getSymbolOfNode(node: Node): Symbol | undefined {
    return getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol));
  }
  function getFileSymbolIfFileSymbolExportEqualsContainer(d: Declaration, container: Symbol) {
    const fileSymbol = getExternalModuleContainer(d);
    const exported = fileSymbol && fileSymbol.exports && fileSymbol.exports.get(InternalSymbolName.ExportEquals);
    return exported && getSymbolIfSameReference(exported, container) ? fileSymbol : undefined;
  }
  function getSymbolIfSameReference(s1: Symbol, s2: Symbol) {
    if (getMergedSymbol(getMergedSymbol(s1).resolveSymbol()) === getMergedSymbol(getMergedSymbol(s2).resolveSymbol())) return s1;
  }
  function findConstructorDeclaration(node: ClassLikeDeclaration): ConstructorDeclaration | undefined {
    const members = node.members;
    for (const member of members) {
      if (member.kind === Syntax.Constructor && qc.is.present((<ConstructorDeclaration>member).body)) return <ConstructorDeclaration>member;
    }
  }
  function createIntrinsicType(kind: TypeFlags, intrinsicName: string, objectFlags: ObjectFlags = 0): IntrinsicType {
    const type = <IntrinsicType>createType(kind);
    type.intrinsicName = intrinsicName;
    type.objectFlags = objectFlags;
    return type;
  }
  function createBooleanType(trueFalseTypes: readonly Type[]): IntrinsicType & UnionType {
    const type = <IntrinsicType & UnionType>getUnionType(trueFalseTypes);
    type.flags |= TypeFlags.Boolean;
    type.intrinsicName = 'boolean';
    return type;
  }
  function createObjectType(objectFlags: ObjectFlags, symbol?: Symbol): ObjectType {
    const type = <ObjectType>createType(TypeFlags.Object);
    type.objectFlags = objectFlags;
    type.symbol = symbol!;
    type.members = undefined;
    type.properties = undefined;
    type.callSignatures = undefined;
    type.constructSignatures = undefined;
    type.stringIndexInfo = undefined;
    type.numberIndexInfo = undefined;
    return type;
  }
  function createTypeofType() {
    return getUnionType(arrayFrom(typeofEQFacts.keys(), getLiteralType));
  }
  function createTypeParameter(symbol?: Symbol) {
    const type = <TypeParameter>createType(TypeFlags.TypeParameter);
    if (symbol) type.symbol = symbol;
    return type;
  }
  function getNamedMembers(ms: SymbolTable): Symbol[] {
    let r: Symbol[] | undefined;
    ms.forEach((symbol, id) => {
      if (!syntax.is.reservedName(id) && symbolIsValue(symbol)) (r || (r = [])).push(symbol);
    });
    return r || empty;
  }
  function setStructuredTypeMembers(
    type: StructuredType,
    members: SymbolTable,
    callSignatures: readonly Signature[],
    constructSignatures: readonly Signature[],
    stringIndexInfo: IndexInfo | undefined,
    numberIndexInfo: IndexInfo | undefined
  ): ResolvedType {
    (<ResolvedType>type).members = members;
    (<ResolvedType>type).properties = members === emptySymbols ? empty : getNamedMembers(members);
    (<ResolvedType>type).callSignatures = callSignatures;
    (<ResolvedType>type).constructSignatures = constructSignatures;
    (<ResolvedType>type).stringIndexInfo = stringIndexInfo;
    (<ResolvedType>type).numberIndexInfo = numberIndexInfo;
    return <ResolvedType>type;
  }
  function createAnonymousType(
    symbol: Symbol | undefined,
    members: SymbolTable,
    callSignatures: readonly Signature[],
    constructSignatures: readonly Signature[],
    stringIndexInfo: IndexInfo | undefined,
    numberIndexInfo: IndexInfo | undefined
  ): ResolvedType {
    return setStructuredTypeMembers(createObjectType(ObjectFlags.Anonymous, symbol), members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
  }
  function forEachSymbolTableInScope<T>(enclosingDeclaration: Node | undefined, callback: (symbolTable: SymbolTable) => T): T {
    let result: T;
    for (let location = enclosingDeclaration; location; location = location.parent) {
      if (location.locals && !isGlobalSourceFile(location)) if ((result = callback(location.locals))) return result;
      switch (location.kind) {
        case Syntax.SourceFile:
          if (!isExternalOrCommonJsModule(<SourceFile>location)) break;
        case Syntax.ModuleDeclaration:
          const sym = getSymbolOfNode(location as ModuleDeclaration);
          if ((result = callback(sym?.exports || emptySymbols))) return result;
          break;
        case Syntax.ClassDeclaration:
        case Syntax.ClassExpression:
        case Syntax.InterfaceDeclaration:
          let table: UnderscoreEscapedMap<Symbol> | undefined;
          (getSymbolOfNode(location as ClassLikeDeclaration | InterfaceDeclaration).members || emptySymbols).forEach((memberSymbol, key) => {
            if (memberSymbol.flags & (SymbolFlags.Type & ~SymbolFlags.Assignment)) (table || (table = new SymbolTable())).set(key, memberSymbol);
          });
          if (table && (result = callback(table))) return result;
          break;
      }
    }
    return callback(globals);
  }
  function getQualifiedLeftMeaning(rightMeaning: SymbolFlags) {
    return rightMeaning === SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace;
  }
  function getAccessibleSymbolChain(
    symbol: Symbol | undefined,
    enclosingDeclaration: Node | undefined,
    meaning: SymbolFlags,
    useOnlyExternalAliasing: boolean,
    visitedSymbolTablesMap: qb.QMap<SymbolTable[]> = new qb.QMap()
  ): Symbol[] | undefined {
    if (!(symbol && !isPropertyOrMethodDeclarationSymbol(symbol))) return;
    const id = '' + symbol.getId();
    let visitedSymbolTables = visitedSymbolTablesMap.get(id);
    if (!visitedSymbolTables) visitedSymbolTablesMap.set(id, (visitedSymbolTables = []));
    return forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);
    function getAccessibleSymbolChainFromSymbolTable(symbols: SymbolTable, ignoreQualification?: boolean): Symbol[] | undefined {
      if (!pushIfUnique(visitedSymbolTables!, symbols)) return;
      const result = trySymbolTable(symbols, ignoreQualification);
      visitedSymbolTables!.pop();
      return result;
    }
    function canQualifySymbol(symbolFromSymbolTable: Symbol, meaning: SymbolFlags) {
      return (
        !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) ||
        !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap)
      );
    }
    function isAccessible(symbolFromSymbolTable: Symbol, resolvedAliasSymbol?: Symbol, ignoreQualification?: boolean) {
      return (
        (symbol === (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) === getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) &&
        !some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) &&
        (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning))
      );
    }
    function trySymbolTable(symbols: SymbolTable, ignoreQualification: boolean | undefined): Symbol[] | undefined {
      if (isAccessible(symbols.get(symbol!.escName)!, undefined, ignoreQualification)) return [symbol!];
      const result = forEachEntry(symbols, (symbolFromSymbolTable) => {
        if (
          symbolFromSymbolTable.flags & SymbolFlags.Alias &&
          symbolFromSymbolTable.escName !== InternalSymbolName.ExportEquals &&
          symbolFromSymbolTable.escName !== InternalSymbolName.Default &&
          !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && qp_isExternalModule(qc.get.sourceFileOf(enclosingDeclaration))) &&
          (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, qp_isExternalModuleImportEqualsDeclaration)) &&
          (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, Syntax.ExportSpecifier))
        ) {
          const resolvedImportedSymbol = symbolFromSymbolTable.resolveAlias();
          const candidate = getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification);
          if (candidate) return candidate;
        }
        if (symbolFromSymbolTable.escName === symbol!.escName && symbolFromSymbolTable.exportSymbol) {
          if (isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), undefined, ignoreQualification)) return [symbol!];
        }
      });
      return result || (symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : undefined);
    }
    function getCandidateListForSymbol(symbolFromSymbolTable: Symbol, resolvedImportedSymbol: Symbol, ignoreQualification: boolean | undefined) {
      if (isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)) return [symbolFromSymbolTable];
      const candidateTable = resolvedImportedSymbol.getExportsOfSymbol();
      const accessibleSymbolsFromExports = candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable, true);
      if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
    }
  }
  function isAnySymbolAccessible(
    symbols: Symbol[] | undefined,
    enclosingDeclaration: Node | undefined,
    initialSymbol: Symbol,
    meaning: SymbolFlags,
    shouldComputeAliasesToMakeVisible: boolean
  ): SymbolAccessibilityResult | undefined {
    if (!length(symbols)) return;
    let hadAccessibleChain: Symbol | undefined;
    let earlyModuleBail = false;
    for (const symbol of symbols!) {
      const accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, false);
      if (accessibleSymbolChain) {
        hadAccessibleChain = symbol;
        const hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible);
        if (hasAccessibleDeclarations) return hasAccessibleDeclarations;
      } else {
        if (some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
          if (shouldComputeAliasesToMakeVisible) {
            earlyModuleBail = true;
            continue;
          }
          return {
            accessibility: SymbolAccessibility.Accessible,
          };
        }
      }
      let containers = getContainersOfSymbol(symbol, enclosingDeclaration);
      const firstDecl: Node | false = !!length(symbol.declarations) && first(symbol.declarations);
      if (!length(containers) && meaning & SymbolFlags.Value && firstDecl && qc.is.kind(ObjectLiteralExpression, firstDecl)) {
        if (firstDecl.parent && qc.is.kind(VariableDeclaration, firstDecl.parent) && firstDecl === firstDecl.parent.initializer) containers = [getSymbolOfNode(firstDecl.parent)];
      }
      const parentResult = isAnySymbolAccessible(
        containers,
        enclosingDeclaration,
        initialSymbol,
        initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning,
        shouldComputeAliasesToMakeVisible
      );
      if (parentResult) return parentResult;
    }
    if (earlyModuleBail) {
      return {
        accessibility: SymbolAccessibility.Accessible,
      };
    }
    if (hadAccessibleChain) {
      return {
        accessibility: SymbolAccessibility.NotAccessible,
        errorSymbolName: initialSymbol.symbolToString(enclosingDeclaration, meaning),
        errorModuleName: hadAccessibleChain !== initialSymbol ? hadAccessibleChain.symbolToString(enclosingDeclaration, SymbolFlags.Namespace) : undefined,
      };
    }
  }
  function isSymbolAccessible(symbol: Symbol | undefined, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, shouldComputeAliasesToMakeVisible: boolean): SymbolAccessibilityResult {
    if (symbol && enclosingDeclaration) {
      const result = isAnySymbolAccessible([symbol], enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible);
      if (result) return result;
      const symbolExternalModule = forEach(symbol.declarations, getExternalModuleContainer);
      if (symbolExternalModule) {
        const enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);
        if (symbolExternalModule !== enclosingExternalModule) {
          return {
            accessibility: SymbolAccessibility.CannotBeNamed,
            errorSymbolName: symbol.symbolToString(enclosingDeclaration, meaning),
            errorModuleName: symbolExternalModule.symbolToString(),
          };
        }
      }
      return {
        accessibility: SymbolAccessibility.NotAccessible,
        errorSymbolName: symbol.symbolToString(enclosingDeclaration, meaning),
      };
    }
    return { accessibility: SymbolAccessibility.Accessible };
  }
  function getExternalModuleContainer(declaration: Node) {
    const node = Node.findAncestor(declaration, hasExternalModuleSymbol);
    return node && getSymbolOfNode(node);
  }
  function hasExternalModuleSymbol(declaration: Node) {
    return qc.is.ambientModule(declaration) || (declaration.kind === Syntax.SourceFile && isExternalOrCommonJsModule(<SourceFile>declaration));
  }
  function hasNonGlobalAugmentationExternalModuleSymbol(declaration: Node) {
    return qc.is.moduleWithStringLiteralName(declaration) || (declaration.kind === Syntax.SourceFile && isExternalOrCommonJsModule(<SourceFile>declaration));
  }
  function isEntityNameVisible(entityName: EntityNameOrEntityNameExpression, enclosingDeclaration: Node): SymbolVisibilityResult {
    let meaning: SymbolFlags;
    if (entityName.parent.kind === Syntax.TypeQuery || isExpressionWithTypeArgumentsInClassExtendsClause(entityName.parent) || entityName.parent.kind === Syntax.ComputedPropertyName)
      meaning = SymbolFlags.Value | SymbolFlags.ExportValue;
    else if (entityName.kind === Syntax.QualifiedName || entityName.kind === Syntax.PropertyAccessExpression || entityName.parent.kind === Syntax.ImportEqualsDeclaration) {
      meaning = SymbolFlags.Namespace;
    } else {
      meaning = SymbolFlags.Type;
    }
    const firstIdentifier = getFirstIdentifier(entityName);
    const symbol = resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning, undefined, undefined, false);
    return (
      (symbol && hasVisibleDeclarations(symbol, true)) || {
        accessibility: SymbolAccessibility.NotAccessible,
        errorSymbolName: qc.get.textOf(firstIdentifier),
        errorNode: firstIdentifier,
      }
    );
  }
  function signatureToString(signature: Signature, enclosingDeclaration?: Node, flags = TypeFormatFlags.None, kind?: SignatureKind, writer?: EmitTextWriter): string {
    return writer ? signatureToStringWorker(writer).getText() : usingSingleLineStringWriter(signatureToStringWorker);
    function signatureToStringWorker(writer: EmitTextWriter) {
      let sigOutput: Syntax;
      if (flags & TypeFormatFlags.WriteArrowStyleSignature) sigOutput = kind === SignatureKind.Construct ? Syntax.ConstructorType : Syntax.FunctionType;
      else {
        sigOutput = kind === SignatureKind.Construct ? Syntax.ConstructSignature : Syntax.CallSignature;
      }
      const sig = nodeBuilder.signatureToSignatureDeclaration(
        signature,
        sigOutput,
        enclosingDeclaration,
        toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName
      );
      const printer = createPrinter({ removeComments: true, omitTrailingSemicolon: true });
      const sourceFile = enclosingDeclaration && qc.get.sourceFileOf(enclosingDeclaration);
      printer.writeNode(EmitHint.Unspecified, sig!, sourceFile, getTrailingSemicolonDeferringWriter(writer));
      return writer;
    }
  }
  function typeToString(
    type: Type,
    enclosingDeclaration?: Node,
    flags: TypeFormatFlags = TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope,
    writer: EmitTextWriter = createTextWriter('')
  ): string {
    const noTruncation = compilerOptions.noErrorTruncation || flags & TypeFormatFlags.NoTruncation;
    const typeNode = nodeBuilder.typeToTypeNode(type, enclosingDeclaration, toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | (noTruncation ? NodeBuilderFlags.NoTruncation : 0), writer);
    if (typeNode === undefined) return fail('should always get typenode');
    const options = { removeComments: true };
    const printer = createPrinter(options);
    const sourceFile = enclosingDeclaration && qc.get.sourceFileOf(enclosingDeclaration);
    printer.writeNode(EmitHint.Unspecified, typeNode, sourceFile, writer);
    const result = writer.getText();
    const maxLength = noTruncation ? noTruncationMaximumTruncationLength * 2 : defaultMaximumTruncationLength * 2;
    if (maxLength && result && result.length >= maxLength) return result.substr(0, maxLength - '...'.length) + '...';
    return result;
  }
  function getTypeNamesForErrorDisplay(left: Type, right: Type): [string, string] {
    let leftStr = symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left);
    let rightStr = symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right);
    if (leftStr === rightStr) {
      leftStr = getTypeNameForErrorDisplay(left);
      rightStr = getTypeNameForErrorDisplay(right);
    }
    return [leftStr, rightStr];
  }
  function getTypeNameForErrorDisplay(type: Type) {
    return typeToString(type, undefined, TypeFormatFlags.UseFullyQualifiedType);
  }
  function toNodeBuilderFlags(flags = TypeFormatFlags.None): NodeBuilderFlags {
    return flags & TypeFormatFlags.NodeBuilderFlagsMask;
  }
  function typePredicateToString(
    typePredicate: TypePredicate,
    enclosingDeclaration?: Node,
    flags: TypeFormatFlags = TypeFormatFlags.UseAliasDefinedOutsideCurrentScope,
    writer?: EmitTextWriter
  ): string {
    return writer ? typePredicateToStringWorker(writer).getText() : usingSingleLineStringWriter(typePredicateToStringWorker);
    function typePredicateToStringWorker(writer: EmitTextWriter) {
      const predicate = new qc.TypePredicateNode(
        typePredicate.kind === TypePredicateKind.AssertsThis || typePredicate.kind === TypePredicateKind.AssertsIdentifier ? new Token(Syntax.AssertsKeyword) : undefined,
        typePredicate.kind === TypePredicateKind.Identifier || typePredicate.kind === TypePredicateKind.AssertsIdentifier ? new Identifier(typePredicate.parameterName) : ThisTypeNode.create(),
        typePredicate.type &&
          nodeBuilder.typeToTypeNode(typePredicate.type, enclosingDeclaration, toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName)!
      );
      const printer = createPrinter({ removeComments: true });
      const sourceFile = enclosingDeclaration && qc.get.sourceFileOf(enclosingDeclaration);
      printer.writeNode(EmitHint.Unspecified, predicate, sourceFile, writer);
      return writer;
    }
  }
  function formatUnionTypes(types: readonly Type[]): Type[] {
    const result: Type[] = [];
    let flags: TypeFlags = 0;
    for (let i = 0; i < types.length; i++) {
      const t = types[i];
      flags |= t.flags;
      if (!(t.flags & TypeFlags.Nullable)) {
        if (t.flags & (TypeFlags.BooleanLiteral | TypeFlags.EnumLiteral)) {
          const baseType = t.flags & TypeFlags.BooleanLiteral ? booleanType : getBaseTypeOfEnumLiteralType(<LiteralType>t);
          if (baseType.flags & TypeFlags.Union) {
            const count = (<UnionType>baseType).types.length;
            if (i + count <= types.length && getRegularTypeOfLiteralType(types[i + count - 1]) === getRegularTypeOfLiteralType((<UnionType>baseType).types[count - 1])) {
              result.push(baseType);
              i += count - 1;
              continue;
            }
          }
        }
        result.push(t);
      }
    }
    if (flags & TypeFlags.Null) result.push(nullType);
    if (flags & TypeFlags.Undefined) result.push(undefinedType);
    return result || types;
  }
  function visibilityToString(flags: ModifierFlags): string | undefined {
    if (flags === ModifierFlags.Private) return 'private';
    if (flags === ModifierFlags.Protected) return 'protected';
    return 'public';
  }
  function getTypeAliasForTypeLiteral(type: Type): Symbol | undefined {
    if (type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral) {
      const node = walkUpParenthesizedTypes(type.symbol.declarations[0].parent);
      if (node.kind === Syntax.TypeAliasDeclaration) return getSymbolOfNode(node);
    }
    return;
  }
  function isTopLevelInExternalModuleAugmentation(node: Node): boolean {
    return node && node.parent && node.parent.kind === Syntax.ModuleBlock && qc.is.externalModuleAugmentation(node.parent.parent);
  }
  function isDefaultBindingContext(location: Node) {
    return location.kind === Syntax.SourceFile || qc.is.ambientModule(location);
  }
  function isDeclarationVisible(node: Node): boolean {
    if (node) {
      const ls = getNodeLinks(node);
      if (ls.isVisible === undefined) ls.isVisible = !!determineIfDeclarationIsVisible();
      return ls.isVisible;
    }
    return false;
    function determineIfDeclarationIsVisible() {
      switch (node.kind) {
        case Syntax.JSDocCallbackTag:
        case Syntax.JSDocTypedefTag:
        case Syntax.JSDocEnumTag:
          return !!(node.parent && node.parent.parent && node.parent.parent.parent && qc.is.kind(SourceFile, node.parent.parent.parent));
        case Syntax.BindingElement:
          return isDeclarationVisible(node.parent.parent);
        case Syntax.VariableDeclaration:
          if (qc.is.kind(BindingPattern, (node as VariableDeclaration).name) && !((node as VariableDeclaration).name as BindingPattern).elements.length) return false;
        case Syntax.ModuleDeclaration:
        case Syntax.ClassDeclaration:
        case Syntax.InterfaceDeclaration:
        case Syntax.TypeAliasDeclaration:
        case Syntax.FunctionDeclaration:
        case Syntax.EnumDeclaration:
        case Syntax.ImportEqualsDeclaration:
          if (qc.is.externalModuleAugmentation(node)) return true;
          const parent = getDeclarationContainer(node);
          if (
            !(getCombinedModifierFlags(node as Declaration) & ModifierFlags.Export) &&
            !(node.kind !== Syntax.ImportEqualsDeclaration && parent.kind !== Syntax.SourceFile && parent.flags & NodeFlags.Ambient)
          ) {
            return isGlobalSourceFile(parent);
          }
          return isDeclarationVisible(parent);
        case Syntax.PropertyDeclaration:
        case Syntax.PropertySignature:
        case Syntax.GetAccessor:
        case Syntax.SetAccessor:
        case Syntax.MethodDeclaration:
        case Syntax.MethodSignature:
          if (hasEffectiveModifier(node, ModifierFlags.Private | ModifierFlags.Protected)) return false;
        case Syntax.Constructor:
        case Syntax.ConstructSignature:
        case Syntax.CallSignature:
        case Syntax.IndexSignature:
        case Syntax.Parameter:
        case Syntax.ModuleBlock:
        case Syntax.FunctionType:
        case Syntax.ConstructorType:
        case Syntax.TypeLiteral:
        case Syntax.TypeReference:
        case Syntax.ArrayType:
        case Syntax.TupleType:
        case Syntax.UnionType:
        case Syntax.IntersectionType:
        case Syntax.ParenthesizedType:
        case Syntax.NamedTupleMember:
          return isDeclarationVisible(node.parent);
        case Syntax.ImportClause:
        case Syntax.NamespaceImport:
        case Syntax.ImportSpecifier:
          return false;
        case Syntax.TypeParameter:
        case Syntax.SourceFile:
        case Syntax.NamespaceExportDeclaration:
          return true;
        case Syntax.ExportAssignment:
          return false;
        default:
          return false;
      }
    }
  }
  function collectLinkedAliases(node: Identifier, setVisibility?: boolean): Node[] | undefined {
    let exportSymbol: Symbol | undefined;
    if (node.parent && node.parent.kind === Syntax.ExportAssignment)
      exportSymbol = resolveName(node, node.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, undefined, node, false);
    else if (node.parent.kind === Syntax.ExportSpecifier) {
      exportSymbol = getTargetOfExportSpecifier(<ExportSpecifier>node.parent, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias);
    }
    let result: Node[] | undefined;
    let visited: qb.QMap<true> | undefined;
    if (exportSymbol) {
      visited = new qb.QMap();
      visited.set('' + exportSymbol.getId(), true);
      buildVisibleNodeList(exportSymbol.declarations);
    }
    return result;
    function buildVisibleNodeList(declarations: Declaration[]) {
      forEach(declarations, (declaration) => {
        const resultNode = getAnyImportSyntax(declaration) || declaration;
        if (setVisibility) getNodeLinks(declaration).isVisible = true;
        else {
          result = result || [];
          pushIfUnique(result, resultNode);
        }
        if (isInternalModuleImportEqualsDeclaration(declaration)) {
          const internalModuleReference = <Identifier | QualifiedName>declaration.moduleReference;
          const firstIdentifier = getFirstIdentifier(internalModuleReference);
          const importSymbol = resolveName(declaration, firstIdentifier.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, undefined, undefined, false);
          const id = importSymbol && '' + importSymbol.getId();
          if (importSymbol && !visited!.has(id!)) {
            visited!.set(id!, true);
            buildVisibleNodeList(importSymbol.declarations);
          }
        }
      });
    }
  }
  function pushTypeResolution(target: TypeSystemEntity, propertyName: TypeSystemPropertyName): boolean {
    const resolutionCycleStartIndex = findResolutionCycleStartIndex(target, propertyName);
    if (resolutionCycleStartIndex >= 0) {
      const { length } = resolutionTargets;
      for (let i = resolutionCycleStartIndex; i < length; i++) {
        resolutionResults[i] = false;
      }
      return false;
    }
    resolutionTargets.push(target);
    resolutionResults.push(true);
    resolutionPropertyNames.push(propertyName);
    return true;
  }
  function findResolutionCycleStartIndex(target: TypeSystemEntity, propertyName: TypeSystemPropertyName): number {
    for (let i = resolutionTargets.length - 1; i >= 0; i--) {
      if (qc.is.withType(resolutionTargets[i], resolutionPropertyNames[i])) return -1;
      if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) return i;
    }
    return -1;
  }
  function isNodewithType(target: TypeSystemEntity, propertyName: TypeSystemPropertyName): boolean {
    switch (propertyName) {
      case TypeSystemPropertyName.Type:
        return !!s.getLinks(<Symbol>target).type;
      case TypeSystemPropertyName.EnumTagType:
        return !!getNodeLinks(target as JSDocEnumTag).resolvedEnumType;
      case TypeSystemPropertyName.DeclaredType:
        return !!s.getLinks(<Symbol>target).declaredType;
      case TypeSystemPropertyName.ResolvedBaseConstructorType:
        return !!(<InterfaceType>target).resolvedBaseConstructorType;
      case TypeSystemPropertyName.ResolvedReturnType:
        return !!(<Signature>target).resolvedReturnType;
      case TypeSystemPropertyName.ImmediateBaseConstraint:
        return !!(<Type>target).immediateBaseConstraint;
      case TypeSystemPropertyName.ResolvedTypeArguments:
        return !!(target as TypeReference).resolvedTypeArguments;
    }
    return Debug.assertNever(propertyName);
  }
  function popTypeResolution(): boolean {
    resolutionTargets.pop();
    resolutionPropertyNames.pop();
    return resolutionResults.pop()!;
  }
  function getDeclarationContainer(node: Node): Node {
    return Node.findAncestor(getRootDeclaration(node), (node) => {
      switch (node.kind) {
        case Syntax.VariableDeclaration:
        case Syntax.VariableDeclarationList:
        case Syntax.ImportSpecifier:
        case Syntax.NamedImports:
        case Syntax.NamespaceImport:
        case Syntax.ImportClause:
          return false;
        default:
          return true;
      }
    })!.parent;
  }
  function getTypeOfPrototypeProperty(prototype: Symbol): Type {
    const classType = <InterfaceType>getDeclaredTypeOfSymbol(getParentOfSymbol(prototype)!);
    return classType.typeParameters
      ? createTypeReference(
          <GenericType>classType,
          map(classType.typeParameters, (_) => anyType)
        )
      : classType;
  }
  function getTypeOfPropertyOfType(type: Type, name: __String): Type | undefined {
    const prop = getPropertyOfType(type, name);
    return prop ? getTypeOfSymbol(prop) : undefined;
  }
  function getTypeOfPropertyOrIndexSignature(type: Type, name: __String): Type {
    return getTypeOfPropertyOfType(type, name) || (NumericLiteral.name(name) && getIndexTypeOfType(type, IndexKind.Number)) || getIndexTypeOfType(type, IndexKind.String) || unknownType;
  }
  function isTypeAny(type: Type | undefined) {
    return type && (type.flags & TypeFlags.Any) !== 0;
  }
  function getTypeForBindingElementParent(node: BindingElementGrandparent) {
    const symbol = getSymbolOfNode(node);
    return (symbol && s.getLinks(symbol).type) || getTypeForVariableLikeDeclaration(node, false);
  }
  function getRestType(source: Type, properties: PropertyName[], symbol: Symbol | undefined): Type {
    source = filterType(source, (t) => !(t.flags & TypeFlags.Nullable));
    if (source.flags & TypeFlags.Never) return emptyObjectType;
    if (source.flags & TypeFlags.Union) return mapType(source, (t) => getRestType(t, properties, symbol));
    const omitKeyType = getUnionType(map(properties, getLiteralTypeFromPropertyName));
    if (isGenericObjectType(source) || isGenericIndexType(omitKeyType)) {
      if (omitKeyType.flags & TypeFlags.Never) return source;
      const omitTypeAlias = getGlobalOmitSymbol();
      if (!omitTypeAlias) return errorType;
      return getTypeAliasInstantiation(omitTypeAlias, [source, omitKeyType]);
    }
    const members = new SymbolTable();
    for (const prop of getPropertiesOfType(source)) {
      if (
        !isTypeAssignableTo(getLiteralTypeFromProperty(prop, TypeFlags.StringOrNumberLiteralOrUnique), omitKeyType) &&
        !(getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlags.Private | ModifierFlags.Protected)) &&
        isSpreadableProperty(prop)
      ) {
        members.set(prop.escName, getSpreadSymbol(prop, false));
      }
    }
    const stringIndexInfo = getIndexInfoOfType(source, IndexKind.String);
    const numberIndexInfo = getIndexInfoOfType(source, IndexKind.Number);
    const result = createAnonymousType(symbol, members, empty, empty, stringIndexInfo, numberIndexInfo);
    result.objectFlags |= ObjectFlags.ObjectRestType;
    return result;
  }
  function getFlowTypeOfDestructuring(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression, declaredType: Type) {
    const reference = getSyntheticElementAccess(node);
    return reference ? getFlowTypeOfReference(reference, declaredType) : declaredType;
  }
  function getSyntheticElementAccess(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression): ElementAccessExpression | undefined {
    const parentAccess = getParentElementAccess(node);
    if (parentAccess && parentAccess.flowNode) {
      const propName = getDestructuringPropertyName(node);
      if (propName) {
        const result = <ElementAccessExpression>createNode(Syntax.ElementAccessExpression, node.pos, node.end);
        result.parent = node;
        result.expression = <LeftHandSideExpression>parentAccess;
        const literal = <StringLiteral>createNode(Syntax.StringLiteral, node.pos, node.end);
        literal.parent = result;
        literal.text = propName;
        result.argumentExpression = literal;
        result.flowNode = parentAccess.flowNode;
        return result;
      }
    }
  }
  function getParentElementAccess(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression) {
    const ancestor = node.parent.parent;
    switch (ancestor.kind) {
      case Syntax.BindingElement:
      case Syntax.PropertyAssignment:
        return getSyntheticElementAccess(<BindingElement | PropertyAssignment>ancestor);
      case Syntax.ArrayLiteralExpression:
        return getSyntheticElementAccess(<Expression>node.parent);
      case Syntax.VariableDeclaration:
        return (<VariableDeclaration>ancestor).initializer;
      case Syntax.BinaryExpression:
        return (<BinaryExpression>ancestor).right;
    }
  }
  function getDestructuringPropertyName(node: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression) {
    const parent = node.parent;
    if (node.kind === Syntax.BindingElement && parent.kind === Syntax.ObjectBindingPattern)
      return getLiteralPropertyNameText((<BindingElement>node).propertyName || <Identifier>(<BindingElement>node).name);
    if (node.kind === Syntax.PropertyAssignment || node.kind === Syntax.ShorthandPropertyAssignment) return getLiteralPropertyNameText((<PropertyAssignment | ShorthandPropertyAssignment>node).name);
    return '' + (<Nodes<Node>>(<BindingPattern | ArrayLiteralExpression>parent).elements).indexOf(node);
  }
  function getLiteralPropertyNameText(name: PropertyName) {
    const type = getLiteralTypeFromPropertyName(name);
    return type.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) ? '' + (<StringLiteralType | NumberLiteralType>type).value : undefined;
  }
  function getTypeForBindingElement(declaration: BindingElement): Type | undefined {
    const pattern = declaration.parent;
    let parentType = getTypeForBindingElementParent(pattern.parent);
    if (!parentType || isTypeAny(parentType)) return parentType;
    if (strictNullChecks && declaration.flags & NodeFlags.Ambient && isParameterDeclaration(declaration)) parentType = getNonNullableType(parentType);
    else if (strictNullChecks && pattern.parent.initializer && !(getTypeFacts(getTypeOfInitializer(pattern.parent.initializer)) & TypeFacts.EQUndefined)) {
      parentType = getTypeWithFacts(parentType, TypeFacts.NEUndefined);
    }
    let type: Type | undefined;
    if (pattern.kind === Syntax.ObjectBindingPattern) {
      if (declaration.dot3Token) {
        parentType = getReducedType(parentType);
        if (parentType.flags & TypeFlags.Unknown || !isValidSpreadType(parentType)) {
          error(declaration, qd.Rest_types_may_only_be_created_from_object_types);
          return errorType;
        }
        const literalMembers: PropertyName[] = [];
        for (const element of pattern.elements) {
          if (!element.dot3Token) literalMembers.push(element.propertyName || (element.name as Identifier));
        }
        type = getRestType(parentType, literalMembers, declaration.symbol);
      } else {
        const name = declaration.propertyName || <Identifier>declaration.name;
        const indexType = getLiteralTypeFromPropertyName(name);
        const declaredType = getConstraintForLocation(getIndexedAccessType(parentType, indexType, name), declaration.name);
        type = getFlowTypeOfDestructuring(declaration, declaredType);
      }
    } else {
      const elementType = checkIteratedTypeOrElementType(IterationUse.Destructuring, parentType, undefinedType, pattern);
      const index = pattern.elements.indexOf(declaration);
      if (declaration.dot3Token) type = everyType(parentType, isTupleType) ? mapType(parentType, (t) => sliceTupleType(<TupleTypeReference>t, index)) : createArrayType(elementType);
      else if (isArrayLikeType(parentType)) {
        const indexType = getLiteralType(index);
        const accessFlags = hasDefaultValue(declaration) ? AccessFlags.NoTupleBoundsCheck : 0;
        const declaredType = getConstraintForLocation(getIndexedAccessTypeOrUndefined(parentType, indexType, declaration.name, accessFlags) || errorType, declaration.name);
        type = getFlowTypeOfDestructuring(declaration, declaredType);
      } else {
        type = elementType;
      }
    }
    if (!declaration.initializer) return type;
    if (getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration)))
      return strictNullChecks && !(getFalsyFlags(checkDeclarationInitializer(declaration)) & TypeFlags.Undefined) ? getTypeWithFacts(type, TypeFacts.NEUndefined) : type;
    return widenTypeInferredFromInitializer(declaration, getUnionType([getTypeWithFacts(type, TypeFacts.NEUndefined), checkDeclarationInitializer(declaration)], UnionReduction.Subtype));
  }
  function getTypeForDeclarationFromJSDocComment(declaration: Node) {
    const jsdocType = qc.getDoc.type(declaration);
    if (jsdocType) return getTypeFromTypeNode(jsdocType);
    return;
  }
  function isNullOrUndefined(node: Expression) {
    const expr = skipParentheses(node);
    return expr.kind === Syntax.NullKeyword || (expr.kind === Syntax.Identifier && getResolvedSymbol(<Identifier>expr) === undefinedSymbol);
  }
  function isEmptyArrayLiteral(node: Expression) {
    const expr = skipParentheses(node);
    return expr.kind === Syntax.ArrayLiteralExpression && (<ArrayLiteralExpression>expr).elements.length === 0;
  }
  function addOptionality(type: Type, optional = true): Type {
    return strictNullChecks && optional ? getOptionalType(type) : type;
  }
  function getTypeForVariableLikeDeclaration(
    declaration: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement,
    includeOptionality: boolean
  ): Type | undefined {
    if (qc.is.kind(VariableDeclaration, declaration) && declaration.parent.parent.kind === Syntax.ForInStatement) {
      const indexType = getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression)));
      return indexType.flags & (TypeFlags.TypeParameter | TypeFlags.Index) ? getExtractStringType(indexType) : stringType;
    }
    if (qc.is.kind(VariableDeclaration, declaration) && declaration.parent.parent.kind === Syntax.ForOfStatement) {
      const forOfStatement = declaration.parent.parent;
      return checkRightHandSideOfForOf(forOfStatement) || anyType;
    }
    if (qc.is.kind(BindingPattern, declaration.parent)) return getTypeForBindingElement(<BindingElement>declaration);
    const isOptional =
      includeOptionality &&
      ((qc.is.kind(ParameterDeclaration, declaration) && isJSDocOptionalParameter(declaration)) ||
        (!qc.is.kind(BindingElement, declaration) && !qc.is.kind(VariableDeclaration, declaration) && !!declaration.questionToken));
    const declaredType = tryGetTypeFromEffectiveTypeNode(declaration);
    if (declaredType) return addOptionality(declaredType, isOptional);
    if (
      (noImplicitAny || isInJSFile(declaration)) &&
      declaration.kind === Syntax.VariableDeclaration &&
      !qc.is.kind(BindingPattern, declaration.name) &&
      !(getCombinedModifierFlags(declaration) & ModifierFlags.Export) &&
      !(declaration.flags & NodeFlags.Ambient)
    ) {
      if (!(qc.get.combinedFlagsOf(declaration) & NodeFlags.Const) && (!declaration.initializer || isNullOrUndefined(declaration.initializer))) return autoType;
      if (declaration.initializer && isEmptyArrayLiteral(declaration.initializer)) return autoArrayType;
    }
    if (declaration.kind === Syntax.Parameter) {
      const func = <FunctionLikeDeclaration>declaration.parent;
      if (func.kind === Syntax.SetAccessor && !hasNonBindableDynamicName(func)) {
        const getter = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfNode(declaration.parent), Syntax.GetAccessor);
        if (getter) {
          const getterSignature = getSignatureFromDeclaration(getter);
          const thisParameter = getAccessorThisNodeKind(ParameterDeclaration, func as AccessorDeclaration);
          if (thisParameter && declaration === thisParameter) {
            assert(!thisParameter.type);
            return getTypeOfSymbol(getterSignature.thisParameter!);
          }
          return getReturnTypeOfSignature(getterSignature);
        }
      }
      if (isInJSFile(declaration)) {
        const typeTag = qc.getDoc.type(func);
        if (typeTag && qc.is.kind(FunctionTypeNode, typeTag)) return getTypeAtPosition(getSignatureFromDeclaration(typeTag), func.parameters.indexOf(declaration));
      }
      const type = declaration.symbol.escName === InternalSymbolName.This ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration);
      if (type) return addOptionality(type, isOptional);
    } else if (isInJSFile(declaration)) {
      const containerObjectType = getJSContainerObjectType(declaration, getSymbolOfNode(declaration), getDeclaredExpandoInitializer(declaration));
      if (containerObjectType) return containerObjectType;
    }
    if (declaration.initializer) {
      const type = widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration));
      return addOptionality(type, isOptional);
    }
    if (qc.is.kind(PropertyDeclaration, declaration) && (noImplicitAny || isInJSFile(declaration))) {
      const constructor = findConstructorDeclaration(declaration.parent);
      const type = constructor
        ? getFlowTypeInConstructor(declaration.symbol, constructor)
        : getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient
        ? getTypeOfPropertyInBaseClass(declaration.symbol)
        : undefined;
      return type && addOptionality(type, isOptional);
    }
    if (qc.is.kind(JsxAttribute, declaration)) return trueType;
    if (qc.is.kind(BindingPattern, declaration.name)) return getTypeFromBindingPattern(declaration.name, false, true);
    return;
  }
  function getFlowTypeInConstructor(symbol: Symbol, constructor: ConstructorDeclaration) {
    const reference = new qc.PropertyAccessExpression(new qc.ThisExpression(), syntax.get.unescUnderscores(symbol.escName));
    reference.expression.parent = reference;
    reference.parent = constructor;
    reference.flowNode = constructor.returnFlowNode;
    const flowType = getFlowTypeOfProperty(reference, symbol);
    if (noImplicitAny && (flowType === autoType || flowType === autoArrayType)) error(symbol.valueDeclaration, qd.Member_0_implicitly_has_an_1_type, symbol.symbolToString(), typeToString(flowType));
    return everyType(flowType, isNullableType) ? undefined : convertAutoToAny(flowType);
  }
  function getFlowTypeOfProperty(reference: Node, prop: Symbol | undefined) {
    const initialType = (prop && (!isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration) & ModifierFlags.Ambient) && getTypeOfPropertyInBaseClass(prop)) || undefinedType;
    return getFlowTypeOfReference(reference, autoType, initialType);
  }
  function getWidenedTypeForAssignmentDeclaration(symbol: Symbol, resolvedSymbol?: Symbol) {
    const container = getAssignedExpandoInitializer(symbol.valueDeclaration);
    if (container) {
      const tag = qc.getDoc.typeTag(container);
      if (tag && tag.typeExpression) return getTypeFromTypeNode(tag.typeExpression);
      const containerObjectType = getJSContainerObjectType(symbol.valueDeclaration, symbol, container);
      return containerObjectType || getWidenedLiteralType(checkExpressionCached(container));
    }
    let type;
    let definedInConstructor = false;
    let definedInMethod = false;
    if (isConstructorDeclaredProperty(symbol)) type = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol)!);
    if (!type) {
      let jsdocType: Type | undefined;
      let types: Type[] | undefined;
      for (const declaration of symbol.declarations) {
        const expression =
          qc.is.kind(BinaryExpression, declaration) || qc.is.kind(CallExpression, declaration)
            ? declaration
            : isAccessExpression(declaration)
            ? qc.is.kind(BinaryExpression, declaration.parent)
              ? declaration.parent
              : declaration
            : undefined;
        if (!expression) continue;
        const kind = isAccessExpression(expression) ? getAssignmentDeclarationPropertyAccessKind(expression) : getAssignmentDeclarationKind(expression);
        if (kind === AssignmentDeclarationKind.ThisProperty) {
          if (isDeclarationInConstructor(expression)) definedInConstructor = true;
          else {
            definedInMethod = true;
          }
        }
        if (!qc.is.kind(CallExpression, expression)) jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration);
        if (!jsdocType) {
          (types || (types = [])).push(
            qc.is.kind(BinaryExpression, expression) || qc.is.kind(CallExpression, expression) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType
          );
        }
      }
      type = jsdocType;
      if (!type) {
        if (!length(types)) return errorType;
        let constructorTypes = definedInConstructor ? getConstructorDefinedThisAssignmentTypes(types!, symbol.declarations) : undefined;
        if (definedInMethod) {
          const propType = getTypeOfPropertyInBaseClass(symbol);
          if (propType) {
            (constructorTypes || (constructorTypes = [])).push(propType);
            definedInConstructor = true;
          }
        }
        const sourceTypes = some(constructorTypes, (t) => !!(t.flags & ~TypeFlags.Nullable)) ? constructorTypes : types;
        type = getUnionType(sourceTypes!, UnionReduction.Subtype);
      }
    }
    const widened = getWidenedType(addOptionality(type, definedInMethod && !definedInConstructor));
    if (filterType(widened, (t) => !!(t.flags & ~TypeFlags.Nullable)) === neverType) {
      reportImplicitAny(symbol.valueDeclaration, anyType);
      return anyType;
    }
    return widened;
  }
  function getJSContainerObjectType(decl: Node, symbol: Symbol, init: Expression | undefined): Type | undefined {
    if (!isInJSFile(decl) || !init || !qc.is.kind(ObjectLiteralExpression, init) || init.properties.length) return;
    const exports = new SymbolTable();
    while (qc.is.kind(BinaryExpression, decl) || qc.is.kind(PropertyAccessExpression, decl)) {
      const s = getSymbolOfNode(decl);
      if (s && hasEntries(s.exports)) exports.merge(s.exports);
      decl = qc.is.kind(BinaryExpression, decl) ? decl.parent : decl.parent.parent;
    }
    const s = getSymbolOfNode(decl);
    if (s && hasEntries(s.exports)) exports.merge(s.exports);
    const type = createAnonymousType(symbol, exports, empty, empty, undefined, undefined);
    type.objectFlags |= ObjectFlags.JSLiteral;
    return type;
  }
  function getAnnotatedTypeForAssignmentDeclaration(declaredType: Type | undefined, expression: Expression, symbol: Symbol, declaration: Declaration) {
    const typeNode = getEffectiveTypeAnnotationNode(expression.parent);
    if (typeNode) {
      const type = getWidenedType(getTypeFromTypeNode(typeNode));
      if (!declaredType) return type;
      else if (declaredType !== errorType && type !== errorType && !isTypeIdenticalTo(declaredType, type)) {
        errorNextVariableOrPropertyDeclarationMustHaveSameType(undefined, declaredType, declaration, type);
      }
    }
    if (symbol.parent) {
      const typeNode = getEffectiveTypeAnnotationNode(symbol.parent.valueDeclaration);
      if (typeNode) return getTypeOfPropertyOfType(getTypeFromTypeNode(typeNode), symbol.escName);
    }
    return declaredType;
  }
  function getInitializerTypeFromAssignmentDeclaration(symbol: Symbol, resolvedSymbol: Symbol | undefined, expression: BinaryExpression | CallExpression, kind: AssignmentDeclarationKind) {
    if (qc.is.kind(CallExpression, expression)) {
      if (resolvedSymbol) return getTypeOfSymbol(resolvedSymbol);
      const objectLitType = checkExpressionCached((expression as BindableObjectDefinePropertyCall).arguments[2]);
      const valueType = getTypeOfPropertyOfType(objectLitType, 'value' as __String);
      if (valueType) return valueType;
      const getFunc = getTypeOfPropertyOfType(objectLitType, 'get' as __String);
      if (getFunc) {
        const getSig = getSingleCallSignature(getFunc);
        if (getSig) return getReturnTypeOfSignature(getSig);
      }
      const setFunc = getTypeOfPropertyOfType(objectLitType, 'set' as __String);
      if (setFunc) {
        const setSig = getSingleCallSignature(setFunc);
        if (setSig) return getTypeOfFirstParameterOfSignature(setSig);
      }
      return anyType;
    }
    if (containsSameNamedThisProperty(expression.left, expression.right)) return anyType;
    const type = resolvedSymbol ? getTypeOfSymbol(resolvedSymbol) : getWidenedLiteralType(checkExpressionCached(expression.right));
    if (type.flags & TypeFlags.Object && kind === AssignmentDeclarationKind.ModuleExports && symbol.escName === InternalSymbolName.ExportEquals) {
      const exportedType = resolveStructuredTypeMembers(type as ObjectType);
      const members = new SymbolTable();
      copyEntries(exportedType.members, members);
      if (resolvedSymbol && !resolvedSymbol.exports) resolvedSymbol.exports = new SymbolTable();
      (resolvedSymbol || symbol).exports!.forEach((s, name) => {
        const exportedMember = members.get(name)!;
        if (exportedMember && exportedMember !== s) {
          if (s.flags & SymbolFlags.Value) {
            if (qc.get.sourceFileOf(s.valueDeclaration) !== qc.get.sourceFileOf(exportedMember.valueDeclaration)) {
              const unescName = syntax.get.unescUnderscores(s.escName);
              const exportedMemberName = tryCast(exportedMember.valueDeclaration, isNamedDeclaration)?.name || exportedMember.valueDeclaration;
              addRelatedInfo(error(s.valueDeclaration, qd.Duplicate_identifier_0, unescName), createDiagnosticForNode(exportedMemberName, qd._0_was_also_declared_here, unescName));
              addRelatedInfo(error(exportedMemberName, qd.Duplicate_identifier_0, unescName), createDiagnosticForNode(s.valueDeclaration, qd._0_was_also_declared_here, unescName));
            }
            const union = new QSymbol(s.flags | exportedMember.flags, name);
            union.type = getUnionType([getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)]);
            union.valueDeclaration = exportedMember.valueDeclaration;
            union.declarations = concatenate(exportedMember.declarations, s.declarations);
            members.set(name, union);
          } else {
            members.set(name, exportedMember.merge(s));
          }
        } else {
          members.set(name, s);
        }
      });
      const result = createAnonymousType(exportedType.symbol, members, exportedType.callSignatures, exportedType.constructSignatures, exportedType.stringIndexInfo, exportedType.numberIndexInfo);
      result.objectFlags |= getObjectFlags(type) & ObjectFlags.JSLiteral;
      return result;
    }
    if (isEmptyArrayLiteralType(type)) {
      reportImplicitAny(expression, anyArrayType);
      return anyArrayType;
    }
    return type;
  }
  function containsSameNamedThisProperty(thisProperty: Expression, expression: Expression) {
    return (
      qc.is.kind(PropertyAccessExpression, thisProperty) && thisProperty.expression.kind === Syntax.ThisKeyword && qc.forEach.childRecursively(expression, (n) => isMatchingReference(thisProperty, n))
    );
  }
  function isDeclarationInConstructor(expression: Expression) {
    const thisContainer = qc.get.thisContainer(expression, false);
    return (
      thisContainer.kind === Syntax.Constructor ||
      thisContainer.kind === Syntax.FunctionDeclaration ||
      (thisContainer.kind === Syntax.FunctionExpression && !isPrototypePropertyAssignment(thisContainer.parent))
    );
  }
  function getConstructorDefinedThisAssignmentTypes(types: Type[], declarations: Declaration[]): Type[] | undefined {
    assert(types.length === declarations.length);
    return types.filter((_, i) => {
      const declaration = declarations[i];
      const expression = qc.is.kind(BinaryExpression, declaration) ? declaration : qc.is.kind(BinaryExpression, declaration.parent) ? declaration.parent : undefined;
      return expression && isDeclarationInConstructor(expression);
    });
  }
  function getTypeFromBindingElement(element: BindingElement, includePatternInType?: boolean, reportErrors?: boolean): Type {
    if (element.initializer) {
      const contextualType = qc.is.kind(BindingPattern, element.name) ? getTypeFromBindingPattern(element.name, true, false) : unknownType;
      return addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element, contextualType)));
    }
    if (qc.is.kind(BindingPattern, element.name)) return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors);
    if (reportErrors && !declarationBelongsToPrivateAmbientMember(element)) reportImplicitAny(element, anyType);
    return includePatternInType ? nonInferrableAnyType : anyType;
  }
  function getTypeFromObjectBindingPattern(pattern: ObjectBindingPattern, includePatternInType: boolean, reportErrors: boolean): Type {
    const members = new SymbolTable();
    let stringIndexInfo: IndexInfo | undefined;
    let objectFlags = ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
    forEach(pattern.elements, (e) => {
      const name = e.propertyName || <Identifier>e.name;
      if (e.dot3Token) {
        stringIndexInfo = createIndexInfo(anyType, false);
        return;
      }
      const exprType = getLiteralTypeFromPropertyName(name);
      if (!isTypeUsableAsPropertyName(exprType)) {
        objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties;
        return;
      }
      const text = getPropertyNameFromType(exprType);
      const flags = SymbolFlags.Property | (e.initializer ? SymbolFlags.Optional : 0);
      const symbol = new QSymbol(flags, text);
      symbol.type = getTypeFromBindingElement(e, includePatternInType, reportErrors);
      symbol.bindingElement = e;
      members.set(symbol.escName, symbol);
    });
    const result = createAnonymousType(undefined, members, empty, empty, stringIndexInfo, undefined);
    result.objectFlags |= objectFlags;
    if (includePatternInType) {
      result.pattern = pattern;
      result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral;
    }
    return result;
  }
  function getTypeFromArrayBindingPattern(pattern: BindingPattern, includePatternInType: boolean, reportErrors: boolean): Type {
    const elements = pattern.elements;
    const lastElement = lastOrUndefined(elements);
    const hasRestElement = !!(lastElement && lastElement.kind === Syntax.BindingElement && lastElement.dot3Token);
    if (elements.length === 0 || (elements.length === 1 && hasRestElement)) return createIterableType(anyType);
    const elementTypes = map(elements, (e) => (qc.is.kind(OmittedExpression, e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors)));
    const minLength = findLastIndex(elements, (e) => !qc.is.kind(OmittedExpression, e) && !hasDefaultValue(e), elements.length - (hasRestElement ? 2 : 1)) + 1;
    let result = <TypeReference>createTupleType(elementTypes, minLength, hasRestElement);
    if (includePatternInType) {
      result = cloneTypeReference(result);
      result.pattern = pattern;
      result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral;
    }
    return result;
  }
  function getTypeFromBindingPattern(pattern: BindingPattern, includePatternInType = false, reportErrors = false): Type {
    return pattern.kind === Syntax.ObjectBindingPattern
      ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)
      : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors);
  }
  function getWidenedTypeForVariableLikeDeclaration(declaration: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement, reportErrors?: boolean): Type {
    return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration, true), declaration, reportErrors);
  }
  function widenTypeForVariableLikeDeclaration(type: Type | undefined, declaration: any, reportErrors?: boolean) {
    if (type) {
      if (reportErrors) reportErrorsFromWidening(declaration, type);
      if (type.flags & TypeFlags.UniqueESSymbol && (qc.is.kind(BindingElement, declaration) || !declaration.type) && type.symbol !== getSymbolOfNode(declaration)) type = esSymbolType;
      return getWidenedType(type);
    }
    type = qc.is.kind(ParameterDeclaration, declaration) && declaration.dot3Token ? anyArrayType : anyType;
    if (reportErrors) {
      if (!declarationBelongsToPrivateAmbientMember(declaration)) reportImplicitAny(declaration, type);
    }
    return type;
  }
  function declarationBelongsToPrivateAmbientMember(declaration: VariableLikeDeclaration) {
    const root = getRootDeclaration(declaration);
    const memberDeclaration = root.kind === Syntax.Parameter ? root.parent : root;
    return isPrivateWithinAmbient(memberDeclaration);
  }
  function tryGetTypeFromEffectiveTypeNode(declaration: Declaration) {
    const typeNode = getEffectiveTypeAnnotationNode(declaration);
    if (typeNode) return getTypeFromTypeNode(typeNode);
  }
  function getAnnotatedAccessorTypeNode(accessor: AccessorDeclaration | undefined): TypeNode | undefined {
    if (accessor) {
      if (accessor.kind === Syntax.GetAccessor) {
        const getterTypeAnnotation = getEffectiveReturnTypeNode(accessor);
        return getterTypeAnnotation;
      } else {
        const setterTypeAnnotation = getEffectiveSetAccessorTypeAnnotationNode(accessor);
        return setterTypeAnnotation;
      }
    }
    return;
  }
  function getAnnotatedAccessorType(accessor: AccessorDeclaration | undefined): Type | undefined {
    const node = getAnnotatedAccessorTypeNode(accessor);
    return node && getTypeFromTypeNode(node);
  }
  function getAnnotatedAccessorThisNodeKind(ParameterDeclaration, accessor: AccessorDeclaration): Symbol | undefined {
    const parameter = getAccessorThisNodeKind(ParameterDeclaration, accessor);
    return parameter && parameter.symbol;
  }
  function getThisTypeOfDeclaration(declaration: SignatureDeclaration): Type | undefined {
    return getThisTypeOfSignature(getSignatureFromDeclaration(declaration));
  }
  function isReferenceToType(type: Type, target: Type) {
    return type !== undefined && target !== undefined && (getObjectFlags(type) & ObjectFlags.Reference) !== 0 && (<TypeReference>type).target === target;
  }
  function getTargetType(type: Type): Type {
    return getObjectFlags(type) & ObjectFlags.Reference ? (<TypeReference>type).target : type;
  }
  function hasBaseType(type: Type, checkBase: Type | undefined) {
    return check(type);
    function check(type: Type): boolean {
      if (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference)) {
        const target = <InterfaceType>getTargetType(type);
        return target === checkBase || some(getBaseTypes(target), check);
      } else if (type.flags & TypeFlags.Intersection) {
        return some((<IntersectionType>type).types, check);
      }
      return false;
    }
  }
  function appendTypeParameters(typeParameters: TypeParameter[] | undefined, declarations: readonly TypeParameterDeclaration[]): TypeParameter[] | undefined {
    for (const declaration of declarations) {
      typeParameters = appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfNode(declaration)));
    }
    return typeParameters;
  }
  function getOuterTypeParameters(node: Node, includeThisTypes?: boolean): TypeParameter[] | undefined {
    while (true) {
      node = node.parent;
      if (node && qc.is.kind(node, BinaryExpression)) {
        const assignmentKind = getAssignmentDeclarationKind(node);
        if (assignmentKind === AssignmentDeclarationKind.Prototype || assignmentKind === AssignmentDeclarationKind.PrototypeProperty) {
          const symbol = getSymbolOfNode(node.left);
          if (symbol && symbol.parent && !Node.findAncestor(symbol.parent.valueDeclaration, (d) => node === d)) node = symbol.parent.valueDeclaration;
        }
      }
      if (!node) return;
      switch (node.kind) {
        case Syntax.VariableStatement:
        case Syntax.ClassDeclaration:
        case Syntax.ClassExpression:
        case Syntax.InterfaceDeclaration:
        case Syntax.CallSignature:
        case Syntax.ConstructSignature:
        case Syntax.MethodSignature:
        case Syntax.FunctionType:
        case Syntax.ConstructorType:
        case Syntax.JSDocFunctionType:
        case Syntax.FunctionDeclaration:
        case Syntax.MethodDeclaration:
        case Syntax.FunctionExpression:
        case Syntax.ArrowFunction:
        case Syntax.TypeAliasDeclaration:
        case Syntax.JSDocTemplateTag:
        case Syntax.JSDocTypedefTag:
        case Syntax.JSDocEnumTag:
        case Syntax.JSDocCallbackTag:
        case Syntax.MappedType:
        case Syntax.ConditionalType:
          const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
          if (node.kind === Syntax.MappedType) return append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfNode((<MappedTypeNode>node).typeParameter)));
          else if (node.kind === Syntax.ConditionalType) return concatenate(outerTypeParameters, getInferTypeParameters(<ConditionalTypeNode>node));
          else if (node.kind === Syntax.VariableStatement && !isInJSFile(node)) {
            break;
          }
          const outerAndOwnTypeParameters = appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(<DeclarationWithTypeParameters>node));
          const thisType =
            includeThisTypes &&
            (node.kind === Syntax.ClassDeclaration || node.kind === Syntax.ClassExpression || node.kind === Syntax.InterfaceDeclaration || isJSConstructor(node)) &&
            getDeclaredTypeOfClassOrInterface(getSymbolOfNode(node as ClassLikeDeclaration | InterfaceDeclaration)).thisType;
          return thisType ? append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;
      }
    }
  }
  function isMixinConstructorType(type: Type) {
    const signatures = getSignaturesOfType(type, SignatureKind.Construct);
    if (signatures.length === 1) {
      const s = signatures[0];
      return !s.typeParameters && s.parameters.length === 1 && signatureHasRestParameter(s) && getElementTypeOfArrayType(getTypeOfParameter(s.parameters[0])) === anyType;
    }
    return false;
  }
  function isConstructorType(type: Type): boolean {
    if (getSignaturesOfType(type, SignatureKind.Construct).length > 0) return true;
    if (type.flags & TypeFlags.TypeVariable) {
      const constraint = getBaseConstraintOfType(type);
      return !!constraint && isMixinConstructorType(constraint);
    }
    return false;
  }
  function getBaseTypeNodeOfClass(type: InterfaceType): ExpressionWithTypeArguments | undefined {
    return getEffectiveBaseTypeNode(type.symbol.valueDeclaration as ClassLikeDeclaration);
  }
  function getConstructorsForTypeArguments(type: Type, typeArgumentNodes: readonly TypeNode[] | undefined, location: Node): readonly Signature[] {
    const typeArgCount = length(typeArgumentNodes);
    const isJavascript = isInJSFile(location);
    return filter(
      getSignaturesOfType(type, SignatureKind.Construct),
      (sig) => (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= length(sig.typeParameters)
    );
  }
  function getInstantiatedConstructorsForTypeArguments(type: Type, typeArgumentNodes: readonly TypeNode[] | undefined, location: Node): readonly Signature[] {
    const signatures = getConstructorsForTypeArguments(type, typeArgumentNodes, location);
    const typeArguments = map(typeArgumentNodes, getTypeFromTypeNode);
    return sameMap<Signature>(signatures, (sig) => (some(sig.typeParameters) ? getSignatureInstantiation(sig, typeArguments, isInJSFile(location)) : sig));
  }
  function getBaseConstructorTypeOfClass(type: InterfaceType): Type {
    if (!type.resolvedBaseConstructorType) {
      const decl = <ClassLikeDeclaration>type.symbol.valueDeclaration;
      const extended = getEffectiveBaseTypeNode(decl);
      const baseTypeNode = getBaseTypeNodeOfClass(type);
      if (!baseTypeNode) return (type.resolvedBaseConstructorType = undefinedType);
      if (!pushTypeResolution(type, TypeSystemPropertyName.ResolvedBaseConstructorType)) return errorType;
      const baseConstructorType = checkExpression(baseTypeNode.expression);
      if (extended && baseTypeNode !== extended) {
        assert(!extended.typeArguments);
        checkExpression(extended.expression);
      }
      if (baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection)) resolveStructuredTypeMembers(<ObjectType>baseConstructorType);
      if (!popTypeResolution()) {
        error(type.symbol.valueDeclaration, qd._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, type.symbol.symbolToString());
        return (type.resolvedBaseConstructorType = errorType);
      }
      if (!(baseConstructorType.flags & TypeFlags.Any) && baseConstructorType !== nullWideningType && !isConstructorType(baseConstructorType)) {
        const err = error(baseTypeNode.expression, qd.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));
        if (baseConstructorType.flags & TypeFlags.TypeParameter) {
          const constraint = getConstraintFromTypeParameter(baseConstructorType);
          let ctorReturn: Type = unknownType;
          if (constraint) {
            const ctorSig = getSignaturesOfType(constraint, SignatureKind.Construct);
            if (ctorSig[0]) ctorReturn = getReturnTypeOfSignature(ctorSig[0]);
          }
          addRelatedInfo(
            err,
            createDiagnosticForNode(
              baseConstructorType.symbol.declarations[0],
              qd.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1,
              baseConstructorType.symbol.symbolToString(),
              typeToString(ctorReturn)
            )
          );
        }
        return (type.resolvedBaseConstructorType = errorType);
      }
      type.resolvedBaseConstructorType = baseConstructorType;
    }
    return type.resolvedBaseConstructorType;
  }
  function getImplementsTypes(type: InterfaceType): BaseType[] {
    let resolvedImplementsTypes: BaseType[] = empty;
    for (const declaration of type.symbol.declarations) {
      const implementsTypeNodes = getEffectiveImplementsTypeNodes(declaration as ClassLikeDeclaration);
      if (!implementsTypeNodes) continue;
      for (const node of implementsTypeNodes) {
        const implementsType = getTypeFromTypeNode(node);
        if (implementsType !== errorType) {
          if (resolvedImplementsTypes === empty) resolvedImplementsTypes = [<ObjectType>implementsType];
          else {
            resolvedImplementsTypes.push(implementsType);
          }
        }
      }
    }
    return resolvedImplementsTypes;
  }
  function getBaseTypes(type: InterfaceType): BaseType[] {
    if (!type.resolvedBaseTypes) {
      if (type.objectFlags & ObjectFlags.Tuple) type.resolvedBaseTypes = [createArrayType(getUnionType(type.typeParameters || empty), (<TupleType>type).readonly)];
      else if (type.symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)) {
        if (type.symbol.flags & SymbolFlags.Class) resolveBaseTypesOfClass(type);
        if (type.symbol.flags & SymbolFlags.Interface) resolveBaseTypesOfInterface(type);
      } else {
        fail('type must be class or interface');
      }
    }
    return type.resolvedBaseTypes;
  }
  function resolveBaseTypesOfClass(type: InterfaceType) {
    type.resolvedBaseTypes = resolvingEmptyArray;
    const baseConstructorType = getApparentType(getBaseConstructorTypeOfClass(type));
    if (!(baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Any))) return (type.resolvedBaseTypes = empty);
    const baseTypeNode = getBaseTypeNodeOfClass(type)!;
    let baseType: Type;
    const originalBaseType = baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : undefined;
    if (baseConstructorType.symbol && baseConstructorType.symbol.flags & SymbolFlags.Class && areAllOuterTypeParametersApplied(originalBaseType!))
      baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol);
    else if (baseConstructorType.flags & TypeFlags.Any) {
      baseType = baseConstructorType;
    } else {
      const constructors = getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode);
      if (!constructors.length) {
        error(baseTypeNode.expression, qd.No_base_constructor_has_the_specified_number_of_type_arguments);
        return (type.resolvedBaseTypes = empty);
      }
      baseType = getReturnTypeOfSignature(constructors[0]);
    }
    if (baseType === errorType) return (type.resolvedBaseTypes = empty);
    const reducedBaseType = getReducedType(baseType);
    if (!isValidBaseType(reducedBaseType)) {
      const elaboration = elaborateNeverIntersection(undefined, baseType);
      const diagnostic = chainDiagnosticMessages(
        elaboration,
        qd.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members,
        typeToString(reducedBaseType)
      );
      diagnostics.add(createDiagnosticForNodeFromMessageChain(baseTypeNode.expression, diagnostic));
      return (type.resolvedBaseTypes = empty);
    }
    if (type === reducedBaseType || hasBaseType(reducedBaseType, type)) {
      error(type.symbol.valueDeclaration, qd.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, undefined, TypeFormatFlags.WriteArrayAsGenericType));
      return (type.resolvedBaseTypes = empty);
    }
    if (type.resolvedBaseTypes === resolvingEmptyArray) type.members = undefined;
    return (type.resolvedBaseTypes = [reducedBaseType]);
  }
  function areAllOuterTypeParametersApplied(type: Type): boolean {
    const outerTypeParameters = (<InterfaceType>type).outerTypeParameters;
    if (outerTypeParameters) {
      const last = outerTypeParameters.length - 1;
      const typeArguments = getTypeArguments(<TypeReference>type);
      return outerTypeParameters[last].symbol !== typeArguments[last].symbol;
    }
    return true;
  }
  function isValidBaseType(type: Type): type is BaseType {
    if (type.flags & TypeFlags.TypeParameter) {
      const constraint = getBaseConstraintOfType(type);
      if (constraint) return isValidBaseType(constraint);
    }
    return !!(
      (type.flags & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.Any) && !isGenericMappedType(type)) ||
      (type.flags & TypeFlags.Intersection && every((<IntersectionType>type).types, isValidBaseType))
    );
  }
  function resolveBaseTypesOfInterface(type: InterfaceType): void {
    type.resolvedBaseTypes = type.resolvedBaseTypes || empty;
    for (const declaration of type.symbol.declarations) {
      if (declaration.kind === Syntax.InterfaceDeclaration && getInterfaceBaseTypeNodes(<InterfaceDeclaration>declaration)) {
        for (const node of getInterfaceBaseTypeNodes(<InterfaceDeclaration>declaration)!) {
          const baseType = getReducedType(getTypeFromTypeNode(node));
          if (baseType !== errorType) {
            if (isValidBaseType(baseType)) {
              if (type !== baseType && !hasBaseType(baseType, type)) {
                if (type.resolvedBaseTypes === empty) type.resolvedBaseTypes = [<ObjectType>baseType];
                else {
                  type.resolvedBaseTypes.push(baseType);
                }
              } else {
                error(declaration, qd.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, undefined, TypeFormatFlags.WriteArrayAsGenericType));
              }
            } else {
              error(node, qd.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members);
            }
          }
        }
      }
    }
  }
  function isStringConcatExpression(expr: Node): boolean {
    if (StringLiteral.like(expr)) return true;
    else if (expr.kind === Syntax.BinaryExpression) return isStringConcatExpression((<BinaryExpression>expr).left) && isStringConcatExpression((<BinaryExpression>expr).right);
    return false;
  }
  function isLiteralEnumMember(member: EnumMember) {
    const expr = member.initializer;
    if (!expr) return !(member.flags & NodeFlags.Ambient);
    switch (expr.kind) {
      case Syntax.StringLiteral:
      case Syntax.NumericLiteral:
      case Syntax.NoSubstitutionLiteral:
        return true;
      case Syntax.PrefixUnaryExpression:
        return (<PrefixUnaryExpression>expr).operator === Syntax.MinusToken && (<PrefixUnaryExpression>expr).operand.kind === Syntax.NumericLiteral;
      case Syntax.Identifier:
        return qc.is.missing(expr) || !!getSymbolOfNode(member.parent).exports!.get((<Identifier>expr).escapedText);
      case Syntax.BinaryExpression:
        return isStringConcatExpression(expr);
      default:
        return false;
    }
  }
  function getBaseTypeOfEnumLiteralType(type: Type) {
    return type.flags & TypeFlags.EnumLiteral && !(type.flags & TypeFlags.Union) ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)!) : type;
  }
  function isThislessType(node: TypeNode): boolean {
    switch (node.kind) {
      case Syntax.AnyKeyword:
      case Syntax.UnknownKeyword:
      case Syntax.StringKeyword:
      case Syntax.NumberKeyword:
      case Syntax.BigIntKeyword:
      case Syntax.BooleanKeyword:
      case Syntax.SymbolKeyword:
      case Syntax.ObjectKeyword:
      case Syntax.VoidKeyword:
      case Syntax.UndefinedKeyword:
      case Syntax.NullKeyword:
      case Syntax.NeverKeyword:
      case Syntax.LiteralType:
        return true;
      case Syntax.ArrayType:
        return isThislessType((<ArrayTypeNode>node).elementType);
      case Syntax.TypeReference:
        return !(node as TypeReferenceNode).typeArguments || (node as TypeReferenceNode).typeArguments!.every(isThislessType);
    }
    return false;
  }
  function isThislessTypeParameter(node: TypeParameterDeclaration) {
    const constraint = getEffectiveConstraintOfTypeParameter(node);
    return !constraint || isThislessType(constraint);
  }
  function isThislessVariableLikeDeclaration(node: VariableLikeDeclaration): boolean {
    const typeNode = getEffectiveTypeAnnotationNode(node);
    return typeNode ? isThislessType(typeNode) : !qc.is.withInitializer(node);
  }
  function isThislessFunctionLikeDeclaration(node: FunctionLikeDeclaration): boolean {
    const returnType = getEffectiveReturnTypeNode(node);
    const typeParameters = getEffectiveTypeParameterDeclarations(node);
    return (
      (node.kind === Syntax.Constructor || (!!returnType && isThislessType(returnType))) && node.parameters.every(isThislessVariableLikeDeclaration) && typeParameters.every(isThislessTypeParameter)
    );
  }
  function createInstantiatedSymbolTable(symbols: Symbol[], mapper: TypeMapper, mappingThisOnly: boolean): SymbolTable {
    const result = new SymbolTable();
    for (const symbol of symbols) {
      result.set(symbol.escName, mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper));
    }
    return result;
  }
  function addInheritedMembers(symbols: SymbolTable, baseSymbols: Symbol[]) {
    for (const s of baseSymbols) {
      if (!symbols.has(s.escName) && !isStaticPrivateIdentifierProperty(s)) symbols.set(s.escName, s);
    }
  }
  function isStaticPrivateIdentifierProperty(s: Symbol): boolean {
    return s.valueDeclaration?.isPrivateIdentifierPropertyDeclaration() && hasSyntacticModifier(s.valueDeclaration, ModifierFlags.Static);
  }
  function resolveDeclaredMembers(type: InterfaceType): InterfaceTypeWithDeclaredMembers {
    if (!(<InterfaceTypeWithDeclaredMembers>type).declaredProperties) {
      const symbol = type.symbol;
      const members = getMembersOfSymbol(symbol);
      (<InterfaceTypeWithDeclaredMembers>type).declaredProperties = getNamedMembers(members);
      (<InterfaceTypeWithDeclaredMembers>type).declaredCallSignatures = empty;
      (<InterfaceTypeWithDeclaredMembers>type).declaredConstructSignatures = empty;
      (<InterfaceTypeWithDeclaredMembers>type).declaredCallSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.Call));
      (<InterfaceTypeWithDeclaredMembers>type).declaredConstructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.New));
      (<InterfaceTypeWithDeclaredMembers>type).declaredStringIndexInfo = getIndexInfoOfSymbol(symbol, IndexKind.String);
      (<InterfaceTypeWithDeclaredMembers>type).declaredNumberIndexInfo = getIndexInfoOfSymbol(symbol, IndexKind.Number);
    }
    return <InterfaceTypeWithDeclaredMembers>type;
  }
  function isTypeUsableAsPropertyName(type: Type): type is StringLiteralType | NumberLiteralType | UniqueESSymbolType {
    return !!(type.flags & TypeFlags.StringOrNumberLiteralOrUnique);
  }
  function isLateBindableName(node: DeclarationName): node is LateBoundName {
    if (!qc.is.kind(ComputedPropertyName, node) && !qc.is.kind(ElementAccessExpression, node)) return false;
    const expr = qc.is.kind(ComputedPropertyName, node) ? node.expression : node.argumentExpression;
    return isEntityNameExpression(expr) && isTypeUsableAsPropertyName(qc.is.kind(ComputedPropertyName, node) ? checkComputedPropertyName(node) : checkExpressionCached(expr));
  }
  function isLateBoundName(name: __String): boolean {
    return (name as string).charCodeAt(0) === Codes._ && (name as string).charCodeAt(1) === Codes._ && (name as string).charCodeAt(2) === Codes.at;
  }
  function hasLateBindableName(node: Declaration): node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration {
    const name = getNameOfDeclaration(node);
    return !!name && isLateBindableName(name);
  }
  function hasNonBindableDynamicName(node: Declaration) {
    return hasDynamicName(node) && !hasLateBindableName(node);
  }
  function isNonBindableDynamicName(node: DeclarationName) {
    return isDynamicName(node) && !isLateBindableName(node);
  }
  function getPropertyNameFromType(type: StringLiteralType | NumberLiteralType | UniqueESSymbolType): __String {
    if (type.flags & TypeFlags.UniqueESSymbol) return (<UniqueESSymbolType>type).escName;
    if (type.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral)) return syntax.get.escUnderscores('' + (<StringLiteralType | NumberLiteralType>type).value);
    return fail();
  }
  function addDeclarationToLateBoundSymbol(symbol: Symbol, member: LateBoundDeclaration | BinaryExpression, symbolFlags: SymbolFlags) {
    assert(!!(this.getCheckFlags() & CheckFlags.Late), 'Expected a late-bound symbol.');
    symbol.flags |= symbolFlags;
    s.getLinks(member.symbol).lateSymbol = symbol;
    if (!symbol.declarations) symbol.declarations = [member];
    else {
      symbol.declarations.push(member);
    }
    if (symbolFlags & SymbolFlags.Value) {
      if (!symbol.valueDeclaration || symbol.valueDeclaration.kind !== member.kind) symbol.valueDeclaration = member;
    }
  }
  function lateBindMember(
    parent: Symbol,
    earlySymbols: SymbolTable | undefined,
    lateSymbols: UnderscoreEscapedMap<TransientSymbol>,
    decl: LateBoundDeclaration | LateBoundBinaryExpressionDeclaration
  ) {
    assert(!!decl.symbol, 'The member is expected to have a symbol.');
    const ls = getNodeLinks(decl);
    if (!ls.resolvedSymbol) {
      ls.resolvedSymbol = decl.symbol;
      const declName = qc.is.kind(BinaryExpression, decl) ? decl.left : decl.name;
      const type = qc.is.kind(ElementAccessExpression, declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName);
      if (isTypeUsableAsPropertyName(type)) {
        const memberName = getPropertyNameFromType(type);
        const symbolFlags = decl.symbol.flags;
        let lateSymbol = lateSymbols.get(memberName);
        if (!lateSymbol) lateSymbols.set(memberName, (lateSymbol = new QSymbol(SymbolFlags.None, memberName, CheckFlags.Late)));
        const earlySymbol = earlySymbols && earlySymbols.get(memberName);
        if (lateSymbol.flags & getExcludedSymbolFlags(symbolFlags) || earlySymbol) {
          const declarations = earlySymbol ? concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations;
          const name = (!(type.flags & TypeFlags.UniqueESSymbol) && syntax.get.unescUnderscores(memberName)) || declarationNameToString(declName);
          forEach(declarations, (declaration) => error(getNameOfDeclaration(declaration) || declaration, qd.Property_0_was_also_declared_here, name));
          error(declName || decl, qd.Duplicate_property_0, name);
          lateSymbol = new QSymbol(SymbolFlags.None, memberName, CheckFlags.Late);
        }
        lateSymbol.nameType = type;
        addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags);
        if (lateSymbol.parent) assert(lateSymbol.parent === parent, 'Existing symbol parent should match new one');
        else {
          lateSymbol.parent = parent;
        }
        return (ls.resolvedSymbol = lateSymbol);
      }
    }
    return ls.resolvedSymbol;
  }
  function getResolvedMembersOrExportsOfSymbol(symbol: QSymbol, resolutionKind: MembersOrExportsResolutionKind): UnderscoreEscapedMap<Symbol> {
    const ls = symbol.getLinks();
    if (!ls[resolutionKind]) {
      const isStatic = resolutionKind === MembersOrExportsResolutionKind.resolvedExports;
      const earlySymbols = !isStatic ? symbol.members : symbol.flags & SymbolFlags.Module ? symbol.getExportsOfModuleWorker() : symbol.exports;
      ls[resolutionKind] = earlySymbols || emptySymbols;
      const lateSymbols = new SymbolTable<TransientSymbol>();
      for (const decl of symbol.declarations) {
        const members = getMembersOfDeclaration(decl);
        if (members) {
          for (const member of members) {
            if (isStatic === hasStaticModifier(member) && hasLateBindableName(member)) lateBindMember(symbol, earlySymbols, lateSymbols, member);
          }
        }
      }
      const assignments = symbol.assignmentDeclarationMembers;
      if (assignments) {
        const decls = arrayFrom(assignments.values());
        for (const member of decls) {
          const assignmentKind = getAssignmentDeclarationKind(member as BinaryExpression | CallExpression);
          const isInstanceMember =
            assignmentKind === AssignmentDeclarationKind.PrototypeProperty ||
            assignmentKind === AssignmentDeclarationKind.ThisProperty ||
            assignmentKind === AssignmentDeclarationKind.ObjectDefinePrototypeProperty ||
            assignmentKind === AssignmentDeclarationKind.Prototype;
          if (isStatic === !isInstanceMember && hasLateBindableName(member)) lateBindMember(symbol, earlySymbols, lateSymbols, member);
        }
      }
      ls[resolutionKind] = earlySymbols?.combine(lateSymbols) || emptySymbols;
    }
    return ls[resolutionKind]!;
  }
  function getTypeWithThisArgument(type: Type, thisArgument?: Type, needApparentType?: boolean): Type {
    if (getObjectFlags(type) & ObjectFlags.Reference) {
      const target = (<TypeReference>type).target;
      const typeArguments = getTypeArguments(<TypeReference>type);
      if (length(target.typeParameters) === length(typeArguments)) {
        const ref = createTypeReference(target, concatenate(typeArguments, [thisArgument || target.thisType!]));
        return needApparentType ? getApparentType(ref) : ref;
      }
    } else if (type.flags & TypeFlags.Intersection) {
      return getIntersectionType(map((<IntersectionType>type).types, (t) => getTypeWithThisArgument(t, thisArgument, needApparentType)));
    }
    return needApparentType ? getApparentType(type) : type;
  }
  function resolveObjectTypeMembers(type: ObjectType, source: InterfaceTypeWithDeclaredMembers, typeParameters: readonly TypeParameter[], typeArguments: readonly Type[]) {
    let mapper: TypeMapper | undefined;
    let members: SymbolTable;
    let callSignatures: readonly Signature[];
    let constructSignatures: readonly Signature[] | undefined;
    let stringIndexInfo: IndexInfo | undefined;
    let numberIndexInfo: IndexInfo | undefined;
    if (rangeEquals(typeParameters, typeArguments, 0, typeParameters.length)) {
      members = source.symbol ? getMembersOfSymbol(source.symbol) : new SymbolTable(source.declaredProperties);
      callSignatures = source.declaredCallSignatures;
      constructSignatures = source.declaredConstructSignatures;
      stringIndexInfo = source.declaredStringIndexInfo;
      numberIndexInfo = source.declaredNumberIndexInfo;
    } else {
      mapper = createTypeMapper(typeParameters, typeArguments);
      members = createInstantiatedSymbolTable(source.declaredProperties, mapper, typeParameters.length === 1);
      callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper);
      constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper);
      stringIndexInfo = instantiateIndexInfo(source.declaredStringIndexInfo, mapper);
      numberIndexInfo = instantiateIndexInfo(source.declaredNumberIndexInfo, mapper);
    }
    const baseTypes = getBaseTypes(source);
    if (baseTypes.length) {
      if (source.symbol && members === getMembersOfSymbol(source.symbol)) members = new SymbolTable(source.declaredProperties);
      setStructuredTypeMembers(type, members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
      const thisArgument = lastOrUndefined(typeArguments);
      for (const baseType of baseTypes) {
        const instantiatedBaseType = thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType;
        addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));
        callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Call));
        constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Construct));
        if (!stringIndexInfo) stringIndexInfo = instantiatedBaseType === anyType ? createIndexInfo(anyType, false) : getIndexInfoOfType(instantiatedBaseType, IndexKind.String);
        numberIndexInfo = numberIndexInfo || getIndexInfoOfType(instantiatedBaseType, IndexKind.Number);
      }
    }
    setStructuredTypeMembers(type, members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
  }
  function resolveClassOrInterfaceMembers(type: InterfaceType): void {
    resolveObjectTypeMembers(type, resolveDeclaredMembers(type), empty, empty);
  }
  function resolveTypeReferenceMembers(type: TypeReference): void {
    const source = resolveDeclaredMembers(type.target);
    const typeParameters = concatenate(source.typeParameters!, [source.thisType!]);
    const typeArguments = getTypeArguments(type);
    const paddedTypeArguments = typeArguments.length === typeParameters.length ? typeArguments : concatenate(typeArguments, [type]);
    resolveObjectTypeMembers(type, source, typeParameters, paddedTypeArguments);
  }
  function createSignature(
    declaration: SignatureDeclaration | JSDocSignature | undefined,
    typeParameters: readonly TypeParameter[] | undefined,
    thisParameter: Symbol | undefined,
    parameters: readonly Symbol[],
    resolvedReturnType: Type | undefined,
    resolvedTypePredicate: TypePredicate | undefined,
    minArgumentCount: number,
    flags: SignatureFlags
  ): Signature {
    const sig = new Signature(checker, flags);
    sig.declaration = declaration;
    sig.typeParameters = typeParameters;
    sig.parameters = parameters;
    sig.thisParameter = thisParameter;
    sig.resolvedReturnType = resolvedReturnType;
    sig.resolvedTypePredicate = resolvedTypePredicate;
    sig.minArgumentCount = minArgumentCount;
    sig.target = undefined;
    sig.mapper = undefined;
    sig.unionSignatures = undefined;
    return sig;
  }
  function cloneSignature(sig: Signature): Signature {
    const result = createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, undefined, undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags);
    result.target = sig.target;
    result.mapper = sig.mapper;
    result.unionSignatures = sig.unionSignatures;
    return result;
  }
  function createUnionSignature(signature: Signature, unionSignatures: Signature[]) {
    const result = cloneSignature(signature);
    result.unionSignatures = unionSignatures;
    result.target = undefined;
    result.mapper = undefined;
    return result;
  }
  function getOptionalCallSignature(signature: Signature, callChainFlags: SignatureFlags): Signature {
    if ((signature.flags & SignatureFlags.CallChainFlags) === callChainFlags) return signature;
    if (!signature.optionalCallSignatureCache) signature.optionalCallSignatureCache = {};
    const key = callChainFlags === SignatureFlags.IsInnerCallChain ? 'inner' : 'outer';
    return signature.optionalCallSignatureCache[key] || (signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags));
  }
  function createOptionalCallSignature(signature: Signature, callChainFlags: SignatureFlags) {
    assert(
      callChainFlags === SignatureFlags.IsInnerCallChain || callChainFlags === SignatureFlags.IsOuterCallChain,
      'An optional call signature can either be for an inner call chain or an outer call chain, but not both.'
    );
    const result = cloneSignature(signature);
    result.flags |= callChainFlags;
    return result;
  }
  function getExpandedParameters(sig: Signature, skipUnionExpanding?: boolean): readonly (readonly Symbol[])[] {
    if (signatureHasRestParameter(sig)) {
      const restIndex = sig.parameters.length - 1;
      const restType = getTypeOfSymbol(sig.parameters[restIndex]);
      if (isTupleType(restType)) return [expandSignatureParametersWithTupleMembers(restType, restIndex)];
      else if (!skipUnionExpanding && restType.flags & TypeFlags.Union && every((restType as UnionType).types, isTupleType))
        return map((restType as UnionType).types, (t) => expandSignatureParametersWithTupleMembers(t as TupleTypeReference, restIndex));
    }
    return [sig.parameters];
    function expandSignatureParametersWithTupleMembers(restType: TupleTypeReference, restIndex: number) {
      const elementTypes = getTypeArguments(restType);
      const minLength = restType.target.minLength;
      const tupleRestIndex = restType.target.hasRestElement ? elementTypes.length - 1 : -1;
      const associatedNames = restType.target.labeledElementDeclarations;
      const restParams = map(elementTypes, (t, i) => {
        const tupleLabelName = !!associatedNames && getTupleElementLabel(associatedNames[i]);
        const name = tupleLabelName || getParameterNameAtPosition(sig, restIndex + i);
        const f = i === tupleRestIndex ? CheckFlags.RestParameter : i >= minLength ? CheckFlags.OptionalParameter : 0;
        const symbol = new QSymbol(SymbolFlags.FunctionScopedVariable, name, f);
        symbol.type = i === tupleRestIndex ? createArrayType(t) : t;
        return symbol;
      });
      return concatenate(sig.parameters.slice(0, restIndex), restParams);
    }
  }
  function getDefaultConstructSignatures(classType: InterfaceType): Signature[] {
    const baseConstructorType = getBaseConstructorTypeOfClass(classType);
    const baseSignatures = getSignaturesOfType(baseConstructorType, SignatureKind.Construct);
    if (baseSignatures.length === 0) return [createSignature(undefined, classType.localTypeParameters, undefined, empty, classType, undefined, 0, SignatureFlags.None)];
    const baseTypeNode = getBaseTypeNodeOfClass(classType)!;
    const isJavaScript = isInJSFile(baseTypeNode);
    const typeArguments = typeArgumentsFromTypeReferenceNode(baseTypeNode);
    const typeArgCount = length(typeArguments);
    const result: Signature[] = [];
    for (const baseSig of baseSignatures) {
      const minTypeArgumentCount = getMinTypeArgumentCount(baseSig.typeParameters);
      const typeParamCount = length(baseSig.typeParameters);
      if (isJavaScript || (typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount)) {
        const sig = typeParamCount
          ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript))
          : cloneSignature(baseSig);
        sig.typeParameters = classType.localTypeParameters;
        sig.resolvedReturnType = classType;
        result.push(sig);
      }
    }
    return result;
  }
  function findMatchingSignature(signatureList: readonly Signature[], signature: Signature, partialMatch: boolean, ignoreThisTypes: boolean, ignoreReturnTypes: boolean): Signature | undefined {
    for (const s of signatureList) {
      if (compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes, partialMatch ? compareTypesSubtypeOf : compareTypesIdentical)) return s;
    }
  }
  function findMatchingSignatures(signatureLists: readonly (readonly Signature[])[], signature: Signature, listIndex: number): Signature[] | undefined {
    if (signature.typeParameters) {
      if (listIndex > 0) return;
      for (let i = 1; i < signatureLists.length; i++) {
        if (!findMatchingSignature(signatureLists[i], signature, false)) return;
      }
      return [signature];
    }
    let result: Signature[] | undefined;
    for (let i = 0; i < signatureLists.length; i++) {
      const match = i === listIndex ? signature : findMatchingSignature(signatureLists[i], signature, true);
      if (!match) return;
      result = appendIfUnique(result, match);
    }
    return result;
  }
  function getUnionSignatures(signatureLists: readonly (readonly Signature[])[]): Signature[] {
    let result: Signature[] | undefined;
    let indexWithLengthOverOne: number | undefined;
    for (let i = 0; i < signatureLists.length; i++) {
      if (signatureLists[i].length === 0) return empty;
      if (signatureLists[i].length > 1) indexWithLengthOverOne = indexWithLengthOverOne === undefined ? i : -1;
      for (const signature of signatureLists[i]) {
        if (!result || !findMatchingSignature(result, signature, true)) {
          const unionSignatures = findMatchingSignatures(signatureLists, signature, i);
          if (unionSignatures) {
            let s = signature;
            if (unionSignatures.length > 1) {
              let thisParameter = signature.thisParameter;
              const firstThisParameterOfUnionSignatures = forEach(unionSignatures, (sig) => sig.thisParameter);
              if (firstThisParameterOfUnionSignatures) {
                const thisType = getIntersectionType(mapDefined(unionSignatures, (sig) => sig.thisParameter && getTypeOfSymbol(sig.thisParameter)));
                thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);
              }
              s = createUnionSignature(signature, unionSignatures);
              s.thisParameter = thisParameter;
            }
            (result || (result = [])).push(s);
          }
        }
      }
    }
    if (!length(result) && indexWithLengthOverOne !== -1) {
      const masterList = signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0];
      let results: Signature[] | undefined = masterList.slice();
      for (const signatures of signatureLists) {
        if (signatures !== masterList) {
          const signature = signatures[0];
          assert(!!signature, 'getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass');
          results = signature.typeParameters && some(results, (s) => !!s.typeParameters) ? undefined : map(results, (sig) => combineSignaturesOfUnionMembers(sig, signature));
          if (!results) break;
        }
      }
      result = results;
    }
    return result || empty;
  }
  function combineUnionThisParam(left: Symbol | undefined, right: Symbol | undefined): Symbol | undefined {
    if (!left || !right) return left || right;
    const thisType = getIntersectionType([getTypeOfSymbol(left), getTypeOfSymbol(right)]);
    return createSymbolWithType(left, thisType);
  }
  function combineUnionParameters(left: Signature, right: Signature) {
    const leftCount = getParameterCount(left);
    const rightCount = getParameterCount(right);
    const longest = leftCount >= rightCount ? left : right;
    const shorter = longest === left ? right : left;
    const longestCount = longest === left ? leftCount : rightCount;
    const eitherHasEffectiveRest = hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right);
    const needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(longest);
    const params = new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0));
    for (let i = 0; i < longestCount; i++) {
      const longestParamType = tryGetTypeAtPosition(longest, i)!;
      const shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
      const unionParamType = getIntersectionType([longestParamType, shorterParamType]);
      const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === longestCount - 1;
      const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);
      const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);
      const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);
      const paramName = leftName === rightName ? leftName : !leftName ? rightName : !rightName ? leftName : undefined;
      const paramSymbol = new QSymbol(SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0), paramName || (`arg${i}` as __String));
      paramSymbol.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
      params[i] = paramSymbol;
    }
    if (needsExtraRestElement) {
      const restParamSymbol = new QSymbol(SymbolFlags.FunctionScopedVariable, 'args' as __String);
      restParamSymbol.type = createArrayType(getTypeAtPosition(shorter, longestCount));
      params[longestCount] = restParamSymbol;
    }
    return params;
  }
  function combineSignaturesOfUnionMembers(left: Signature, right: Signature): Signature {
    const declaration = left.declaration;
    const params = combineUnionParameters(left, right);
    const thisParam = combineUnionThisParam(left.thisParameter, right.thisParameter);
    const minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
    const result = createSignature(
      declaration,
      left.typeParameters || right.typeParameters,
      thisParam,
      params,
      undefined,
      undefined,
      minArgCount,
      (left.flags | right.flags) & SignatureFlags.PropagatingFlags
    );
    result.unionSignatures = concatenate(left.unionSignatures || [left], [right]);
    return result;
  }
  function getUnionIndexInfo(types: readonly Type[], kind: IndexKind): IndexInfo | undefined {
    const indexTypes: Type[] = [];
    let isAnyReadonly = false;
    for (const type of types) {
      const indexInfo = getIndexInfoOfType(getApparentType(type), kind);
      if (!indexInfo) return;
      indexTypes.push(indexInfo.type);
      isAnyReadonly = isAnyReadonly || indexInfo.isReadonly;
    }
    return createIndexInfo(getUnionType(indexTypes, UnionReduction.Subtype), isAnyReadonly);
  }
  function resolveUnionTypeMembers(type: UnionType) {
    const callSignatures = getUnionSignatures(map(type.types, (t) => (t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, SignatureKind.Call))));
    const constructSignatures = getUnionSignatures(map(type.types, (t) => getSignaturesOfType(t, SignatureKind.Construct)));
    const stringIndexInfo = getUnionIndexInfo(type.types, IndexKind.String);
    const numberIndexInfo = getUnionIndexInfo(type.types, IndexKind.Number);
    setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
  }
  function intersectTypes(type1: Type, type2: Type): Type;
  function intersectTypes(type1: Type | undefined, type2: Type | undefined): Type | undefined;
  function intersectTypes(type1: Type | undefined, type2: Type | undefined): Type | undefined {
    return !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]);
  }
  function intersectIndexInfos(info1: IndexInfo | undefined, info2: IndexInfo | undefined): IndexInfo | undefined {
    return !info1 ? info2 : !info2 ? info1 : createIndexInfo(getIntersectionType([info1.type, info2.type]), info1.isReadonly && info2.isReadonly);
  }
  function unionSpreadIndexInfos(info1: IndexInfo | undefined, info2: IndexInfo | undefined): IndexInfo | undefined {
    return info1 && info2 && createIndexInfo(getUnionType([info1.type, info2.type]), info1.isReadonly || info2.isReadonly);
  }
  function findMixins(types: readonly Type[]): readonly boolean[] {
    const constructorTypeCount = countWhere(types, (t) => getSignaturesOfType(t, SignatureKind.Construct).length > 0);
    const mixinFlags = map(types, isMixinConstructorType);
    if (constructorTypeCount > 0 && constructorTypeCount === countWhere(mixinFlags, (b) => b)) {
      const firstMixinIndex = mixinFlags.indexOf(true);
      mixinFlags[firstMixinIndex] = false;
    }
    return mixinFlags;
  }
  function includeMixinType(type: Type, types: readonly Type[], mixinFlags: readonly boolean[], index: number): Type {
    const mixedTypes: Type[] = [];
    for (let i = 0; i < types.length; i++) {
      if (i === index) mixedTypes.push(type);
      else if (mixinFlags[i]) {
        mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], SignatureKind.Construct)[0]));
      }
    }
    return getIntersectionType(mixedTypes);
  }
  function resolveIntersectionTypeMembers(type: IntersectionType) {
    let callSignatures: Signature[] | undefined;
    let constructSignatures: Signature[] | undefined;
    let stringIndexInfo: IndexInfo | undefined;
    let numberIndexInfo: IndexInfo | undefined;
    const types = type.types;
    const mixinFlags = findMixins(types);
    const mixinCount = countWhere(mixinFlags, (b) => b);
    for (let i = 0; i < types.length; i++) {
      const t = type.types[i];
      if (!mixinFlags[i]) {
        let signatures = getSignaturesOfType(t, SignatureKind.Construct);
        if (signatures.length && mixinCount > 0) {
          signatures = map(signatures, (s) => {
            const clone = cloneSignature(s);
            clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);
            return clone;
          });
        }
        constructSignatures = appendSignatures(constructSignatures, signatures);
      }
      callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, SignatureKind.Call));
      stringIndexInfo = intersectIndexInfos(stringIndexInfo, getIndexInfoOfType(t, IndexKind.String));
      numberIndexInfo = intersectIndexInfos(numberIndexInfo, getIndexInfoOfType(t, IndexKind.Number));
    }
    setStructuredTypeMembers(type, emptySymbols, callSignatures || empty, constructSignatures || empty, stringIndexInfo, numberIndexInfo);
  }
  function appendSignatures(signatures: Signature[] | undefined, newSignatures: readonly Signature[]) {
    for (const sig of newSignatures) {
      if (!signatures || every(signatures, (s) => !compareSignaturesIdentical(s, sig, false, compareTypesIdentical))) signatures = append(signatures, sig);
    }
    return signatures;
  }
  function resolveAnonymousTypeMembers(type: AnonymousType) {
    const symbol = getMergedSymbol(type.symbol);
    if (type.target) {
      setStructuredTypeMembers(type, emptySymbols, empty, empty, undefined, undefined);
      const members = createInstantiatedSymbolTable(getPropertiesOfObjectType(type.target), type.mapper!, false);
      const callSignatures = instantiateSignatures(getSignaturesOfType(type.target, SignatureKind.Call), type.mapper!);
      const constructSignatures = instantiateSignatures(getSignaturesOfType(type.target, SignatureKind.Construct), type.mapper!);
      const stringIndexInfo = instantiateIndexInfo(getIndexInfoOfType(type.target, IndexKind.String), type.mapper!);
      const numberIndexInfo = instantiateIndexInfo(getIndexInfoOfType(type.target, IndexKind.Number), type.mapper!);
      setStructuredTypeMembers(type, members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
    } else if (symbol.flags & SymbolFlags.TypeLiteral) {
      setStructuredTypeMembers(type, emptySymbols, empty, empty, undefined, undefined);
      const members = getMembersOfSymbol(symbol);
      const callSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.Call));
      const constructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.New));
      const stringIndexInfo = getIndexInfoOfSymbol(symbol, IndexKind.String);
      const numberIndexInfo = getIndexInfoOfSymbol(symbol, IndexKind.Number);
      setStructuredTypeMembers(type, members, callSignatures, constructSignatures, stringIndexInfo, numberIndexInfo);
    } else {
      let members = emptySymbols;
      let stringIndexInfo: IndexInfo | undefined;
      if (symbol.exports) {
        members = this.getExportsOfSymbol();
        if (symbol === globalThisSymbol) {
          const varsOnly = new SymbolTable();
          members.forEach((p) => {
            if (!(p.flags & SymbolFlags.BlockScoped)) varsOnly.set(p.escName, p);
          });
          members = varsOnly;
        }
      }
      setStructuredTypeMembers(type, members, empty, empty, undefined, undefined);
      if (symbol.flags & SymbolFlags.Class) {
        const classType = this.getDeclaredTypeOfClassOrInterface();
        const baseConstructorType = getBaseConstructorTypeOfClass(classType);
        if (baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.TypeVariable)) {
          members = new SymbolTable(getNamedMembers(members));
          addInheritedMembers(members, getPropertiesOfType(baseConstructorType));
        } else if (baseConstructorType === anyType) {
          stringIndexInfo = createIndexInfo(anyType, false);
        }
      }
      const numberIndexInfo =
        symbol.flags & SymbolFlags.Enum && (getDeclaredTypeOfSymbol(symbol).flags & TypeFlags.Enum || some(type.properties, (prop) => !!(getTypeOfSymbol(prop).flags & TypeFlags.NumberLike)))
          ? enumNumberIndexInfo
          : undefined;
      setStructuredTypeMembers(type, members, empty, empty, stringIndexInfo, numberIndexInfo);
      if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method)) type.callSignatures = getSignaturesOfSymbol(symbol);
      if (symbol.flags & SymbolFlags.Class) {
        const classType = this.getDeclaredTypeOfClassOrInterface();
        let constructSignatures = symbol.members ? getSignaturesOfSymbol(symbol.members.get(InternalSymbolName.Constructor)) : empty;
        if (symbol.flags & SymbolFlags.Function) {
          constructSignatures = addRange(
            constructSignatures.slice(),
            mapDefined(type.callSignatures, (sig) =>
              isJSConstructor(sig.declaration)
                ? createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType, undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags)
                : undefined
            )
          );
        }
        if (!constructSignatures.length) constructSignatures = getDefaultConstructSignatures(classType);
        type.constructSignatures = constructSignatures;
      }
    }
  }
  function resolveReverseMappedTypeMembers(type: ReverseMappedType) {
    const indexInfo = getIndexInfoOfType(type.source, IndexKind.String);
    const modifiers = getMappedTypeModifiers(type.mappedType);
    const readonlyMask = modifiers & MappedTypeModifiers.IncludeReadonly ? false : true;
    const optionalMask = modifiers & MappedTypeModifiers.IncludeOptional ? 0 : SymbolFlags.Optional;
    const stringIndexInfo = indexInfo && createIndexInfo(inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType), readonlyMask && indexInfo.isReadonly);
    const members = new SymbolTable();
    for (const prop of getPropertiesOfType(type.source)) {
      const f = CheckFlags.ReverseMapped | (readonlyMask && isReadonlySymbol(prop) ? CheckFlags.Readonly : 0);
      const inferredProp = new QSymbol(SymbolFlags.Property | (prop.flags & optionalMask), prop.escName, f) as ReverseMappedSymbol;
      inferredProp.declarations = prop.declarations;
      inferredProp.nameType = s.getLinks(prop).nameType;
      inferredProp.propertyType = getTypeOfSymbol(prop);
      inferredProp.mappedType = type.mappedType;
      inferredProp.constraintType = type.constraintType;
      members.set(prop.escName, inferredProp);
    }
    setStructuredTypeMembers(type, members, empty, empty, stringIndexInfo, undefined);
  }
  function getLowerBoundOfKeyType(type: Type): Type {
    if (type.flags & (TypeFlags.Any | TypeFlags.Primitive)) return type;
    if (type.flags & TypeFlags.Index) return getIndexType(getApparentType((<IndexType>type).type));
    if (type.flags & TypeFlags.Conditional) {
      if ((<ConditionalType>type).root.isDistributive) {
        const checkType = (<ConditionalType>type).checkType;
        const constraint = getLowerBoundOfKeyType(checkType);
        if (constraint !== checkType)
          return getConditionalTypeInstantiation(<ConditionalType>type, prependTypeMapping((<ConditionalType>type).root.checkType, constraint, (<ConditionalType>type).mapper));
      }
      return type;
    }
    if (type.flags & TypeFlags.Union) return getUnionType(sameMap((<UnionType>type).types, getLowerBoundOfKeyType));
    if (type.flags & TypeFlags.Intersection) return getIntersectionType(sameMap((<UnionType>type).types, getLowerBoundOfKeyType));
    return neverType;
  }
  function resolveMappedTypeMembers(type: MappedType) {
    const members = new SymbolTable();
    let stringIndexInfo: IndexInfo | undefined;
    let numberIndexInfo: IndexInfo | undefined;
    setStructuredTypeMembers(type, emptySymbols, empty, empty, undefined, undefined);
    const typeParameter = getTypeParameterFromMappedType(type);
    const constraintType = getConstraintTypeFromMappedType(type);
    const templateType = getTemplateTypeFromMappedType(<MappedType>type.target || type);
    const modifiersType = getApparentType(getModifiersTypeFromMappedType(type));
    const templateModifiers = getMappedTypeModifiers(type);
    const include = keyofStringsOnly ? TypeFlags.StringLiteral : TypeFlags.StringOrNumberLiteralOrUnique;
    if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
      for (const prop of getPropertiesOfType(modifiersType)) {
        addMemberForKeyType(getLiteralTypeFromProperty(prop, include));
      }
      if (modifiersType.flags & TypeFlags.Any || getIndexInfoOfType(modifiersType, IndexKind.String)) addMemberForKeyType(stringType);
      if (!keyofStringsOnly && getIndexInfoOfType(modifiersType, IndexKind.Number)) addMemberForKeyType(numberType);
    } else {
      forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
    }
    setStructuredTypeMembers(type, members, empty, empty, stringIndexInfo, numberIndexInfo);
    function addMemberForKeyType(t: Type) {
      const templateMapper = appendTypeMapping(type.mapper, typeParameter, t);
      if (isTypeUsableAsPropertyName(t)) {
        const propName = getPropertyNameFromType(t);
        const modifiersProp = getPropertyOfType(modifiersType, propName);
        const isOptional = !!(
          templateModifiers & MappedTypeModifiers.IncludeOptional ||
          (!(templateModifiers & MappedTypeModifiers.ExcludeOptional) && modifiersProp && modifiersProp.flags & SymbolFlags.Optional)
        );
        const isReadonly = !!(
          templateModifiers & MappedTypeModifiers.IncludeReadonly ||
          (!(templateModifiers & MappedTypeModifiers.ExcludeReadonly) && modifiersProp && isReadonlySymbol(modifiersProp))
        );
        const stripOptional = strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags & SymbolFlags.Optional;
        const prop = <MappedSymbol>(
          new QSymbol(
            SymbolFlags.Property | (isOptional ? SymbolFlags.Optional : 0),
            propName,
            CheckFlags.Mapped | (isReadonly ? CheckFlags.Readonly : 0) | (stripOptional ? CheckFlags.StripOptional : 0)
          )
        );
        prop.mappedType = type;
        prop.mapper = templateMapper;
        if (modifiersProp) {
          prop.syntheticOrigin = modifiersProp;
          prop.declarations = modifiersProp.declarations;
        }
        prop.nameType = t;
        members.set(propName, prop);
      } else if (t.flags & (TypeFlags.Any | TypeFlags.String | TypeFlags.Number | TypeFlags.Enum)) {
        const propType = instantiateType(templateType, templateMapper);
        if (t.flags & (TypeFlags.Any | TypeFlags.String)) stringIndexInfo = createIndexInfo(propType, !!(templateModifiers & MappedTypeModifiers.IncludeReadonly));
        else {
          numberIndexInfo = createIndexInfo(numberIndexInfo ? getUnionType([numberIndexInfo.type, propType]) : propType, !!(templateModifiers & MappedTypeModifiers.IncludeReadonly));
        }
      }
    }
  }
  function getTypeOfMappedSymbol(symbol: MappedSymbol) {
    if (!symbol.type) {
      if (!pushTypeResolution(symbol, TypeSystemPropertyName.Type)) return errorType;
      const templateType = getTemplateTypeFromMappedType(<MappedType>symbol.mappedType.target || symbol.mappedType);
      const propType = instantiateType(templateType, symbol.mapper);
      let type =
        strictNullChecks && symbol.flags & SymbolFlags.Optional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void)
          ? getOptionalType(propType)
          : symbol.checkFlags & CheckFlags.StripOptional
          ? getTypeWithFacts(propType, TypeFacts.NEUndefined)
          : propType;
      if (!popTypeResolution()) {
        error(currentNode, qd.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbol.symbolToString(), typeToString(symbol.mappedType));
        type = errorType;
      }
      symbol.type = type;
      symbol.mapper = undefined!;
    }
    return symbol.type;
  }
  function getTypeParameterFromMappedType(type: MappedType) {
    return type.typeParameter || (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(type.declaration.typeParameter)));
  }
  function getConstraintTypeFromMappedType(type: MappedType) {
    return type.constraintType || (type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType);
  }
  function getTemplateTypeFromMappedType(type: MappedType) {
    return (
      type.templateType ||
      (type.templateType = type.declaration.type
        ? instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper)
        : errorType)
    );
  }
  function getConstraintDeclarationForMappedType(type: MappedType) {
    return getEffectiveConstraintOfTypeParameter(type.declaration.typeParameter);
  }
  function isMappedTypeWithKeyofConstraintDeclaration(type: MappedType) {
    const constraintDeclaration = getConstraintDeclarationForMappedType(type)!;
    return constraintDeclaration.kind === Syntax.TypeOperator && (<TypeOperatorNode>constraintDeclaration).operator === Syntax.KeyOfKeyword;
  }
  function getModifiersTypeFromMappedType(type: MappedType) {
    if (!type.modifiersType) {
      if (isMappedTypeWithKeyofConstraintDeclaration(type))
        type.modifiersType = instantiateType(getTypeFromTypeNode((<TypeOperatorNode>getConstraintDeclarationForMappedType(type)).type), type.mapper);
      else {
        const declaredType = <MappedType>getTypeFromMappedTypeNode(type.declaration);
        const constraint = getConstraintTypeFromMappedType(declaredType);
        const extendedConstraint = constraint && constraint.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(<TypeParameter>constraint) : constraint;
        type.modifiersType = extendedConstraint && extendedConstraint.flags & TypeFlags.Index ? instantiateType((<IndexType>extendedConstraint).type, type.mapper) : unknownType;
      }
    }
    return type.modifiersType;
  }
  function getMappedTypeModifiers(type: MappedType): MappedTypeModifiers {
    const declaration = type.declaration;
    return (
      (declaration.readonlyToken ? (declaration.readonlyToken.kind === Syntax.MinusToken ? MappedTypeModifiers.ExcludeReadonly : MappedTypeModifiers.IncludeReadonly) : 0) |
      (declaration.questionToken ? (declaration.questionToken.kind === Syntax.MinusToken ? MappedTypeModifiers.ExcludeOptional : MappedTypeModifiers.IncludeOptional) : 0)
    );
  }
  function getMappedTypeOptionality(type: MappedType): number {
    const modifiers = getMappedTypeModifiers(type);
    return modifiers & MappedTypeModifiers.ExcludeOptional ? -1 : modifiers & MappedTypeModifiers.IncludeOptional ? 1 : 0;
  }
  function getCombinedMappedTypeOptionality(type: MappedType): number {
    const optionality = getMappedTypeOptionality(type);
    const modifiersType = getModifiersTypeFromMappedType(type);
    return optionality || (isGenericMappedType(modifiersType) ? getMappedTypeOptionality(modifiersType) : 0);
  }
  function isPartialMappedType(type: Type) {
    return !!(getObjectFlags(type) & ObjectFlags.Mapped && getMappedTypeModifiers(<MappedType>type) & MappedTypeModifiers.IncludeOptional);
  }
  function isGenericMappedType(type: Type): type is MappedType {
    return !!(getObjectFlags(type) & ObjectFlags.Mapped) && isGenericIndexType(getConstraintTypeFromMappedType(<MappedType>type));
  }
  function resolveStructuredTypeMembers(type: StructuredType): ResolvedType {
    if (!(<ResolvedType>type).members) {
      if (type.flags & TypeFlags.Object) {
        if ((<ObjectType>type).objectFlags & ObjectFlags.Reference) resolveTypeReferenceMembers(<TypeReference>type);
        else if ((<ObjectType>type).objectFlags & ObjectFlags.ClassOrInterface) resolveClassOrInterfaceMembers(<InterfaceType>type);
        else if ((<ReverseMappedType>type).objectFlags & ObjectFlags.ReverseMapped) resolveReverseMappedTypeMembers(type as ReverseMappedType);
        else if ((<ObjectType>type).objectFlags & ObjectFlags.Anonymous) resolveAnonymousTypeMembers(<AnonymousType>type);
        else if ((<MappedType>type).objectFlags & ObjectFlags.Mapped) resolveMappedTypeMembers(<MappedType>type);
      } else if (type.flags & TypeFlags.Union) resolveUnionTypeMembers(<UnionType>type);
      else if (type.flags & TypeFlags.Intersection) resolveIntersectionTypeMembers(<IntersectionType>type);
    }
    return <ResolvedType>type;
  }
  function getPropertiesOfObjectType(type: Type): Symbol[] {
    if (type.flags & TypeFlags.Object) return resolveStructuredTypeMembers(<ObjectType>type).properties;
    return empty;
  }
  function getPropertyOfObjectType(type: Type, name: __String): Symbol | undefined {
    if (type.flags & TypeFlags.Object) {
      const resolved = resolveStructuredTypeMembers(<ObjectType>type);
      const symbol = resolved.members.get(name);
      if (symbol && symbolIsValue(symbol)) return symbol;
    }
  }
  function getPropertiesOfUnionOrIntersectionType(type: UnionOrIntersectionType): Symbol[] {
    if (!type.resolvedProperties) {
      const members = new SymbolTable();
      for (const current of type.types) {
        for (const prop of getPropertiesOfType(current)) {
          if (!members.has(prop.escName)) {
            const combinedProp = getPropertyOfUnionOrIntersectionType(type, prop.escName);
            if (combinedProp) members.set(prop.escName, combinedProp);
          }
        }
        if (type.flags & TypeFlags.Union && !getIndexInfoOfType(current, IndexKind.String) && !getIndexInfoOfType(current, IndexKind.Number)) break;
      }
      type.resolvedProperties = getNamedMembers(members);
    }
    return type.resolvedProperties;
  }
  function getPropertiesOfType(type: Type): Symbol[] {
    type = getReducedApparentType(type);
    return type.flags & TypeFlags.UnionOrIntersection ? getPropertiesOfUnionOrIntersectionType(<UnionType>type) : getPropertiesOfObjectType(type);
  }
  function isTypeInvalidDueToUnionDiscriminant(contextualType: Type, obj: ObjectLiteralExpression | JsxAttributes): boolean {
    const list = obj.properties as Nodes<ObjectLiteralElementLike | JsxAttributeLike>;
    return list.some((property) => {
      const nameType = property.name && getLiteralTypeFromPropertyName(property.name);
      const name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
      const expected = name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name);
      return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected);
    });
  }
  function getAllPossiblePropertiesOfTypes(types: readonly Type[]): Symbol[] {
    const unionType = getUnionType(types);
    if (!(unionType.flags & TypeFlags.Union)) return getAugmentedPropertiesOfType(unionType);
    const props = new SymbolTable();
    for (const memberType of types) {
      for (const { escName } of getAugmentedPropertiesOfType(memberType)) {
        if (!props.has(escName)) {
          const prop = createUnionOrIntersectionProperty(unionType as UnionType, escName);
          if (prop) props.set(escName, prop);
        }
      }
    }
    return arrayFrom(props.values());
  }
  function getConstraintOfType(type: InstantiableType | UnionOrIntersectionType): Type | undefined {
    return type.flags & TypeFlags.TypeParameter
      ? getConstraintOfTypeParameter(<TypeParameter>type)
      : type.flags & TypeFlags.IndexedAccess
      ? getConstraintOfIndexedAccess(<IndexedAccessType>type)
      : type.flags & TypeFlags.Conditional
      ? getConstraintOfConditionalType(<ConditionalType>type)
      : getBaseConstraintOfType(type);
  }
  function getConstraintOfTypeParameter(typeParameter: TypeParameter): Type | undefined {
    return hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined;
  }
  function getConstraintOfIndexedAccess(type: IndexedAccessType) {
    return hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined;
  }
  function getSimplifiedTypeOrConstraint(type: Type) {
    const simplified = getSimplifiedType(type, false);
    return simplified !== type ? simplified : getConstraintOfType(type);
  }
  function getConstraintFromIndexedAccess(type: IndexedAccessType) {
    const indexConstraint = getSimplifiedTypeOrConstraint(type.indexType);
    if (indexConstraint && indexConstraint !== type.indexType) {
      const indexedAccess = getIndexedAccessTypeOrUndefined(type.objectType, indexConstraint);
      if (indexedAccess) return indexedAccess;
    }
    const objectConstraint = getSimplifiedTypeOrConstraint(type.objectType);
    if (objectConstraint && objectConstraint !== type.objectType) return getIndexedAccessTypeOrUndefined(objectConstraint, type.indexType);
    return;
  }
  function getDefaultConstraintOfConditionalType(type: ConditionalType) {
    if (!type.resolvedDefaultConstraint) {
      const trueConstraint = getInferredTrueTypeFromConditionalType(type);
      const falseConstraint = getFalseTypeFromConditionalType(type);
      type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]);
    }
    return type.resolvedDefaultConstraint;
  }
  function getConstraintOfDistributiveConditionalType(type: ConditionalType): Type | undefined {
    if (type.root.isDistributive && type.restrictiveInstantiation !== type) {
      const simplified = getSimplifiedType(type.checkType, false);
      const constraint = simplified === type.checkType ? getConstraintOfType(simplified) : simplified;
      if (constraint && constraint !== type.checkType) {
        const instantiated = getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
        if (!(instantiated.flags & TypeFlags.Never)) return instantiated;
      }
    }
    return;
  }
  function getConstraintFromConditionalType(type: ConditionalType) {
    return getConstraintOfDistributiveConditionalType(type) || getDefaultConstraintOfConditionalType(type);
  }
  function getConstraintOfConditionalType(type: ConditionalType) {
    return hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined;
  }
  function getEffectiveConstraintOfIntersection(types: readonly Type[], targetIsUnion: boolean) {
    let constraints: Type[] | undefined;
    let hasDisjointDomainType = false;
    for (const t of types) {
      if (t.flags & TypeFlags.Instantiable) {
        let constraint = getConstraintOfType(t);
        while (constraint && constraint.flags & (TypeFlags.TypeParameter | TypeFlags.Index | TypeFlags.Conditional)) {
          constraint = getConstraintOfType(constraint);
        }
        if (constraint) {
          constraints = append(constraints, constraint);
          if (targetIsUnion) constraints = append(constraints, t);
        }
      } else if (t.flags & TypeFlags.DisjointDomains) hasDisjointDomainType = true;
    }
    if (constraints && (targetIsUnion || hasDisjointDomainType)) {
      if (hasDisjointDomainType) {
        for (const t of types) {
          if (t.flags & TypeFlags.DisjointDomains) constraints = append(constraints, t);
        }
      }
      return getIntersectionType(constraints);
    }
    return;
  }
  function getBaseConstraintOfType(type: Type): Type | undefined {
    if (type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.UnionOrIntersection)) {
      const constraint = getResolvedBaseConstraint(<InstantiableType | UnionOrIntersectionType>type);
      return constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined;
    }
    return type.flags & TypeFlags.Index ? keyofConstraintType : undefined;
  }
  function getBaseConstraintOrType(type: Type) {
    return getBaseConstraintOfType(type) || type;
  }
  function hasNonCircularBaseConstraint(type: InstantiableType): boolean {
    return getResolvedBaseConstraint(type) !== circularConstraintType;
  }
  function getResolvedBaseConstraint(type: InstantiableType | UnionOrIntersectionType): Type {
    let nonTerminating = false;
    return type.resolvedBaseConstraint || (type.resolvedBaseConstraint = getTypeWithThisArgument(getImmediateBaseConstraint(type), type));
    function getImmediateBaseConstraint(t: Type): Type {
      if (!t.immediateBaseConstraint) {
        if (!pushTypeResolution(t, TypeSystemPropertyName.ImmediateBaseConstraint)) return circularConstraintType;
        if (constraintDepth >= 50) {
          error(currentNode, qd.Type_instantiation_is_excessively_deep_and_possibly_infinite);
          nonTerminating = true;
          return (t.immediateBaseConstraint = noConstraintType);
        }
        constraintDepth++;
        let result = computeBaseConstraint(getSimplifiedType(t, false));
        constraintDepth--;
        if (!popTypeResolution()) {
          if (t.flags & TypeFlags.TypeParameter) {
            const errorNode = getConstraintDeclaration(<TypeParameter>t);
            if (errorNode) {
              const diagnostic = error(errorNode, qd.Type_parameter_0_has_a_circular_constraint, typeToString(t));
              if (currentNode && !qc.is.descendantOf(errorNode, currentNode) && !qc.is.descendantOf(currentNode, errorNode))
                addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode, qd.Circularity_originates_in_type_at_this_location));
            }
          }
          result = circularConstraintType;
        }
        if (nonTerminating) result = circularConstraintType;
        t.immediateBaseConstraint = result || noConstraintType;
      }
      return t.immediateBaseConstraint;
    }
    function getBaseConstraint(t: Type): Type | undefined {
      const c = getImmediateBaseConstraint(t);
      return c !== noConstraintType && c !== circularConstraintType ? c : undefined;
    }
    function computeBaseConstraint(t: Type): Type | undefined {
      if (t.flags & TypeFlags.TypeParameter) {
        const constraint = getConstraintFromTypeParameter(<TypeParameter>t);
        return (t as TypeParameter).isThisType || !constraint ? constraint : getBaseConstraint(constraint);
      }
      if (t.flags & TypeFlags.UnionOrIntersection) {
        const types = (<UnionOrIntersectionType>t).types;
        const baseTypes: Type[] = [];
        for (const type of types) {
          const baseType = getBaseConstraint(type);
          if (baseType) baseTypes.push(baseType);
        }
        return t.flags & TypeFlags.Union && baseTypes.length === types.length
          ? getUnionType(baseTypes)
          : t.flags & TypeFlags.Intersection && baseTypes.length
          ? getIntersectionType(baseTypes)
          : undefined;
      }
      if (t.flags & TypeFlags.Index) return keyofConstraintType;
      if (t.flags & TypeFlags.IndexedAccess) {
        const baseObjectType = getBaseConstraint((<IndexedAccessType>t).objectType);
        const baseIndexType = getBaseConstraint((<IndexedAccessType>t).indexType);
        const baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType);
        return baseIndexedAccess && getBaseConstraint(baseIndexedAccess);
      }
      if (t.flags & TypeFlags.Conditional) {
        const constraint = getConstraintFromConditionalType(<ConditionalType>t);
        constraintDepth++;
        const result = constraint && getBaseConstraint(constraint);
        constraintDepth--;
        return result;
      }
      if (t.flags & TypeFlags.Substitution) return getBaseConstraint((<SubstitutionType>t).substitute);
      return t;
    }
  }
  function getApparentTypeOfIntersectionType(type: IntersectionType) {
    return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(type, type, true));
  }
  function getResolvedTypeParameterDefault(typeParameter: TypeParameter): Type | undefined {
    if (!typeParameter.default) {
      if (typeParameter.target) {
        const targetDefault = getResolvedTypeParameterDefault(typeParameter.target);
        typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType;
      } else {
        typeParameter.default = resolvingDefaultType;
        const defaultDeclaration = typeParameter.symbol && forEach(typeParameter.symbol.declarations, (decl) => qc.is.kind(TypeParameterDeclaration, decl) && decl.default);
        const defaultType = defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType;
        if (typeParameter.default === resolvingDefaultType) typeParameter.default = defaultType;
      }
    } else if (typeParameter.default === resolvingDefaultType) typeParameter.default = circularConstraintType;
    return typeParameter.default;
  }
  function getDefaultFromTypeParameter(typeParameter: TypeParameter): Type | undefined {
    const defaultType = getResolvedTypeParameterDefault(typeParameter);
    return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined;
  }
  function hasNonCircularTypeParameterDefault(typeParameter: TypeParameter) {
    return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
  }
  function hasTypeParameterDefault(typeParameter: TypeParameter): boolean {
    return !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, (decl) => qc.is.kind(TypeParameterDeclaration, decl) && decl.default));
  }
  function getApparentTypeOfMappedType(type: MappedType) {
    return type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type));
  }
  function getResolvedApparentTypeOfMappedType(type: MappedType) {
    const typeVariable = getHomomorphicTypeVariable(type);
    if (typeVariable) {
      const constraint = getConstraintOfTypeParameter(typeVariable);
      if (constraint && (isArrayType(constraint) || isTupleType(constraint))) return instantiateType(type, prependTypeMapping(typeVariable, constraint, type.mapper));
    }
    return type;
  }
  function getApparentType(type: Type): Type {
    const t = type.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(type) || unknownType : type;
    return getObjectFlags(t) & ObjectFlags.Mapped
      ? getApparentTypeOfMappedType(<MappedType>t)
      : t.flags & TypeFlags.Intersection
      ? getApparentTypeOfIntersectionType(<IntersectionType>t)
      : t.flags & TypeFlags.StringLike
      ? globalStringType
      : t.flags & TypeFlags.NumberLike
      ? globalNumberType
      : t.flags & TypeFlags.BigIntLike
      ? getGlobalBigIntType(true)
      : t.flags & TypeFlags.BooleanLike
      ? globalBooleanType
      : t.flags & TypeFlags.ESSymbolLike
      ? getGlobalESSymbolType(true)
      : t.flags & TypeFlags.NonPrimitive
      ? emptyObjectType
      : t.flags & TypeFlags.Index
      ? keyofConstraintType
      : t.flags & TypeFlags.Unknown && !strictNullChecks
      ? emptyObjectType
      : t;
  }
  function getReducedApparentType(type: Type): Type {
    return getReducedType(getApparentType(getReducedType(type)));
  }
  function createUnionOrIntersectionProperty(containingType: UnionOrIntersectionType, name: __String): Symbol | undefined {
    let singleProp: Symbol | undefined;
    let propSet: qb.QMap<Symbol> | undefined;
    let indexTypes: Type[] | undefined;
    const isUnion = containingType.flags & TypeFlags.Union;
    let optionalFlag = isUnion ? SymbolFlags.None : SymbolFlags.Optional;
    let syntheticFlag = CheckFlags.SyntheticMethod;
    let checkFlags = 0;
    for (const current of containingType.types) {
      const type = getApparentType(current);
      if (!(type === errorType || type.flags & TypeFlags.Never)) {
        const prop = getPropertyOfType(type, name);
        const modifiers = prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0;
        if (prop) {
          if (isUnion) optionalFlag |= prop.flags & SymbolFlags.Optional;
          else optionalFlag &= prop.flags;
          if (!singleProp) singleProp = prop;
          else if (prop !== singleProp) {
            if (!propSet) {
              propSet = new qb.QMap<Symbol>();
              propSet.set('' + singleProp.getId(), singleProp);
            }
            const id = '' + prop.getId();
            if (!propSet.has(id)) propSet.set(id, prop);
          }
          checkFlags |=
            (isReadonlySymbol(prop) ? CheckFlags.Readonly : 0) |
            (!(modifiers & ModifierFlags.NonPublicAccessibilityModifier) ? CheckFlags.ContainsPublic : 0) |
            (modifiers & ModifierFlags.Protected ? CheckFlags.ContainsProtected : 0) |
            (modifiers & ModifierFlags.Private ? CheckFlags.ContainsPrivate : 0) |
            (modifiers & ModifierFlags.Static ? CheckFlags.ContainsStatic : 0);
          if (!isPrototypeProperty(prop)) syntheticFlag = CheckFlags.SyntheticProperty;
        } else if (isUnion) {
          const indexInfo = !isLateBoundName(name) && ((NumericLiteral.name(name) && getIndexInfoOfType(type, IndexKind.Number)) || getIndexInfoOfType(type, IndexKind.String));
          if (indexInfo) {
            checkFlags |= CheckFlags.WritePartial | (indexInfo.isReadonly ? CheckFlags.Readonly : 0);
            indexTypes = append(indexTypes, isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type);
          } else if (isObjectLiteralType(type)) {
            checkFlags |= CheckFlags.WritePartial;
            indexTypes = append(indexTypes, undefinedType);
          } else checkFlags |= CheckFlags.ReadPartial;
        }
      }
    }
    if (!singleProp || (isUnion && (propSet || checkFlags & CheckFlags.Partial) && checkFlags & (CheckFlags.ContainsPrivate | CheckFlags.ContainsProtected))) return;
    if (!propSet && !(checkFlags & CheckFlags.ReadPartial) && !indexTypes) return singleProp;
    const props = propSet ? arrayFrom(propSet.values()) : [singleProp];
    let declarations: Declaration[] | undefined;
    let firstType: Type | undefined;
    let nameType: Type | undefined;
    const propTypes: Type[] = [];
    let firstValueDeclaration: Declaration | undefined;
    let hasNonUniformValueDeclaration = false;
    for (const prop of props) {
      if (!firstValueDeclaration) firstValueDeclaration = prop.valueDeclaration;
      else if (prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration) {
        hasNonUniformValueDeclaration = true;
      }
      declarations = addRange(declarations, prop.declarations);
      const type = getTypeOfSymbol(prop);
      if (!firstType) {
        firstType = type;
        nameType = s.getLinks(prop).nameType;
      } else if (type !== firstType) {
        checkFlags |= CheckFlags.HasNonUniformType;
      }
      if (isLiteralType(type)) checkFlags |= CheckFlags.HasLiteralType;
      if (type.flags & TypeFlags.Never) checkFlags |= CheckFlags.HasNeverType;
      propTypes.push(type);
    }
    addRange(propTypes, indexTypes);
    const result = new QSymbol(SymbolFlags.Property | optionalFlag, name, syntheticFlag | checkFlags);
    result.containingType = containingType;
    if (!hasNonUniformValueDeclaration && firstValueDeclaration) {
      result.valueDeclaration = firstValueDeclaration;
      if (firstValueDeclaration.symbol.parent) result.parent = firstValueDeclaration.symbol.parent;
    }
    result.declarations = declarations!;
    result.nameType = nameType;
    if (propTypes.length > 2) {
      result.checkFlags |= CheckFlags.DeferredType;
      result.deferralParent = containingType;
      result.deferralConstituents = propTypes;
    } else {
      result.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes);
    }
    return result;
  }
  function getUnionOrIntersectionProperty(type: UnionOrIntersectionType, name: __String): Symbol | undefined {
    const properties = type.propertyCache || (type.propertyCache = new SymbolTable());
    let property = properties.get(name);
    if (!property) {
      property = createUnionOrIntersectionProperty(type, name);
      if (property) properties.set(name, property);
    }
    return property;
  }
  function getPropertyOfUnionOrIntersectionType(type: UnionOrIntersectionType, name: __String): Symbol | undefined {
    const property = getUnionOrIntersectionProperty(type, name);
    return property && !(getCheckFlags(property) & CheckFlags.ReadPartial) ? property : undefined;
  }
  function getReducedType(type: Type): Type {
    if (type.flags & TypeFlags.Union && (<UnionType>type).objectFlags & ObjectFlags.ContainsIntersections)
      return (<UnionType>type).resolvedReducedType || ((<UnionType>type).resolvedReducedType = getReducedUnionType(<UnionType>type));
    else if (type.flags & TypeFlags.Intersection) {
      if (!((<IntersectionType>type).objectFlags & ObjectFlags.IsNeverIntersectionComputed)) {
        (<IntersectionType>type).objectFlags |=
          ObjectFlags.IsNeverIntersectionComputed | (some(getPropertiesOfUnionOrIntersectionType(<IntersectionType>type), isNeverReducedProperty) ? ObjectFlags.IsNeverIntersection : 0);
      }
      return (<IntersectionType>type).objectFlags & ObjectFlags.IsNeverIntersection ? neverType : type;
    }
    return type;
  }
  function getReducedUnionType(unionType: UnionType) {
    const reducedTypes = sameMap(unionType.types, getReducedType);
    if (reducedTypes === unionType.types) return unionType;
    const reduced = getUnionType(reducedTypes);
    if (reduced.flags & TypeFlags.Union) (<UnionType>reduced).resolvedReducedType = reduced;
    return reduced;
  }
  function isNeverReducedProperty(prop: Symbol) {
    return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop);
  }
  function isDiscriminantWithNeverType(prop: Symbol) {
    return (
      !(prop.flags & SymbolFlags.Optional) &&
      (getCheckFlags(prop) & (CheckFlags.Discriminant | CheckFlags.HasNeverType)) === CheckFlags.Discriminant &&
      !!(getTypeOfSymbol(prop).flags & TypeFlags.Never)
    );
  }
  function isConflictingPrivateProperty(prop: Symbol) {
    return !prop.valueDeclaration && !!(getCheckFlags(prop) & CheckFlags.ContainsPrivate);
  }
  function elaborateNeverIntersection(errorInfo: DiagnosticMessageChain | undefined, type: Type) {
    if (getObjectFlags(type) & ObjectFlags.IsNeverIntersection) {
      const neverProp = find(getPropertiesOfUnionOrIntersectionType(<IntersectionType>type), isDiscriminantWithNeverType);
      if (neverProp) {
        return chainDiagnosticMessages(
          errorInfo,
          qd.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents,
          typeToString(type, undefined, TypeFormatFlags.NoTypeReduction),
          neverProp.symbolToString()
        );
      }
      const privateProp = find(getPropertiesOfUnionOrIntersectionType(<IntersectionType>type), isConflictingPrivateProperty);
      if (privateProp) {
        return chainDiagnosticMessages(
          errorInfo,
          qd.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some,
          typeToString(type, undefined, TypeFormatFlags.NoTypeReduction),
          privateProp.symbolToString()
        );
      }
    }
    return errorInfo;
  }
  function getPropertyOfType(type: Type, name: __String): Symbol | undefined {
    type = getReducedApparentType(type);
    if (type.flags & TypeFlags.Object) {
      const resolved = resolveStructuredTypeMembers(<ObjectType>type);
      const symbol = resolved.members.get(name);
      if (symbol && symbolIsValue(symbol)) return symbol;
      const functionType =
        resolved === anyFunctionType ? globalFunctionType : resolved.callSignatures.length ? globalCallableFunctionType : resolved.constructSignatures.length ? globalNewableFunctionType : undefined;
      if (functionType) {
        const symbol = getPropertyOfObjectType(functionType, name);
        if (symbol) return symbol;
      }
      return getPropertyOfObjectType(globalObjectType, name);
    }
    if (type.flags & TypeFlags.UnionOrIntersection) return getPropertyOfUnionOrIntersectionType(<UnionOrIntersectionType>type, name);
    return;
  }
  function getSignaturesOfStructuredType(type: Type, kind: SignatureKind): readonly Signature[] {
    if (type.flags & TypeFlags.StructuredType) {
      const resolved = resolveStructuredTypeMembers(<ObjectType>type);
      return kind === SignatureKind.Call ? resolved.callSignatures : resolved.constructSignatures;
    }
    return empty;
  }
  function getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[] {
    return getSignaturesOfStructuredType(getReducedApparentType(type), kind);
  }
  function getIndexInfoOfStructuredType(type: Type, kind: IndexKind): IndexInfo | undefined {
    if (type.flags & TypeFlags.StructuredType) {
      const resolved = resolveStructuredTypeMembers(<ObjectType>type);
      return kind === IndexKind.String ? resolved.stringIndexInfo : resolved.numberIndexInfo;
    }
  }
  function getIndexTypeOfStructuredType(type: Type, kind: IndexKind): Type | undefined {
    const info = getIndexInfoOfStructuredType(type, kind);
    return info && info.type;
  }
  function getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined {
    return getIndexInfoOfStructuredType(getReducedApparentType(type), kind);
  }
  function getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined {
    return getIndexTypeOfStructuredType(getReducedApparentType(type), kind);
  }
  function getImplicitIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined {
    if (isObjectTypeWithInferableIndex(type)) {
      const propTypes: Type[] = [];
      for (const prop of getPropertiesOfType(type)) {
        if (kind === IndexKind.String || NumericLiteral.name(prop.escName)) propTypes.push(getTypeOfSymbol(prop));
      }
      if (kind === IndexKind.String) append(propTypes, getIndexTypeOfType(type, IndexKind.Number));
      if (propTypes.length) return getUnionType(propTypes);
    }
    return;
  }
  function getTypeParametersFromDeclaration(declaration: DeclarationWithTypeParameters): TypeParameter[] | undefined {
    let result: TypeParameter[] | undefined;
    for (const node of getEffectiveTypeParameterDeclarations(declaration)) {
      result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol));
    }
    return result;
  }
  function symbolsToArray(symbols: SymbolTable): Symbol[] {
    const result: Symbol[] = [];
    symbols.forEach((symbol, id) => {
      if (!syntax.is.reservedName(id)) result.push(symbol);
    });
    return result;
  }
  function isJSDocOptionalParameter(node: ParameterDeclaration) {
    return (
      isInJSFile(node) &&
      ((node.type && node.type.kind === Syntax.JSDocOptionalType) ||
        qc.getDoc.parameterTags(node).some(({ isBracketed, typeExpression }) => isBracketed || (!!typeExpression && typeExpression.type.kind === Syntax.JSDocOptionalType)))
    );
  }
  function tryFindAmbientModule(moduleName: string, withAugmentations: boolean) {
    if (qp_isExternalModuleNameRelative(moduleName)) return;
    const symbol = getSymbol(globals, ('"' + moduleName + '"') as __String, SymbolFlags.ValueModule);
    return symbol && withAugmentations ? getMergedSymbol(symbol) : symbol;
  }
  function isOptionalParameter(node: ParameterDeclaration | JSDocParameterTag) {
    if (hasQuestionToken(node) || isOptionalJSDocParameterTag(node) || isJSDocOptionalParameter(node)) return true;
    if (node.initializer) {
      const signature = getSignatureFromDeclaration(node.parent);
      const parameterIndex = node.parent.parameters.indexOf(node);
      assert(parameterIndex >= 0);
      return parameterIndex >= getMinArgumentCount(signature, true);
    }
    const iife = qc.get.immediatelyInvokedFunctionExpression(node.parent);
    if (iife) return !node.type && !node.dot3Token && node.parent.parameters.indexOf(node) >= iife.arguments.length;
    return false;
  }
  function isOptionalJSDocParameterTag(node: Node): node is JSDocParameterTag {
    if (!qc.is.kind(JSDocParameterTag, node)) return false;
    const { isBracketed, typeExpression } = node;
    return isBracketed || (!!typeExpression && typeExpression.type.kind === Syntax.JSDocOptionalType);
  }
  function createTypePredicate(kind: TypePredicateKind, parameterName: string | undefined, parameterIndex: number | undefined, type: Type | undefined): TypePredicate {
    return { kind, parameterName, parameterIndex, type } as TypePredicate;
  }
  function getMinTypeArgumentCount(typeParameters: readonly TypeParameter[] | undefined): number {
    let minTypeArgumentCount = 0;
    if (typeParameters) {
      for (let i = 0; i < typeParameters.length; i++) {
        if (!hasTypeParameterDefault(typeParameters[i])) minTypeArgumentCount = i + 1;
      }
    }
    return minTypeArgumentCount;
  }
  function fillMissingTypeArguments(typeArguments: readonly Type[], typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[];
  function fillMissingTypeArguments(
    typeArguments: readonly Type[] | undefined,
    typeParameters: readonly TypeParameter[] | undefined,
    minTypeArgumentCount: number,
    isJavaScriptImplicitAny: boolean
  ): Type[] | undefined;
  function fillMissingTypeArguments(typeArguments: readonly Type[] | undefined, typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean) {
    const numTypeParameters = length(typeParameters);
    if (!numTypeParameters) return [];
    const numTypeArguments = length(typeArguments);
    if (isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters)) {
      const result = typeArguments ? typeArguments.slice() : [];
      for (let i = numTypeArguments; i < numTypeParameters; i++) {
        result[i] = errorType;
      }
      const baseDefaultType = getDefaultTypeArgumentType(isJavaScriptImplicitAny);
      for (let i = numTypeArguments; i < numTypeParameters; i++) {
        let defaultType = getDefaultFromTypeParameter(typeParameters![i]);
        if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) defaultType = anyType;
        result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters!, result)) : baseDefaultType;
      }
      result.length = typeParameters!.length;
      return result;
    }
    return typeArguments && typeArguments.slice();
  }
  function getSignatureFromDeclaration(declaration: SignatureDeclaration | JSDocSignature): Signature {
    const links = getNodeLinks(declaration);
    if (!links.resolvedSignature) {
      const parameters: Symbol[] = [];
      let flags = SignatureFlags.None;
      let minArgumentCount = 0;
      let thisParameter: Symbol | undefined;
      let hasThisParameter = false;
      const iife = qc.get.immediatelyInvokedFunctionExpression(declaration);
      const isJSConstructSignature = qc.isDoc.constructSignature(declaration);
      const isUntypedSignatureInJSFile = !iife && isInJSFile(declaration) && isValueSignatureDeclaration(declaration) && !qc.getDoc.withParameterTags(declaration) && !qc.getDoc.type(declaration);
      if (isUntypedSignatureInJSFile) flags |= SignatureFlags.IsUntypedSignatureInJSFile;
      for (let i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {
        const param = declaration.parameters[i];
        let paramSymbol = param.symbol;
        const type = qc.is.kind(JSDocParameterTag, param) ? param.typeExpression && param.typeExpression.type : param.type;
        if (paramSymbol && !!(paramSymbol.flags & SymbolFlags.Property) && !qc.is.kind(BindingPattern, param.name)) {
          const resolvedSymbol = resolveName(param, paramSymbol.escName, SymbolFlags.Value, undefined, undefined, false);
          paramSymbol = resolvedSymbol!;
        }
        if (i === 0 && paramSymbol.escName === InternalSymbolName.This) {
          hasThisParameter = true;
          thisParameter = param.symbol;
        } else {
          parameters.push(paramSymbol);
        }
        if (type && type.kind === Syntax.LiteralType) flags |= SignatureFlags.HasLiteralTypes;
        const isOptionalParameter =
          isOptionalJSDocParameterTag(param) ||
          param.initializer ||
          param.questionToken ||
          param.dot3Token ||
          (iife && parameters.length > iife.arguments.length && !type) ||
          isJSDocOptionalParameter(param);
        if (!isOptionalParameter) minArgumentCount = parameters.length;
      }
      if ((declaration.kind === Syntax.GetAccessor || declaration.kind === Syntax.SetAccessor) && !hasNonBindableDynamicName(declaration) && (!hasThisParameter || !thisParameter)) {
        const otherKind = declaration.kind === Syntax.GetAccessor ? Syntax.SetAccessor : Syntax.GetAccessor;
        const other = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfNode(declaration), otherKind);
        if (other) thisParameter = getAnnotatedAccessorThisNodeKind(ParameterDeclaration, other);
      }
      const classType = declaration.kind === Syntax.Constructor ? getDeclaredTypeOfClassOrInterface(getMergedSymbol((<ClassDeclaration>declaration.parent).symbol)) : undefined;
      const typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration);
      if (hasRestParameter(declaration) || (isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters))) flags |= SignatureFlags.HasRestParameter;
      links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, undefined, undefined, minArgumentCount, flags);
    }
    return links.resolvedSignature;
  }
  function maybeAddJsSyntheticRestParameter(declaration: SignatureDeclaration | JSDocSignature, parameters: Symbol[]): boolean {
    if (qc.is.kind(JSDocSignature, declaration) || !containsArgumentsReference(declaration)) return false;
    const lastParam = lastOrUndefined(declaration.parameters);
    const lastParamTags = lastParam ? qc.getDoc.parameterTags(lastParam) : qc.getDoc.tags(declaration).filter(isJSDocParameterTag);
    const lastParamVariadicType = firstDefined(lastParamTags, (p) => (p.typeExpression && qc.is.kind(JSDocVariadicType, p.typeExpression.type) ? p.typeExpression.type : undefined));
    const syntheticArgsSymbol = new QSymbol(SymbolFlags.Variable, 'args' as __String, CheckFlags.RestParameter);
    syntheticArgsSymbol.type = lastParamVariadicType ? createArrayType(getTypeFromTypeNode(lastParamVariadicType.type)) : anyArrayType;
    if (lastParamVariadicType) parameters.pop();
    parameters.push(syntheticArgsSymbol);
    return true;
  }
  function getSignatureOfTypeTag(node: SignatureDeclaration | JSDocSignature) {
    if (!(isInJSFile(node) && qc.is.functionLikeDeclaration(node))) return;
    const typeTag = qc.getDoc.typeTag(node);
    const signature = typeTag && typeTag.typeExpression && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
    return signature && getErasedSignature(signature);
  }
  function getReturnTypeOfTypeTag(node: SignatureDeclaration | JSDocSignature) {
    const signature = getSignatureOfTypeTag(node);
    return signature && getReturnTypeOfSignature(signature);
  }
  function containsArgumentsReference(declaration: SignatureDeclaration): boolean {
    const links = getNodeLinks(declaration);
    if (links.containsArgumentsReference === undefined) {
      if (links.flags & NodeCheckFlags.CaptureArguments) links.containsArgumentsReference = true;
      else {
        links.containsArgumentsReference = traverse((declaration as FunctionLikeDeclaration).body!);
      }
    }
    return links.containsArgumentsReference;
    function traverse(node: Node): boolean {
      if (!node) return false;
      switch (node.kind) {
        case Syntax.Identifier:
          return (<Identifier>node).escapedText === 'arguments' && qc.is.expressionNode(node);
        case Syntax.PropertyDeclaration:
        case Syntax.MethodDeclaration:
        case Syntax.GetAccessor:
        case Syntax.SetAccessor:
          return (<NamedDeclaration>node).name!.kind === Syntax.ComputedPropertyName && traverse((<NamedDeclaration>node).name!);
        default:
          return !nodeStartsNewLexicalEnvironment(node) && !qc.is.partOfTypeNode(node) && !!qc.forEach.child(node, traverse);
      }
    }
  }
  function getSignaturesOfSymbol(symbol: Symbol | undefined): Signature[] {
    if (!symbol) return empty;
    const result: Signature[] = [];
    for (let i = 0; i < symbol.declarations.length; i++) {
      const decl = symbol.declarations[i];
      if (!qc.is.functionLike(decl)) continue;
      if (i > 0 && (decl as FunctionLikeDeclaration).body) {
        const previous = symbol.declarations[i - 1];
        if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) continue;
      }
      result.push(getSignatureFromDeclaration(decl));
    }
    return result;
  }
  function resolveExternalModuleTypeByLiteral(name: StringLiteral) {
    const moduleSym = resolveExternalModuleName(name, name);
    if (moduleSym) {
      const resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
      if (resolvedModuleSymbol) return getTypeOfSymbol(resolvedModuleSymbol);
    }
    return anyType;
  }
  function getThisTypeOfSignature(signature: Signature): Type | undefined {
    if (signature.thisParameter) return getTypeOfSymbol(signature.thisParameter);
  }
  function getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined {
    if (!signature.resolvedTypePredicate) {
      if (signature.target) {
        const targetTypePredicate = getTypePredicateOfSignature(signature.target);
        signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper!) : noTypePredicate;
      } else if (signature.unionSignatures) {
        signature.resolvedTypePredicate = getUnionTypePredicate(signature.unionSignatures) || noTypePredicate;
      } else {
        const type = signature.declaration && getEffectiveReturnTypeNode(signature.declaration);
        let jsdocPredicate: TypePredicate | undefined;
        if (!type && isInJSFile(signature.declaration)) {
          const jsdocSignature = getSignatureOfTypeTag(signature.declaration!);
          if (jsdocSignature && signature !== jsdocSignature) jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
        }
        signature.resolvedTypePredicate = type && qc.is.kind(TypePredicateNode, type) ? createTypePredicateFromTypePredicateNode(type, signature) : jsdocPredicate || noTypePredicate;
      }
      assert(!!signature.resolvedTypePredicate);
    }
    return signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate;
  }
  function createTypePredicateFromTypePredicateNode(node: TypePredicateNode, signature: Signature): TypePredicate {
    const parameterName = node.parameterName;
    const type = node.type && getTypeFromTypeNode(node.type);
    return parameterName.kind === Syntax.ThisType
      ? createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsThis : TypePredicateKind.This, undefined, type)
      : createTypePredicate(
          node.assertsModifier ? TypePredicateKind.AssertsIdentifier : TypePredicateKind.Identifier,
          parameterName.escapedText as string,
          findIndex(signature.parameters, (p) => p.escName === parameterName.escapedText),
          type
        );
  }
  function getReturnTypeOfSignature(signature: Signature): Type {
    if (!signature.resolvedReturnType) {
      if (!pushTypeResolution(signature, TypeSystemPropertyName.ResolvedReturnType)) return errorType;
      let type = signature.target
        ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper)
        : signature.unionSignatures
        ? getUnionType(map(signature.unionSignatures, getReturnTypeOfSignature), UnionReduction.Subtype)
        : getReturnTypeFromAnnotation(signature.declaration!) ||
          (qc.is.missing((<FunctionLikeDeclaration>signature.declaration).body) ? anyType : getReturnTypeFromBody(<FunctionLikeDeclaration>signature.declaration));
      if (signature.flags & SignatureFlags.IsInnerCallChain) type = addOptionalTypeMarker(type);
      else if (signature.flags & SignatureFlags.IsOuterCallChain) {
        type = getOptionalType(type);
      }
      if (!popTypeResolution()) {
        if (signature.declaration) {
          const typeNode = getEffectiveReturnTypeNode(signature.declaration);
          if (typeNode) error(typeNode, qd.Return_type_annotation_circularly_references_itself);
          else if (noImplicitAny) {
            const declaration = <Declaration>signature.declaration;
            const name = getNameOfDeclaration(declaration);
            if (name) {
              error(
                name,
                qd._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions,
                declarationNameToString(name)
              );
            } else {
              error(
                declaration,
                qd.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions
              );
            }
          }
        }
        type = anyType;
      }
      signature.resolvedReturnType = type;
    }
    return signature.resolvedReturnType;
  }
  function getReturnTypeFromAnnotation(declaration: SignatureDeclaration | JSDocSignature) {
    if (declaration.kind === Syntax.Constructor) return getDeclaredTypeOfClassOrInterface(getMergedSymbol((<ClassDeclaration>declaration.parent).symbol));
    if (qc.isDoc.constructSignature(declaration)) return getTypeFromTypeNode((declaration.parameters[0] as ParameterDeclaration).type!);
    const typeNode = getEffectiveReturnTypeNode(declaration);
    if (typeNode) return getTypeFromTypeNode(typeNode);
    if (declaration.kind === Syntax.GetAccessor && !hasNonBindableDynamicName(declaration)) {
      const jsDocType = isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration);
      if (jsDocType) return jsDocType;
      const setter = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfNode(declaration), Syntax.SetAccessor);
      const setterType = getAnnotatedAccessorType(setter);
      if (setterType) return setterType;
    }
    return getReturnTypeOfTypeTag(declaration);
  }
  function isResolvingReturnTypeOfSignature(signature: Signature) {
    return !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, TypeSystemPropertyName.ResolvedReturnType) >= 0;
  }
  function getRestTypeOfSignature(signature: Signature): Type {
    return tryGetRestTypeOfSignature(signature) || anyType;
  }
  function tryGetRestTypeOfSignature(signature: Signature): Type | undefined {
    if (signatureHasRestParameter(signature)) {
      const sigRestType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
      const restType = isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType;
      return restType && getIndexTypeOfType(restType, IndexKind.Number);
    }
    return;
  }
  function getSignatureInstantiation(signature: Signature, typeArguments: Type[] | undefined, isJavascript: boolean, inferredTypeParameters?: readonly TypeParameter[]): Signature {
    const instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(
      signature,
      fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript)
    );
    if (inferredTypeParameters) {
      const returnSignature = getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature));
      if (returnSignature) {
        const newReturnSignature = cloneSignature(returnSignature);
        newReturnSignature.typeParameters = inferredTypeParameters;
        const newInstantiatedSignature = cloneSignature(instantiatedSignature);
        newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature);
        return newInstantiatedSignature;
      }
    }
    return instantiatedSignature;
  }
  function getSignatureInstantiationWithoutFillingInTypeArguments(signature: Signature, typeArguments: readonly Type[] | undefined): Signature {
    const instantiations = signature.instantiations || (signature.instantiations = new qb.QMap<Signature>());
    const id = getTypeListId(typeArguments);
    let instantiation = instantiations.get(id);
    if (!instantiation) instantiations.set(id, (instantiation = createSignatureInstantiation(signature, typeArguments)));
    return instantiation;
  }
  function createSignatureInstantiation(signature: Signature, typeArguments: readonly Type[] | undefined): Signature {
    return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), true);
  }
  function createSignatureTypeMapper(signature: Signature, typeArguments: readonly Type[] | undefined): TypeMapper {
    return createTypeMapper(signature.typeParameters!, typeArguments);
  }
  function getErasedSignature(signature: Signature): Signature {
    return signature.typeParameters ? signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) : signature;
  }
  function createErasedSignature(signature: Signature) {
    return instantiateSignature(signature, createTypeEraser(signature.typeParameters!), true);
  }
  function getCanonicalSignature(signature: Signature): Signature {
    return signature.typeParameters ? signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) : signature;
  }
  function createCanonicalSignature(signature: Signature) {
    return getSignatureInstantiation(
      signature,
      map(signature.typeParameters, (tp) => (tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp)),
      isInJSFile(signature.declaration)
    );
  }
  function getBaseSignature(signature: Signature) {
    const typeParameters = signature.typeParameters;
    if (typeParameters) {
      const typeEraser = createTypeEraser(typeParameters);
      const baseConstraints = map(typeParameters, (tp) => instantiateType(getBaseConstraintOfType(tp), typeEraser) || unknownType);
      return instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), true);
    }
    return signature;
  }
  function getOrCreateTypeFromSignature(signature: Signature): ObjectType {
    if (!signature.isolatedSignatureType) {
      const kind = signature.declaration ? signature.declaration.kind : Syntax.Unknown;
      const isConstructor = kind === Syntax.Constructor || kind === Syntax.ConstructSignature || kind === Syntax.ConstructorType;
      const type = createObjectType(ObjectFlags.Anonymous);
      type.members = emptySymbols;
      type.properties = empty;
      type.callSignatures = !isConstructor ? [signature] : empty;
      type.constructSignatures = isConstructor ? [signature] : empty;
      signature.isolatedSignatureType = type;
    }
    return signature.isolatedSignatureType;
  }
  function createIndexInfo(type: Type, isReadonly: boolean, declaration?: IndexSignatureDeclaration): IndexInfo {
    return { type, isReadonly, declaration };
  }
  function getConstraintDeclaration(type: TypeParameter): TypeNode | undefined {
    return mapDefined(filter(type.symbol && type.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0];
  }
  function getInferredTypeParameterConstraint(typeParameter: TypeParameter) {
    let inferences: Type[] | undefined;
    if (typeParameter.symbol) {
      for (const declaration of typeParameter.symbol.declarations) {
        if (declaration.parent.kind === Syntax.InferType) {
          const grandParent = declaration.parent.parent;
          if (grandParent.kind === Syntax.TypeReference) {
            const typeReference = <TypeReferenceNode>grandParent;
            const typeParameters = getTypeParametersForTypeReference(typeReference);
            if (typeParameters) {
              const index = typeReference.typeArguments!.indexOf(<TypeNode>declaration.parent);
              if (index < typeParameters.length) {
                const declaredConstraint = getConstraintOfTypeParameter(typeParameters[index]);
                if (declaredConstraint) {
                  const mapper = createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReference, typeParameters));
                  const constraint = instantiateType(declaredConstraint, mapper);
                  if (constraint !== typeParameter) inferences = append(inferences, constraint);
                }
              }
            }
          } else if (grandParent.kind === Syntax.Parameter && (<ParameterDeclaration>grandParent).dot3Token) {
            inferences = append(inferences, createArrayType(unknownType));
          }
        }
      }
    }
    return inferences && getIntersectionType(inferences);
  }
  function getConstraintFromTypeParameter(typeParameter: TypeParameter): Type | undefined {
    if (!typeParameter.constraint) {
      if (typeParameter.target) {
        const targetConstraint = getConstraintOfTypeParameter(typeParameter.target);
        typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType;
      } else {
        const constraintDeclaration = getConstraintDeclaration(typeParameter);
        if (!constraintDeclaration) typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType;
        else {
          let type = getTypeFromTypeNode(constraintDeclaration);
          if (type.flags & TypeFlags.Any && type !== errorType) type = constraintDeclaration.parent.parent.kind === Syntax.MappedType ? keyofConstraintType : unknownType;
          typeParameter.constraint = type;
        }
      }
    }
    return typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint;
  }
  function getParentSymbolOfTypeParameter(typeParameter: TypeParameter): Symbol | undefined {
    const tp = getDeclarationOfKind<TypeParameterDeclaration>(typeParameter.symbol, Syntax.TypeParameter)!;
    const host = qc.is.kind(JSDocTemplateTag, tp.parent) ? getHostSignatureFromJSDoc(tp.parent) : tp.parent;
    return host && getSymbolOfNode(host);
  }
  function getTypeListId(types: readonly Type[] | undefined) {
    let result = '';
    if (types) {
      const length = types.length;
      let i = 0;
      while (i < length) {
        const startId = types[i].id;
        let count = 1;
        while (i + count < length && types[i + count].id === startId + count) {
          count++;
        }
        if (result.length) result += ',';
        result += startId;
        if (count > 1) result += ':' + count;
        i += count;
      }
    }
    return result;
  }
  function getPropagatingFlagsOfTypes(types: readonly Type[], excludeKinds: TypeFlags): ObjectFlags {
    let result: ObjectFlags = 0;
    for (const type of types) {
      if (!(type.flags & excludeKinds)) result |= getObjectFlags(type);
    }
    return result & ObjectFlags.PropagatingFlags;
  }
  function createTypeReference(target: GenericType, typeArguments: readonly Type[] | undefined): TypeReference {
    const id = getTypeListId(typeArguments);
    let type = target.instantiations.get(id);
    if (!type) {
      type = <TypeReference>createObjectType(ObjectFlags.Reference, target.symbol);
      target.instantiations.set(id, type);
      type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments, 0) : 0;
      type.target = target;
      type.resolvedTypeArguments = typeArguments;
    }
    return type;
  }
  function cloneTypeReference(source: TypeReference): TypeReference {
    const type = <TypeReference>createType(source.flags);
    type.symbol = source.symbol;
    type.objectFlags = source.objectFlags;
    type.target = source.target;
    type.resolvedTypeArguments = source.resolvedTypeArguments;
    return type;
  }
  function createDeferredTypeReference(target: GenericType, node: TypeReferenceNode | ArrayTypeNode | TupleTypeNode, mapper?: TypeMapper): DeferredTypeReference {
    const aliasSymbol = getAliasSymbolForTypeNode(node);
    const aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
    const type = <DeferredTypeReference>createObjectType(ObjectFlags.Reference, target.symbol);
    type.target = target;
    type.node = node;
    type.mapper = mapper;
    type.aliasSymbol = aliasSymbol;
    type.aliasTypeArguments = mapper ? instantiateTypes(aliasTypeArguments, mapper) : aliasTypeArguments;
    return type;
  }
  function getTypeArguments(type: TypeReference): readonly Type[] {
    if (!type.resolvedTypeArguments) {
      if (!pushTypeResolution(type, TypeSystemPropertyName.ResolvedTypeArguments)) return type.target.localTypeParameters?.map(() => errorType) || empty;
      const node = type.node;
      const typeArguments = !node
        ? empty
        : node.kind === Syntax.TypeReference
        ? concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters!))
        : node.kind === Syntax.ArrayType
        ? [getTypeFromTypeNode(node.elementType)]
        : map(node.elements, getTypeFromTypeNode);
      if (popTypeResolution()) type.resolvedTypeArguments = type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments;
      else {
        type.resolvedTypeArguments = type.target.localTypeParameters?.map(() => errorType) || empty;
        error(
          type.node || currentNode,
          type.target.symbol ? qd.Type_arguments_for_0_circularly_reference_themselves : qd.Tuple_type_arguments_circularly_reference_themselves,
          type.target.symbol && type.target.symbol.symbolToString()
        );
      }
    }
    return type.resolvedTypeArguments;
  }
  function getTypeReferenceArity(type: TypeReference): number {
    return length(type.target.typeParameters);
  }
  function getTypeFromClassOrInterfaceReference(node: NodeWithTypeArguments, symbol: Symbol): Type {
    const type = <InterfaceType>getDeclaredTypeOfSymbol(getMergedSymbol(symbol));
    const typeParameters = type.localTypeParameters;
    if (typeParameters) {
      const numTypeArguments = length(node.typeArguments);
      const minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
      const isJs = isInJSFile(node);
      const isJsImplicitAny = !noImplicitAny && isJs;
      if (!isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length)) {
        const missingAugmentsTag = isJs && qc.is.kind(ExpressionWithTypeArguments, node) && !qc.is.kind(JSDocAugmentsTag, node.parent);
        const diag =
          minTypeArgumentCount === typeParameters.length
            ? missingAugmentsTag
              ? qd.Expected_0_type_arguments_provide_these_with_an_extends_tag
              : qd.Generic_type_0_requires_1_type_argument_s
            : missingAugmentsTag
            ? qd.Expected_0_1_type_arguments_provide_these_with_an_extends_tag
            : qd.Generic_type_0_requires_between_1_and_2_type_arguments;
        const typeStr = typeToString(type, undefined, TypeFormatFlags.WriteArrayAsGenericType);
        error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length);
        if (!isJs) return errorType;
      }
      if (node.kind === Syntax.TypeReference && isDeferredTypeReferenceNode(<TypeReferenceNode>node, length(node.typeArguments) !== typeParameters.length))
        return createDeferredTypeReference(<GenericType>type, <TypeReferenceNode>node, undefined);
      const typeArguments = concatenate(type.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs));
      return createTypeReference(<GenericType>type, typeArguments);
    }
    return checkNoTypeArguments(node, symbol) ? type : errorType;
  }
  function getTypeAliasInstantiation(symbol: Symbol, typeArguments: readonly Type[] | undefined): Type {
    const type = getDeclaredTypeOfSymbol(symbol);
    const links = s.getLinks(symbol);
    const typeParameters = links.typeParameters!;
    const id = getTypeListId(typeArguments);
    let instantiation = links.instantiations!.get(id);
    if (!instantiation) {
      links.instantiations!.set(
        id,
        (instantiation = instantiateType(
          type,
          createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration)))
        ))
      );
    }
    return instantiation;
  }
  function getTypeFromTypeAliasReference(node: NodeWithTypeArguments, symbol: Symbol): Type {
    const type = getDeclaredTypeOfSymbol(symbol);
    const typeParameters = s.getLinks(symbol).typeParameters;
    if (typeParameters) {
      const numTypeArguments = length(node.typeArguments);
      const minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
      if (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
        error(
          node,
          minTypeArgumentCount === typeParameters.length ? qd.Generic_type_0_requires_1_type_argument_s : qd.Generic_type_0_requires_between_1_and_2_type_arguments,
          symbol.symbolToString(),
          minTypeArgumentCount,
          typeParameters.length
        );
        return errorType;
      }
      return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node));
    }
    return checkNoTypeArguments(node, symbol) ? type : errorType;
  }
  function getTypeReferenceName(node: TypeReferenceType): EntityNameOrEntityNameExpression | undefined {
    switch (node.kind) {
      case Syntax.TypeReference:
        return node.typeName;
      case Syntax.ExpressionWithTypeArguments:
        const expr = node.expression;
        if (isEntityNameExpression(expr)) return expr;
    }
    return;
  }
  function resolveTypeReferenceName(typeReferenceName: EntityNameExpression | EntityName | undefined, meaning: SymbolFlags, ignoreErrors?: boolean) {
    if (!typeReferenceName) return unknownSymbol;
    return resolveEntityName(typeReferenceName, meaning, ignoreErrors) || unknownSymbol;
  }
  function getTypeReferenceType(node: NodeWithTypeArguments, symbol: Symbol): Type {
    if (symbol === unknownSymbol) return errorType;
    symbol = symbol.getExpandoSymbol() || symbol;
    if (symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface)) return getTypeFromClassOrInterfaceReference(node, symbol);
    if (symbol.flags & SymbolFlags.TypeAlias) return getTypeFromTypeAliasReference(node, symbol);
    const res = tryGetDeclaredTypeOfSymbol(symbol);
    if (res) return checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType;
    if (symbol.flags & SymbolFlags.Value && isJSDocTypeReference(node)) {
      const jsdocType = getTypeFromJSDocValueReference(node, symbol);
      if (jsdocType) return jsdocType;
      resolveTypeReferenceName(getTypeReferenceName(node), SymbolFlags.Type);
      return this.getTypeOfSymbol();
    }
    return errorType;
  }
  function getTypeFromJSDocValueReference(node: NodeWithTypeArguments, symbol: Symbol): Type | undefined {
    const links = getNodeLinks(node);
    if (!links.resolvedJSDocType) {
      const valueType = this.getTypeOfSymbol();
      let typeType = valueType;
      if (symbol.valueDeclaration) {
        const decl = getRootDeclaration(symbol.valueDeclaration);
        let isRequireAlias = false;
        if (qc.is.kind(VariableDeclaration, decl) && decl.initializer) {
          let expr = decl.initializer;
          while (qc.is.kind(PropertyAccessExpression, expr)) {
            expr = expr.expression;
          }
          isRequireAlias = qc.is.kind(CallExpression, expr) && isRequireCall(expr, true) && !!valueType.symbol;
        }
        const isImportTypeWithQualifier = node.kind === Syntax.ImportType && (node as ImportTypeNode).qualifier;
        if (valueType.symbol && (isRequireAlias || isImportTypeWithQualifier)) typeType = getTypeReferenceType(node, valueType.symbol);
      }
      links.resolvedJSDocType = typeType;
    }
    return links.resolvedJSDocType;
  }
  function getSubstitutionType(baseType: Type, substitute: Type) {
    if (substitute.flags & TypeFlags.AnyOrUnknown || substitute === baseType) return baseType;
    const id = `${getTypeId(baseType)}>${getTypeId(substitute)}`;
    const cached = substitutionTypes.get(id);
    if (cached) return cached;
    const result = <SubstitutionType>createType(TypeFlags.Substitution);
    result.baseType = baseType;
    result.substitute = substitute;
    substitutionTypes.set(id, result);
    return result;
  }
  function isUnaryTupleTypeNode(node: TypeNode) {
    return node.kind === Syntax.TupleType && (<TupleTypeNode>node).elements.length === 1;
  }
  function getImpliedConstraint(type: Type, checkNode: TypeNode, extendsNode: TypeNode): Type | undefined {
    return isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode)
      ? getImpliedConstraint(type, (<TupleTypeNode>checkNode).elements[0], (<TupleTypeNode>extendsNode).elements[0])
      : getActualTypeVariable(getTypeFromTypeNode(checkNode)) === type
      ? getTypeFromTypeNode(extendsNode)
      : undefined;
  }
  function getConditionalFlowTypeOfType(type: Type, node: Node) {
    let constraints: Type[] | undefined;
    while (node && !qc.is.statement(node) && node.kind !== Syntax.JSDocComment) {
      const parent = node.parent;
      if (parent.kind === Syntax.ConditionalType && node === (<ConditionalTypeNode>parent).trueType) {
        const constraint = getImpliedConstraint(type, (<ConditionalTypeNode>parent).checkType, (<ConditionalTypeNode>parent).extendsType);
        if (constraint) constraints = append(constraints, constraint);
      }
      node = parent;
    }
    return constraints ? getSubstitutionType(type, getIntersectionType(append(constraints, type))) : type;
  }
  function isJSDocTypeReference(node: Node): node is TypeReferenceNode {
    return !!(node.flags & NodeFlags.JSDoc) && (node.kind === Syntax.TypeReference || node.kind === Syntax.ImportType);
  }
  function checkNoTypeArguments(node: NodeWithTypeArguments, symbol?: Symbol) {
    if (node.typeArguments) {
      error(node, qd.Type_0_is_not_generic, symbol ? symbol.symbolToString() : (<TypeReferenceNode>node).typeName ? declarationNameToString((<TypeReferenceNode>node).typeName) : anon);
      return false;
    }
    return true;
  }
  function getIntendedTypeFromJSDocTypeReference(node: TypeReferenceNode): Type | undefined {
    if (qc.is.kind(Identifier, node.typeName)) {
      const typeArgs = node.typeArguments;
      switch (node.typeName.escapedText) {
        case 'String':
          checkNoTypeArguments(node);
          return stringType;
        case 'Number':
          checkNoTypeArguments(node);
          return numberType;
        case 'Boolean':
          checkNoTypeArguments(node);
          return booleanType;
        case 'Void':
          checkNoTypeArguments(node);
          return voidType;
        case 'Undefined':
          checkNoTypeArguments(node);
          return undefinedType;
        case 'Null':
          checkNoTypeArguments(node);
          return nullType;
        case 'Function':
        case 'function':
          checkNoTypeArguments(node);
          return globalFunctionType;
        case 'array':
          return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;
        case 'promise':
          return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined;
        case 'Object':
          if (typeArgs && typeArgs.length === 2) {
            if (isJSDocIndexSignature(node)) {
              const indexed = getTypeFromTypeNode(typeArgs[0]);
              const target = getTypeFromTypeNode(typeArgs[1]);
              const index = createIndexInfo(target, false);
              return createAnonymousType(undefined, emptySymbols, empty, empty, indexed === stringType ? index : undefined, indexed === numberType ? index : undefined);
            }
            return anyType;
          }
          checkNoTypeArguments(node);
          return !noImplicitAny ? anyType : undefined;
      }
    }
  }
  function getTypeFromJSDocNullableTypeNode(node: JSDocNullableType) {
    const type = getTypeFromTypeNode(node.type);
    return strictNullChecks ? getNullableType(type, TypeFlags.Null) : type;
  }
  function getTypeFromTypeReference(node: TypeReferenceType): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      if (qc.is.constTypeReference(node) && qc.is.assertionExpression(node.parent)) {
        links.resolvedSymbol = unknownSymbol;
        return (links.resolvedType = checkExpressionCached(node.parent.expression));
      }
      let symbol: Symbol | undefined;
      let type: Type | undefined;
      const meaning = SymbolFlags.Type;
      if (isJSDocTypeReference(node)) {
        type = getIntendedTypeFromJSDocTypeReference(node);
        if (!type) {
          symbol = resolveTypeReferenceName(getTypeReferenceName(node), meaning, true);
          if (symbol === unknownSymbol) symbol = resolveTypeReferenceName(getTypeReferenceName(node), meaning | SymbolFlags.Value);
          else {
            resolveTypeReferenceName(getTypeReferenceName(node), meaning);
          }
          type = getTypeReferenceType(node, symbol);
        }
      }
      if (!type) {
        symbol = resolveTypeReferenceName(getTypeReferenceName(node), meaning);
        type = getTypeReferenceType(node, symbol);
      }
      links.resolvedSymbol = symbol;
      links.resolvedType = type;
    }
    return links.resolvedType;
  }
  function typeArgumentsFromTypeReferenceNode(node: NodeWithTypeArguments): Type[] | undefined {
    return map(node.typeArguments, getTypeFromTypeNode);
  }
  function getTypeFromTypeQueryNode(node: TypeQueryNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(checkExpression(node.exprName)));
    return links.resolvedType;
  }
  function getTypeOfGlobalSymbol(symbol: Symbol | undefined, arity: number): ObjectType {
    function getTypeDeclaration(symbol: Symbol): Declaration | undefined {
      const declarations = symbol.declarations;
      for (const declaration of declarations) {
        switch (declaration.kind) {
          case Syntax.ClassDeclaration:
          case Syntax.InterfaceDeclaration:
          case Syntax.EnumDeclaration:
            return declaration;
        }
      }
    }
    if (!symbol) return arity ? emptyGenericType : emptyObjectType;
    const type = getDeclaredTypeOfSymbol(symbol);
    if (!(type.flags & TypeFlags.Object)) {
      error(getTypeDeclaration(symbol), qd.Global_type_0_must_be_a_class_or_interface_type, symbol.name);
      return arity ? emptyGenericType : emptyObjectType;
    }
    if (length((<InterfaceType>type).typeParameters) !== arity) {
      error(getTypeDeclaration(symbol), qd.Global_type_0_must_have_1_type_parameter_s, symbol.name, arity);
      return arity ? emptyGenericType : emptyObjectType;
    }
    return <ObjectType>type;
  }
  function getGlobalValueSymbol(name: __String, reportErrors: boolean): Symbol | undefined {
    return getGlobalSymbol(name, SymbolFlags.Value, reportErrors ? qd.Cannot_find_global_value_0 : undefined);
  }
  function getGlobalTypeSymbol(name: __String, reportErrors: boolean): Symbol | undefined {
    return getGlobalSymbol(name, SymbolFlags.Type, reportErrors ? qd.Cannot_find_global_type_0 : undefined);
  }
  function getGlobalSymbol(name: __String, meaning: SymbolFlags, diagnostic: DiagnosticMessage | undefined): Symbol | undefined {
    return resolveName(undefined, name, meaning, diagnostic, name, false);
  }
  function getGlobalType(name: __String, arity: 0, reportErrors: boolean): ObjectType;
  function getGlobalType(name: __String, arity: number, reportErrors: boolean): GenericType;
  function getGlobalType(name: __String, arity: number, reportErrors: boolean): ObjectType | undefined {
    const symbol = getGlobalTypeSymbol(name, reportErrors);
    return symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined;
  }
  function getGlobalTypedPropertyDescriptorType() {
    return deferredGlobalTypedPropertyDescriptorType || (deferredGlobalTypedPropertyDescriptorType = getGlobalType('TypedPropertyDescriptor' as __String, 1, true)) || emptyGenericType;
  }
  function getGlobalTemplateStringsArrayType() {
    return deferredGlobalTemplateStringsArrayType || (deferredGlobalTemplateStringsArrayType = getGlobalType('TemplateStringsArray' as __String, 0, true)) || emptyObjectType;
  }
  function getGlobalImportMetaType() {
    return deferredGlobalImportMetaType || (deferredGlobalImportMetaType = getGlobalType('ImportMeta' as __String, 0, true)) || emptyObjectType;
  }
  function getGlobalESSymbolConstructorSymbol(reportErrors: boolean) {
    return deferredGlobalESSymbolConstructorSymbol || (deferredGlobalESSymbolConstructorSymbol = getGlobalValueSymbol('Symbol' as __String, reportErrors));
  }
  function getGlobalESSymbolType(reportErrors: boolean) {
    return deferredGlobalESSymbolType || (deferredGlobalESSymbolType = getGlobalType('Symbol' as __String, 0, reportErrors)) || emptyObjectType;
  }
  function getGlobalPromiseType(reportErrors: boolean) {
    return deferredGlobalPromiseType || (deferredGlobalPromiseType = getGlobalType('Promise' as __String, 1, reportErrors)) || emptyGenericType;
  }
  function getGlobalPromiseLikeType(reportErrors: boolean) {
    return deferredGlobalPromiseLikeType || (deferredGlobalPromiseLikeType = getGlobalType('PromiseLike' as __String, 1, reportErrors)) || emptyGenericType;
  }
  function getGlobalPromiseConstructorSymbol(reportErrors: boolean): Symbol | undefined {
    return deferredGlobalPromiseConstructorSymbol || (deferredGlobalPromiseConstructorSymbol = getGlobalValueSymbol('Promise' as __String, reportErrors));
  }
  function getGlobalPromiseConstructorLikeType(reportErrors: boolean) {
    return deferredGlobalPromiseConstructorLikeType || (deferredGlobalPromiseConstructorLikeType = getGlobalType('PromiseConstructorLike' as __String, 0, reportErrors)) || emptyObjectType;
  }
  function getGlobalAsyncIterableType(reportErrors: boolean) {
    return deferredGlobalAsyncIterableType || (deferredGlobalAsyncIterableType = getGlobalType('AsyncIterable' as __String, 1, reportErrors)) || emptyGenericType;
  }
  function getGlobalAsyncIteratorType(reportErrors: boolean) {
    return deferredGlobalAsyncIteratorType || (deferredGlobalAsyncIteratorType = getGlobalType('AsyncIterator' as __String, 3, reportErrors)) || emptyGenericType;
  }
  function getGlobalAsyncIterableIteratorType(reportErrors: boolean) {
    return deferredGlobalAsyncIterableIteratorType || (deferredGlobalAsyncIterableIteratorType = getGlobalType('AsyncIterableIterator' as __String, 1, reportErrors)) || emptyGenericType;
  }
  function getGlobalAsyncGeneratorType(reportErrors: boolean) {
    return deferredGlobalAsyncGeneratorType || (deferredGlobalAsyncGeneratorType = getGlobalType('AsyncGenerator' as __String, 3, reportErrors)) || emptyGenericType;
  }
  function getGlobalIterableType(reportErrors: boolean) {
    return deferredGlobalIterableType || (deferredGlobalIterableType = getGlobalType('Iterable' as __String, 1, reportErrors)) || emptyGenericType;
  }
  function getGlobalIteratorType(reportErrors: boolean) {
    return deferredGlobalIteratorType || (deferredGlobalIteratorType = getGlobalType('Iterator' as __String, 3, reportErrors)) || emptyGenericType;
  }
  function getGlobalIterableIteratorType(reportErrors: boolean) {
    return deferredGlobalIterableIteratorType || (deferredGlobalIterableIteratorType = getGlobalType('IterableIterator' as __String, 1, reportErrors)) || emptyGenericType;
  }
  function getGlobalGeneratorType(reportErrors: boolean) {
    return deferredGlobalGeneratorType || (deferredGlobalGeneratorType = getGlobalType('Generator' as __String, 3, reportErrors)) || emptyGenericType;
  }
  function getGlobalIteratorYieldResultType(reportErrors: boolean) {
    return deferredGlobalIteratorYieldResultType || (deferredGlobalIteratorYieldResultType = getGlobalType('IteratorYieldResult' as __String, 1, reportErrors)) || emptyGenericType;
  }
  function getGlobalIteratorReturnResultType(reportErrors: boolean) {
    return deferredGlobalIteratorReturnResultType || (deferredGlobalIteratorReturnResultType = getGlobalType('IteratorReturnResult' as __String, 1, reportErrors)) || emptyGenericType;
  }
  function getGlobalTypeOrUndefined(name: __String, arity = 0): ObjectType | undefined {
    const symbol = getGlobalSymbol(name, SymbolFlags.Type, undefined);
    return symbol && <GenericType>getTypeOfGlobalSymbol(symbol, arity);
  }
  function getGlobalExtractSymbol(): Symbol {
    return deferredGlobalExtractSymbol || (deferredGlobalExtractSymbol = getGlobalSymbol('Extract' as __String, SymbolFlags.TypeAlias, qd.Cannot_find_global_type_0)!);
  }
  function getGlobalOmitSymbol(): Symbol {
    return deferredGlobalOmitSymbol || (deferredGlobalOmitSymbol = getGlobalSymbol('Omit' as __String, SymbolFlags.TypeAlias, qd.Cannot_find_global_type_0)!);
  }
  function getGlobalBigIntType(reportErrors: boolean) {
    return deferredGlobalBigIntType || (deferredGlobalBigIntType = getGlobalType('BigInt' as __String, 0, reportErrors)) || emptyObjectType;
  }
  function createTypeFromGenericGlobalType(genericGlobalType: GenericType, typeArguments: readonly Type[]): ObjectType {
    return genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType;
  }
  function createTypedPropertyDescriptorType(propertyType: Type): Type {
    return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), [propertyType]);
  }
  function createIterableType(iteratedType: Type): Type {
    return createTypeFromGenericGlobalType(getGlobalIterableType(true), [iteratedType]);
  }
  function createArrayType(elementType: Type, readonly?: boolean): ObjectType {
    return createTypeFromGenericGlobalType(readonly ? globalReadonlyArrayType : globalArrayType, [elementType]);
  }
  function isTupleRestElement(node: TypeNode) {
    return node.kind === Syntax.RestType || (node.kind === Syntax.NamedTupleMember && !!(node as NamedTupleMember).dot3Token);
  }
  function isTupleOptionalElement(node: TypeNode) {
    return node.kind === Syntax.OptionalType || (node.kind === Syntax.NamedTupleMember && !!(node as NamedTupleMember).questionToken);
  }
  function getArrayOrTupleTargetType(node: ArrayTypeNode | TupleTypeNode): GenericType {
    const readonly = isReadonlyTypeOperator(node.parent);
    if (node.kind === Syntax.ArrayType || (node.elements.length === 1 && isTupleRestElement(node.elements[0]))) return readonly ? globalReadonlyArrayType : globalArrayType;
    const lastElement = lastOrUndefined(node.elements);
    const restElement = lastElement && isTupleRestElement(lastElement) ? lastElement : undefined;
    const minLength = findLastIndex(node.elements, (n) => !isTupleOptionalElement(n) && n !== restElement) + 1;
    const missingName = some(node.elements, (e) => e.kind !== Syntax.NamedTupleMember);
    return getTupleTypeOfArity(node.elements.length, minLength, !!restElement, readonly, missingName ? undefined : (node.elements as readonly NamedTupleMember[]));
  }
  function isDeferredTypeReferenceNode(node: TypeReferenceNode | ArrayTypeNode | TupleTypeNode, hasDefaultTypeArguments?: boolean) {
    return (
      !!getAliasSymbolForTypeNode(node) ||
      (isResolvedByTypeAlias(node) &&
        (node.kind === Syntax.ArrayType
          ? mayResolveTypeAlias(node.elementType)
          : node.kind === Syntax.TupleType
          ? some(node.elements, mayResolveTypeAlias)
          : hasDefaultTypeArguments || some(node.typeArguments, mayResolveTypeAlias)))
    );
  }
  function isResolvedByTypeAlias(node: Node): boolean {
    const parent = node.parent;
    switch (parent.kind) {
      case Syntax.ParenthesizedType:
      case Syntax.NamedTupleMember:
      case Syntax.TypeReference:
      case Syntax.UnionType:
      case Syntax.IntersectionType:
      case Syntax.IndexedAccessType:
      case Syntax.ConditionalType:
      case Syntax.TypeOperator:
      case Syntax.ArrayType:
      case Syntax.TupleType:
        return isResolvedByTypeAlias(parent);
      case Syntax.TypeAliasDeclaration:
        return true;
    }
    return false;
  }
  function mayResolveTypeAlias(node: Node): boolean {
    switch (node.kind) {
      case Syntax.TypeReference:
        return isJSDocTypeReference(node) || !!(resolveTypeReferenceName((<TypeReferenceNode>node).typeName, SymbolFlags.Type).flags & SymbolFlags.TypeAlias);
      case Syntax.TypeQuery:
        return true;
      case Syntax.TypeOperator:
        return (<TypeOperatorNode>node).operator !== Syntax.UniqueKeyword && mayResolveTypeAlias((<TypeOperatorNode>node).type);
      case Syntax.ParenthesizedType:
      case Syntax.OptionalType:
      case Syntax.NamedTupleMember:
      case Syntax.JSDocOptionalType:
      case Syntax.JSDocNullableType:
      case Syntax.JSDocNonNullableType:
      case Syntax.JSDocTypeExpression:
        return mayResolveTypeAlias((<ParenthesizedTypeNode | OptionalTypeNode | JSDocTypeReferencingNode | NamedTupleMember>node).type);
      case Syntax.RestType:
        return (<RestTypeNode>node).type.kind !== Syntax.ArrayType || mayResolveTypeAlias((<ArrayTypeNode>(<RestTypeNode>node).type).elementType);
      case Syntax.UnionType:
      case Syntax.IntersectionType:
        return some((<UnionOrIntersectionTypeNode>node).types, mayResolveTypeAlias);
      case Syntax.IndexedAccessType:
        return mayResolveTypeAlias((<IndexedAccessTypeNode>node).objectType) || mayResolveTypeAlias((<IndexedAccessTypeNode>node).indexType);
      case Syntax.ConditionalType:
        return (
          mayResolveTypeAlias((<ConditionalTypeNode>node).checkType) ||
          mayResolveTypeAlias((<ConditionalTypeNode>node).extendsType) ||
          mayResolveTypeAlias((<ConditionalTypeNode>node).trueType) ||
          mayResolveTypeAlias((<ConditionalTypeNode>node).falseType)
        );
    }
    return false;
  }
  function getTypeFromArrayOrTupleTypeNode(node: ArrayTypeNode | TupleTypeNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      const target = getArrayOrTupleTargetType(node);
      if (target === emptyGenericType) links.resolvedType = emptyObjectType;
      else if (isDeferredTypeReferenceNode(node)) {
        links.resolvedType = node.kind === Syntax.TupleType && node.elements.length === 0 ? target : createDeferredTypeReference(target, node, undefined);
      } else {
        const elementTypes = node.kind === Syntax.ArrayType ? [getTypeFromTypeNode(node.elementType)] : map(node.elements, getTypeFromTypeNode);
        links.resolvedType = createTypeReference(target, elementTypes);
      }
    }
    return links.resolvedType;
  }
  function isReadonlyTypeOperator(node: Node) {
    return qc.is.kind(TypeOperatorNode, node) && node.operator === Syntax.ReadonlyKeyword;
  }
  function createTupleTypeOfArity(
    arity: number,
    minLength: number,
    hasRestElement: boolean,
    readonly: boolean,
    namedMemberDeclarations: readonly (NamedTupleMember | ParameterDeclaration)[] | undefined
  ): TupleType {
    let typeParameters: TypeParameter[] | undefined;
    const properties: Symbol[] = [];
    const maxLength = hasRestElement ? arity - 1 : arity;
    if (arity) {
      typeParameters = new Array(arity);
      for (let i = 0; i < arity; i++) {
        const typeParameter = (typeParameters[i] = createTypeParameter());
        if (i < maxLength) {
          const property = new QSymbol(SymbolFlags.Property | (i >= minLength ? SymbolFlags.Optional : 0), ('' + i) as __String, readonly ? CheckFlags.Readonly : 0);
          property.tupleLabelDeclaration = namedMemberDeclarations?.[i];
          property.type = typeParameter;
          properties.push(property);
        }
      }
    }
    const literalTypes = [];
    for (let i = minLength; i <= maxLength; i++) literalTypes.push(getLiteralType(i));
    const lengthSymbol = new QSymbol(SymbolFlags.Property, 'length' as __String);
    lengthSymbol.type = hasRestElement ? numberType : getUnionType(literalTypes);
    properties.push(lengthSymbol);
    const type = <TupleType & InterfaceTypeWithDeclaredMembers>createObjectType(ObjectFlags.Tuple | ObjectFlags.Reference);
    type.typeParameters = typeParameters;
    type.outerTypeParameters = undefined;
    type.localTypeParameters = typeParameters;
    type.instantiations = new qb.QMap<TypeReference>();
    type.instantiations.set(getTypeListId(type.typeParameters), <GenericType>type);
    type.target = <GenericType>type;
    type.resolvedTypeArguments = type.typeParameters;
    type.thisType = createTypeParameter();
    type.thisType.isThisType = true;
    type.thisType.constraint = type;
    type.declaredProperties = properties;
    type.declaredCallSignatures = empty;
    type.declaredConstructSignatures = empty;
    type.declaredStringIndexInfo = undefined;
    type.declaredNumberIndexInfo = undefined;
    type.minLength = minLength;
    type.hasRestElement = hasRestElement;
    type.readonly = readonly;
    type.labeledElementDeclarations = namedMemberDeclarations;
    return type;
  }
  function getTupleTypeOfArity(
    arity: number,
    minLength: number,
    hasRestElement: boolean,
    readonly: boolean,
    namedMemberDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[]
  ): GenericType {
    const key =
      arity +
      (hasRestElement ? '+' : ',') +
      minLength +
      (readonly ? 'R' : '') +
      (namedMemberDeclarations && namedMemberDeclarations.length ? ',' + map(namedMemberDeclarations, getNodeId).join(',') : '');
    let type = tupleTypes.get(key);
    if (!type) tupleTypes.set(key, (type = createTupleTypeOfArity(arity, minLength, hasRestElement, readonly, namedMemberDeclarations)));
    return type;
  }
  function createTupleType(
    elementTypes: readonly Type[],
    minLength = elementTypes.length,
    hasRestElement = false,
    readonly = false,
    namedMemberDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[]
  ) {
    const arity = elementTypes.length;
    if (arity === 1 && hasRestElement) return createArrayType(elementTypes[0], readonly);
    const tupleType = getTupleTypeOfArity(arity, minLength, arity > 0 && hasRestElement, readonly, namedMemberDeclarations);
    return elementTypes.length ? createTypeReference(tupleType, elementTypes) : tupleType;
  }
  function sliceTupleType(type: TupleTypeReference, index: number) {
    const tuple = type.target;
    if (tuple.hasRestElement) index = Math.min(index, getTypeReferenceArity(type) - 1);
    return createTupleType(
      getTypeArguments(type).slice(index),
      Math.max(0, tuple.minLength - index),
      tuple.hasRestElement,
      tuple.readonly,
      tuple.labeledElementDeclarations && tuple.labeledElementDeclarations.slice(index)
    );
  }
  function getTypeFromOptionalTypeNode(node: OptionalTypeNode): Type {
    const type = getTypeFromTypeNode(node.type);
    return strictNullChecks ? getOptionalType(type) : type;
  }
  function getTypeId(type: Type) {
    return type.id;
  }
  function containsType(types: readonly Type[], type: Type): boolean {
    return binarySearch(types, type, getTypeId, compareValues) >= 0;
  }
  function insertType(types: Type[], type: Type): boolean {
    const index = binarySearch(types, type, getTypeId, compareValues);
    if (index < 0) {
      types.splice(~index, 0, type);
      return true;
    }
    return false;
  }
  function addTypeToUnion(typeSet: Type[], includes: TypeFlags, type: Type) {
    const flags = type.flags;
    if (flags & TypeFlags.Union) return addTypesToUnion(typeSet, includes, (<UnionType>type).types);
    if (!(flags & TypeFlags.Never)) {
      includes |= flags & TypeFlags.IncludesMask;
      if (flags & TypeFlags.StructuredOrInstantiable) includes |= TypeFlags.IncludesStructuredOrInstantiable;
      if (type === wildcardType) includes |= TypeFlags.IncludesWildcard;
      if (!strictNullChecks && flags & TypeFlags.Nullable)
        if (!(getObjectFlags(type) & ObjectFlags.ContainsWideningType)) includes |= TypeFlags.IncludesNonWideningType;
        else {
          const len = typeSet.length;
          const index = len && type.id > typeSet[len - 1].id ? ~len : binarySearch(typeSet, type, getTypeId, compareValues);
          if (index < 0) typeSet.splice(~index, 0, type);
        }
    }
    return includes;
  }
  function addTypesToUnion(typeSet: Type[], includes: TypeFlags, types: readonly Type[]): TypeFlags {
    for (const type of types) {
      includes = addTypeToUnion(typeSet, includes, type);
    }
    return includes;
  }
  function isSetOfLiteralsFromSameEnum(types: readonly Type[]): boolean {
    const first = types[0];
    if (first.flags & TypeFlags.EnumLiteral) {
      const firstEnum = getParentOfSymbol(first.symbol);
      for (let i = 1; i < types.length; i++) {
        const other = types[i];
        if (!(other.flags & TypeFlags.EnumLiteral) || firstEnum !== getParentOfSymbol(other.symbol)) return false;
      }
      return true;
    }
    return false;
  }
  function removeSubtypes(types: Type[], primitivesOnly: boolean): boolean {
    const len = types.length;
    if (len === 0 || isSetOfLiteralsFromSameEnum(types)) return true;
    let i = len;
    let count = 0;
    while (i > 0) {
      i--;
      const source = types[i];
      for (const target of types) {
        if (source !== target) {
          if (count === 100000) {
            const estimatedCount = (count / (len - i)) * len;
            if (estimatedCount > (primitivesOnly ? 25000000 : 1000000)) {
              error(currentNode, qd.Expression_produces_a_union_type_that_is_too_complex_to_represent);
              return false;
            }
          }
          count++;
          if (
            isTypeRelatedTo(source, target, strictSubtypeRelation) &&
            (!(getObjectFlags(getTargetType(source)) & ObjectFlags.Class) || !(getObjectFlags(getTargetType(target)) & ObjectFlags.Class) || isTypeDerivedFrom(source, target))
          ) {
            orderedRemoveItemAt(types, i);
            break;
          }
        }
      }
    }
    return true;
  }
  function removeRedundantLiteralTypes(types: Type[], includes: TypeFlags) {
    let i = types.length;
    while (i > 0) {
      i--;
      const t = types[i];
      const remove =
        (t.flags & TypeFlags.StringLiteral && includes & TypeFlags.String) ||
        (t.flags & TypeFlags.NumberLiteral && includes & TypeFlags.Number) ||
        (t.flags & TypeFlags.BigIntLiteral && includes & TypeFlags.BigInt) ||
        (t.flags & TypeFlags.UniqueESSymbol && includes & TypeFlags.ESSymbol) ||
        (isFreshLiteralType(t) && containsType(types, (<LiteralType>t).regularType));
      if (remove) orderedRemoveItemAt(types, i);
    }
  }
  function getUnionType(types: readonly Type[], unionReduction: UnionReduction = UnionReduction.Literal, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
    if (types.length === 0) return neverType;
    if (types.length === 1) return types[0];
    const typeSet: Type[] = [];
    const includes = addTypesToUnion(typeSet, 0, types);
    if (unionReduction !== UnionReduction.None) {
      if (includes & TypeFlags.AnyOrUnknown) return includes & TypeFlags.Any ? (includes & TypeFlags.IncludesWildcard ? wildcardType : anyType) : unknownType;
      switch (unionReduction) {
        case UnionReduction.Literal:
          if (includes & (TypeFlags.Literal | TypeFlags.UniqueESSymbol)) removeRedundantLiteralTypes(typeSet, includes);
          break;
        case UnionReduction.Subtype:
          if (!removeSubtypes(typeSet, !(includes & TypeFlags.IncludesStructuredOrInstantiable))) return errorType;
          break;
      }
      if (typeSet.length === 0) {
        return includes & TypeFlags.Null
          ? includes & TypeFlags.IncludesNonWideningType
            ? nullType
            : nullWideningType
          : includes & TypeFlags.Undefined
          ? includes & TypeFlags.IncludesNonWideningType
            ? undefinedType
            : undefinedWideningType
          : neverType;
      }
    }
    const objectFlags = (includes & TypeFlags.NotPrimitiveUnion ? 0 : ObjectFlags.PrimitiveUnion) | (includes & TypeFlags.Intersection ? ObjectFlags.ContainsIntersections : 0);
    return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments);
  }
  function getUnionTypePredicate(signatures: readonly Signature[]): TypePredicate | undefined {
    let first: TypePredicate | undefined;
    const types: Type[] = [];
    for (const sig of signatures) {
      const pred = getTypePredicateOfSignature(sig);
      if (!pred || pred.kind === TypePredicateKind.AssertsThis || pred.kind === TypePredicateKind.AssertsIdentifier) continue;
      if (first) {
        if (!typePredicateKindsMatch(first, pred)) return;
      } else {
        first = pred;
      }
      types.push(pred.type);
    }
    if (!first) return;
    const unionType = getUnionType(types);
    return createTypePredicate(first.kind, first.parameterName, first.parameterIndex, unionType);
  }
  function typePredicateKindsMatch(a: TypePredicate, b: TypePredicate): boolean {
    return a.kind === b.kind && a.parameterIndex === b.parameterIndex;
  }
  function getUnionTypeFromSortedList(types: Type[], objectFlags: ObjectFlags, aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
    if (types.length === 0) return neverType;
    if (types.length === 1) return types[0];
    const id = getTypeListId(types);
    let type = unionTypes.get(id);
    if (!type) {
      type = <UnionType>createType(TypeFlags.Union);
      unionTypes.set(id, type);
      type.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, TypeFlags.Nullable);
      type.types = types;
      type.aliasSymbol = aliasSymbol;
      type.aliasTypeArguments = aliasTypeArguments;
    }
    return type;
  }
  function getTypeFromUnionTypeNode(node: UnionTypeNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      const aliasSymbol = getAliasSymbolForTypeNode(node);
      links.resolvedType = getUnionType(map(node.types, getTypeFromTypeNode), UnionReduction.Literal, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
    }
    return links.resolvedType;
  }
  function addTypeToIntersection(typeSet: qb.QMap<Type>, includes: TypeFlags, type: Type) {
    const flags = type.flags;
    if (flags & TypeFlags.Intersection) return addTypesToIntersection(typeSet, includes, (<IntersectionType>type).types);
    if (isEmptyAnonymousObjectType(type)) {
      if (!(includes & TypeFlags.IncludesEmptyObject)) {
        includes |= TypeFlags.IncludesEmptyObject;
        typeSet.set(type.id.toString(), type);
      }
    } else {
      if (flags & TypeFlags.AnyOrUnknown)
        if (type === wildcardType) includes |= TypeFlags.IncludesWildcard;
        else if ((strictNullChecks || !(flags & TypeFlags.Nullable)) && !typeSet.has(type.id.toString())) {
          if (type.flags & TypeFlags.Unit && includes & TypeFlags.Unit) includes |= TypeFlags.NonPrimitive;
          typeSet.set(type.id.toString(), type);
        }
      includes |= flags & TypeFlags.IncludesMask;
    }
    return includes;
  }
  function addTypesToIntersection(typeSet: qb.QMap<Type>, includes: TypeFlags, types: readonly Type[]) {
    for (const type of types) {
      includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type));
    }
    return includes;
  }
  function removeRedundantPrimitiveTypes(types: Type[], includes: TypeFlags) {
    let i = types.length;
    while (i > 0) {
      i--;
      const t = types[i];
      const remove =
        (t.flags & TypeFlags.String && includes & TypeFlags.StringLiteral) ||
        (t.flags & TypeFlags.Number && includes & TypeFlags.NumberLiteral) ||
        (t.flags & TypeFlags.BigInt && includes & TypeFlags.BigIntLiteral) ||
        (t.flags & TypeFlags.ESSymbol && includes & TypeFlags.UniqueESSymbol);
      if (remove) orderedRemoveItemAt(types, i);
    }
  }
  function eachUnionContains(unionTypes: UnionType[], type: Type) {
    for (const u of unionTypes) {
      if (!containsType(u.types, type)) {
        const primitive =
          type.flags & TypeFlags.StringLiteral
            ? stringType
            : type.flags & TypeFlags.NumberLiteral
            ? numberType
            : type.flags & TypeFlags.BigIntLiteral
            ? bigintType
            : type.flags & TypeFlags.UniqueESSymbol
            ? esSymbolType
            : undefined;
        if (!primitive || !containsType(u.types, primitive)) return false;
      }
    }
    return true;
  }
  function extractIrreducible(types: Type[], flag: TypeFlags) {
    if (every(types, (t) => !!(t.flags & TypeFlags.Union) && some((t as UnionType).types, (tt) => !!(tt.flags & flag)))) {
      for (let i = 0; i < types.length; i++) {
        types[i] = filterType(types[i], (t) => !(t.flags & flag));
      }
      return true;
    }
    return false;
  }
  function intersectUnionsOfPrimitiveTypes(types: Type[]) {
    let unionTypes: UnionType[] | undefined;
    const index = findIndex(types, (t) => !!(getObjectFlags(t) & ObjectFlags.PrimitiveUnion));
    if (index < 0) return false;
    let i = index + 1;
    while (i < types.length) {
      const t = types[i];
      if (getObjectFlags(t) & ObjectFlags.PrimitiveUnion) {
        (unionTypes || (unionTypes = [<UnionType>types[index]])).push(<UnionType>t);
        orderedRemoveItemAt(types, i);
      } else {
        i++;
      }
    }
    if (!unionTypes) return false;
    const checked: Type[] = [];
    const result: Type[] = [];
    for (const u of unionTypes) {
      for (const t of u.types) {
        if (insertType(checked, t)) {
          if (eachUnionContains(unionTypes, t)) insertType(result, t);
        }
      }
    }
    types[index] = getUnionTypeFromSortedList(result, ObjectFlags.PrimitiveUnion);
    return true;
  }
  function createIntersectionType(types: Type[], aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]) {
    const result = <IntersectionType>createType(TypeFlags.Intersection);
    result.objectFlags = getPropagatingFlagsOfTypes(types, TypeFlags.Nullable);
    result.types = types;
    result.aliasSymbol = aliasSymbol;
    result.aliasTypeArguments = aliasTypeArguments;
    return result;
  }
  function getIntersectionType(types: readonly Type[], aliasSymbol?: Symbol, aliasTypeArguments?: readonly Type[]): Type {
    const typeMembershipMap: qb.QMap<Type> = new qb.QMap();
    const includes = addTypesToIntersection(typeMembershipMap, 0, types);
    const typeSet: Type[] = arrayFrom(typeMembershipMap.values());
    if (
      includes & TypeFlags.Never ||
      (strictNullChecks && includes & TypeFlags.Nullable && includes & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.IncludesEmptyObject)) ||
      (includes & TypeFlags.NonPrimitive && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NonPrimitive)) ||
      (includes & TypeFlags.StringLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.StringLike)) ||
      (includes & TypeFlags.NumberLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.NumberLike)) ||
      (includes & TypeFlags.BigIntLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.BigIntLike)) ||
      (includes & TypeFlags.ESSymbolLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.ESSymbolLike)) ||
      (includes & TypeFlags.VoidLike && includes & (TypeFlags.DisjointDomains & ~TypeFlags.VoidLike))
    ) {
      return neverType;
    }
    if (includes & TypeFlags.Any) return includes & TypeFlags.IncludesWildcard ? wildcardType : anyType;
    if (!strictNullChecks && includes & TypeFlags.Nullable) return includes & TypeFlags.Undefined ? undefinedType : nullType;
    if (
      (includes & TypeFlags.String && includes & TypeFlags.StringLiteral) ||
      (includes & TypeFlags.Number && includes & TypeFlags.NumberLiteral) ||
      (includes & TypeFlags.BigInt && includes & TypeFlags.BigIntLiteral) ||
      (includes & TypeFlags.ESSymbol && includes & TypeFlags.UniqueESSymbol)
    ) {
      removeRedundantPrimitiveTypes(typeSet, includes);
    }
    if (includes & TypeFlags.IncludesEmptyObject && includes & TypeFlags.Object) orderedRemoveItemAt(typeSet, findIndex(typeSet, isEmptyAnonymousObjectType));
    if (typeSet.length === 0) return unknownType;
    if (typeSet.length === 1) return typeSet[0];
    const id = getTypeListId(typeSet);
    let result = intersectionTypes.get(id);
    if (!result) {
      if (includes & TypeFlags.Union) {
        if (intersectUnionsOfPrimitiveTypes(typeSet)) result = getIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
        else if (extractIrreducible(typeSet, TypeFlags.Undefined)) {
          result = getUnionType([getIntersectionType(typeSet), undefinedType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments);
        } else if (extractIrreducible(typeSet, TypeFlags.Null)) {
          result = getUnionType([getIntersectionType(typeSet), nullType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments);
        } else {
          const size = reduceLeft(typeSet, (n, t) => n * (t.flags & TypeFlags.Union ? (<UnionType>t).types.length : 1), 1);
          if (size >= 100000) {
            error(currentNode, qd.Expression_produces_a_union_type_that_is_too_complex_to_represent);
            return errorType;
          }
          const unionIndex = findIndex(typeSet, (t) => (t.flags & TypeFlags.Union) !== 0);
          const unionType = <UnionType>typeSet[unionIndex];
          result = getUnionType(
            map(unionType.types, (t) => getIntersectionType(replaceElement(typeSet, unionIndex, t))),
            UnionReduction.Literal,
            aliasSymbol,
            aliasTypeArguments
          );
        }
      } else {
        result = createIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
      }
      intersectionTypes.set(id, result);
    }
    return result;
  }
  function getTypeFromIntersectionTypeNode(node: IntersectionTypeNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      const aliasSymbol = getAliasSymbolForTypeNode(node);
      links.resolvedType = getIntersectionType(map(node.types, getTypeFromTypeNode), aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
    }
    return links.resolvedType;
  }
  function createIndexType(type: InstantiableType | UnionOrIntersectionType, stringsOnly: boolean) {
    const result = <IndexType>createType(TypeFlags.Index);
    result.type = type;
    result.stringsOnly = stringsOnly;
    return result;
  }
  function getIndexTypeForGenericType(type: InstantiableType | UnionOrIntersectionType, stringsOnly: boolean) {
    return stringsOnly
      ? type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, true))
      : type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, false));
  }
  function getLiteralTypeFromPropertyName(name: PropertyName) {
    if (qc.is.kind(PrivateIdentifier, name)) return neverType;
    return qc.is.kind(Identifier, name)
      ? getLiteralType(syntax.get.unescUnderscores(name.escapedText))
      : getRegularTypeOfLiteralType(qc.is.kind(ComputedPropertyName, name) ? checkComputedPropertyName(name) : checkExpression(name));
  }
  function getBigIntLiteralType(node: BigIntLiteral): LiteralType {
    return getLiteralType({
      negative: false,
      base10Value: parsePseudoBigInt(node.text),
    });
  }
  function getLiteralTypeFromProperty(prop: Symbol, include: TypeFlags) {
    if (!(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlags.NonPublicAccessibilityModifier)) {
      let type = s.getLinks(getLateBoundSymbol(prop)).nameType;
      if (!type && !isKnownSymbol(prop)) {
        if (prop.escName === InternalSymbolName.Default) type = getLiteralType('default');
        else {
          const name = prop.valueDeclaration && (getNameOfDeclaration(prop.valueDeclaration) as PropertyName);
          type = (name && getLiteralTypeFromPropertyName(name)) || getLiteralType(prop.name);
        }
      }
      if (type && type.flags & include) return type;
    }
    return neverType;
  }
  function getLiteralTypeFromProperties(type: Type, include: TypeFlags) {
    return getUnionType(map(getPropertiesOfType(type), (p) => getLiteralTypeFromProperty(p, include)));
  }
  function getNonEnumNumberIndexInfo(type: Type) {
    const numberIndexInfo = getIndexInfoOfType(type, IndexKind.Number);
    return numberIndexInfo !== enumNumberIndexInfo ? numberIndexInfo : undefined;
  }
  function getIndexType(type: Type, stringsOnly = keyofStringsOnly, noIndexSignatures?: boolean): Type {
    type = getReducedType(type);
    return type.flags & TypeFlags.Union
      ? getIntersectionType(map((<IntersectionType>type).types, (t) => getIndexType(t, stringsOnly, noIndexSignatures)))
      : type.flags & TypeFlags.Intersection
      ? getUnionType(map((<IntersectionType>type).types, (t) => getIndexType(t, stringsOnly, noIndexSignatures)))
      : maybeTypeOfKind(type, TypeFlags.InstantiableNonPrimitive)
      ? getIndexTypeForGenericType(<InstantiableType | UnionOrIntersectionType>type, stringsOnly)
      : getObjectFlags(type) & ObjectFlags.Mapped
      ? filterType(getConstraintTypeFromMappedType(<MappedType>type), (t) => !(noIndexSignatures && t.flags & (TypeFlags.Any | TypeFlags.String)))
      : type === wildcardType
      ? wildcardType
      : type.flags & TypeFlags.Unknown
      ? neverType
      : type.flags & (TypeFlags.Any | TypeFlags.Never)
      ? keyofConstraintType
      : stringsOnly
      ? !noIndexSignatures && getIndexInfoOfType(type, IndexKind.String)
        ? stringType
        : getLiteralTypeFromProperties(type, TypeFlags.StringLiteral)
      : !noIndexSignatures && getIndexInfoOfType(type, IndexKind.String)
      ? getUnionType([stringType, numberType, getLiteralTypeFromProperties(type, TypeFlags.UniqueESSymbol)])
      : getNonEnumNumberIndexInfo(type)
      ? getUnionType([numberType, getLiteralTypeFromProperties(type, TypeFlags.StringLiteral | TypeFlags.UniqueESSymbol)])
      : getLiteralTypeFromProperties(type, TypeFlags.StringOrNumberLiteralOrUnique);
  }
  function getExtractStringType(type: Type) {
    if (keyofStringsOnly) return type;
    const extractTypeAlias = getGlobalExtractSymbol();
    return extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType;
  }
  function getIndexTypeOrString(type: Type): Type {
    const indexType = getExtractStringType(getIndexType(type));
    return indexType.flags & TypeFlags.Never ? stringType : indexType;
  }
  function getTypeFromTypeOperatorNode(node: TypeOperatorNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      switch (node.operator) {
        case Syntax.KeyOfKeyword:
          links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));
          break;
        case Syntax.UniqueKeyword:
          links.resolvedType = node.type.kind === Syntax.SymbolKeyword ? getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(node.parent)) : errorType;
          break;
        case Syntax.ReadonlyKeyword:
          links.resolvedType = getTypeFromTypeNode(node.type);
          break;
        default:
          throw Debug.assertNever(node.operator);
      }
    }
    return links.resolvedType;
  }
  function createIndexedAccessType(objectType: Type, indexType: Type) {
    const type = <IndexedAccessType>createType(TypeFlags.IndexedAccess);
    type.objectType = objectType;
    type.indexType = indexType;
    return type;
  }
  function isJSLiteralType(type: Type): boolean {
    if (noImplicitAny) return false;
    if (getObjectFlags(type) & ObjectFlags.JSLiteral) return true;
    if (type.flags & TypeFlags.Union) return every((type as UnionType).types, isJSLiteralType);
    if (type.flags & TypeFlags.Intersection) return some((type as IntersectionType).types, isJSLiteralType);
    if (type.flags & TypeFlags.Instantiable) return isJSLiteralType(getResolvedBaseConstraint(type));
    return false;
  }
  function getPropertyNameFromIndex(
    indexType: Type,
    accessNode:
      | StringLiteral
      | Identifier
      | PrivateIdentifier
      | ObjectBindingPattern
      | ArrayBindingPattern
      | ComputedPropertyName
      | NumericLiteral
      | IndexedAccessTypeNode
      | ElementAccessExpression
      | SyntheticExpression
      | undefined
  ) {
    const accessExpression = accessNode && accessNode.kind === Syntax.ElementAccessExpression ? accessNode : undefined;
    return isTypeUsableAsPropertyName(indexType)
      ? getPropertyNameFromType(indexType)
      : accessExpression && checkThatExpressionIsProperSymbolReference(accessExpression.argumentExpression, indexType, false)
      ? getPropertyNameForKnownSymbolName(idText((<PropertyAccessExpression>accessExpression.argumentExpression).name))
      : accessNode && qc.is.propertyName(accessNode)
      ? getPropertyNameForPropertyNameNode(accessNode)
      : undefined;
  }
  function getPropertyTypeForIndexType(
    originalObjectType: Type,
    objectType: Type,
    indexType: Type,
    fullIndexType: Type,
    suppressNoImplicitAnyError: boolean,
    accessNode: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression | undefined,
    accessFlags: AccessFlags
  ) {
    const accessExpression = accessNode && accessNode.kind === Syntax.ElementAccessExpression ? accessNode : undefined;
    const propName = accessNode && qc.is.kind(PrivateIdentifier, accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode);
    if (propName !== undefined) {
      const prop = getPropertyOfType(objectType, propName);
      if (prop) {
        if (accessExpression) {
          markPropertyAsReferenced(prop, accessExpression, accessExpression.expression.kind === Syntax.ThisKeyword);
          if (isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression))) {
            error(accessExpression.argumentExpression, qd.Cannot_assign_to_0_because_it_is_a_read_only_property, prop.symbolToString());
            return;
          }
          if (accessFlags & AccessFlags.CacheSymbol) getNodeLinks(accessNode!).resolvedSymbol = prop;
          if (isThisPropertyAccessInConstructor(accessExpression, prop)) return autoType;
        }
        const propType = getTypeOfSymbol(prop);
        return accessExpression && getAssignmentTargetKind(accessExpression) !== AssignmentKind.Definite ? getFlowTypeOfReference(accessExpression, propType) : propType;
      }
      if (everyType(objectType, isTupleType) && NumericLiteral.name(propName) && +propName >= 0) {
        if (accessNode && everyType(objectType, (t) => !(<TupleTypeReference>t).target.hasRestElement) && !(accessFlags & AccessFlags.NoTupleBoundsCheck)) {
          const indexNode = getIndexNodeForAccessExpression(accessNode);
          if (isTupleType(objectType))
            error(indexNode, qd.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), syntax.get.unescUnderscores(propName));
          else {
            error(indexNode, qd.Property_0_does_not_exist_on_type_1, syntax.get.unescUnderscores(propName), typeToString(objectType));
          }
        }
        errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, IndexKind.Number));
        return mapType(objectType, (t) => getRestTypeOfTupleType(<TupleTypeReference>t) || undefinedType);
      }
    }
    if (!(indexType.flags & TypeFlags.Nullable) && isTypeAssignableToKind(indexType, TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike)) {
      if (objectType.flags & (TypeFlags.Any | TypeFlags.Never)) return objectType;
      const stringIndexInfo = getIndexInfoOfType(objectType, IndexKind.String);
      const indexInfo = (isTypeAssignableToKind(indexType, TypeFlags.NumberLike) && getIndexInfoOfType(objectType, IndexKind.Number)) || stringIndexInfo;
      if (indexInfo) {
        if (accessFlags & AccessFlags.NoIndexSignatures && indexInfo === stringIndexInfo) {
          if (accessExpression) error(accessExpression, qd.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType));
          return;
        }
        if (accessNode && !isTypeAssignableToKind(indexType, TypeFlags.String | TypeFlags.Number)) {
          const indexNode = getIndexNodeForAccessExpression(accessNode);
          error(indexNode, qd.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
          return indexInfo.type;
        }
        errorIfWritingToReadonlyIndex(indexInfo);
        return indexInfo.type;
      }
      if (indexType.flags & TypeFlags.Never) return neverType;
      if (isJSLiteralType(objectType)) return anyType;
      if (accessExpression && !isConstEnumObjectType(objectType)) {
        if (objectType.symbol === globalThisSymbol && propName !== undefined && globalThisSymbol.exports!.has(propName) && globalThisSymbol.exports!.get(propName)!.flags & SymbolFlags.BlockScoped)
          error(accessExpression, qd.Property_0_does_not_exist_on_type_1, syntax.get.unescUnderscores(propName), typeToString(objectType));
        else if (noImplicitAny && !compilerOptions.suppressImplicitAnyIndexErrors && !suppressNoImplicitAnyError) {
          if (propName !== undefined && typeHasStaticProperty(propName, objectType)) error(accessExpression, qd.Property_0_is_a_static_member_of_type_1, propName as string, typeToString(objectType));
          else if (getIndexTypeOfType(objectType, IndexKind.Number)) {
            error(accessExpression.argumentExpression, qd.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number);
          } else {
            let suggestion: string | undefined;
            if (propName !== undefined && (suggestion = getSuggestionForNonexistentProperty(propName as string, objectType))) {
              if (suggestion !== undefined) error(accessExpression.argumentExpression, qd.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName as string, typeToString(objectType), suggestion);
            } else {
              const suggestion = getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType);
              if (suggestion !== undefined)
                error(accessExpression, qd.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion);
              else {
                let errorInfo: DiagnosticMessageChain | undefined;
                if (indexType.flags & TypeFlags.EnumLiteral)
                  errorInfo = chainDiagnosticMessages(undefined, qd.Property_0_does_not_exist_on_type_1, '[' + typeToString(indexType) + ']', typeToString(objectType));
                else if (indexType.flags & TypeFlags.UniqueESSymbol) {
                  const symbolName = getFullyQualifiedName((indexType as UniqueESSymbolType).symbol, accessExpression);
                  errorInfo = chainDiagnosticMessages(undefined, qd.Property_0_does_not_exist_on_type_1, '[' + symbolName + ']', typeToString(objectType));
                } else if (indexType.flags & TypeFlags.StringLiteral) {
                  errorInfo = chainDiagnosticMessages(undefined, qd.Property_0_does_not_exist_on_type_1, (indexType as StringLiteralType).value, typeToString(objectType));
                } else if (indexType.flags & TypeFlags.NumberLiteral) {
                  errorInfo = chainDiagnosticMessages(undefined, qd.Property_0_does_not_exist_on_type_1, (indexType as NumberLiteralType).value, typeToString(objectType));
                } else if (indexType.flags & (TypeFlags.Number | TypeFlags.String)) {
                  errorInfo = chainDiagnosticMessages(undefined, qd.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType));
                }
                errorInfo = chainDiagnosticMessages(
                  errorInfo,
                  qd.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1,
                  typeToString(fullIndexType),
                  typeToString(objectType)
                );
                diagnostics.add(createDiagnosticForNodeFromMessageChain(accessExpression, errorInfo));
              }
            }
          }
        }
        return;
      }
    }
    if (isJSLiteralType(objectType)) return anyType;
    if (accessNode) {
      const indexNode = getIndexNodeForAccessExpression(accessNode);
      if (indexType.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral))
        error(indexNode, qd.Property_0_does_not_exist_on_type_1, '' + (<StringLiteralType | NumberLiteralType>indexType).value, typeToString(objectType));
      else if (indexType.flags & (TypeFlags.String | TypeFlags.Number)) {
        error(indexNode, qd.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType));
      } else {
        error(indexNode, qd.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
      }
    }
    if (isTypeAny(indexType)) return indexType;
    return;
    function errorIfWritingToReadonlyIndex(indexInfo: IndexInfo | undefined): void {
      if (indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression) || qc.is.deleteTarget(accessExpression)))
        error(accessExpression, qd.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
    }
  }
  function getIndexNodeForAccessExpression(accessNode: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression) {
    return accessNode.kind === Syntax.ElementAccessExpression
      ? accessNode.argumentExpression
      : accessNode.kind === Syntax.IndexedAccessType
      ? accessNode.indexType
      : accessNode.kind === Syntax.ComputedPropertyName
      ? accessNode.expression
      : accessNode;
  }
  function isGenericObjectType(type: Type): boolean {
    if (type.flags & TypeFlags.UnionOrIntersection) {
      if (!((<UnionOrIntersectionType>type).objectFlags & ObjectFlags.IsGenericObjectTypeComputed)) {
        (<UnionOrIntersectionType>type).objectFlags |=
          ObjectFlags.IsGenericObjectTypeComputed | (some((<UnionOrIntersectionType>type).types, isGenericObjectType) ? ObjectFlags.IsGenericObjectType : 0);
      }
      return !!((<UnionOrIntersectionType>type).objectFlags & ObjectFlags.IsGenericObjectType);
    }
    return !!(type.flags & TypeFlags.InstantiableNonPrimitive) || isGenericMappedType(type);
  }
  function isGenericIndexType(type: Type): boolean {
    if (type.flags & TypeFlags.UnionOrIntersection) {
      if (!((<UnionOrIntersectionType>type).objectFlags & ObjectFlags.IsGenericIndexTypeComputed))
        (<UnionOrIntersectionType>type).objectFlags |= ObjectFlags.IsGenericIndexTypeComputed | (some((<UnionOrIntersectionType>type).types, isGenericIndexType) ? ObjectFlags.IsGenericIndexType : 0);
      return !!((<UnionOrIntersectionType>type).objectFlags & ObjectFlags.IsGenericIndexType);
    }
    return !!(type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.Index));
  }
  function isThisTypeParameter(type: Type): boolean {
    return !!(type.flags & TypeFlags.TypeParameter && (<TypeParameter>type).isThisType);
  }
  function getSimplifiedType(type: Type, writing: boolean): Type {
    return type.flags & TypeFlags.IndexedAccess
      ? getSimplifiedIndexedAccessType(<IndexedAccessType>type, writing)
      : type.flags & TypeFlags.Conditional
      ? getSimplifiedConditionalType(<ConditionalType>type, writing)
      : type;
  }
  function distributeIndexOverObjectType(objectType: Type, indexType: Type, writing: boolean) {
    if (objectType.flags & TypeFlags.UnionOrIntersection) {
      const types = map((objectType as UnionOrIntersectionType).types, (t) => getSimplifiedType(getIndexedAccessType(t, indexType), writing));
      return objectType.flags & TypeFlags.Intersection || writing ? getIntersectionType(types) : getUnionType(types);
    }
  }
  function distributeObjectOverIndexType(objectType: Type, indexType: Type, writing: boolean) {
    if (indexType.flags & TypeFlags.Union) {
      const types = map((indexType as UnionType).types, (t) => getSimplifiedType(getIndexedAccessType(objectType, t), writing));
      return writing ? getIntersectionType(types) : getUnionType(types);
    }
  }
  function unwrapSubstitution(type: Type): Type {
    if (type.flags & TypeFlags.Substitution) return (type as SubstitutionType).substitute;
    return type;
  }
  function getSimplifiedIndexedAccessType(type: IndexedAccessType, writing: boolean): Type {
    const cache = writing ? 'simplifiedForWriting' : 'simplifiedForReading';
    if (type[cache]) return type[cache] === circularConstraintType ? type : type[cache]!;
    type[cache] = circularConstraintType;
    const objectType = unwrapSubstitution(getSimplifiedType(type.objectType, writing));
    const indexType = getSimplifiedType(type.indexType, writing);
    const distributedOverIndex = distributeObjectOverIndexType(objectType, indexType, writing);
    if (distributedOverIndex) return (type[cache] = distributedOverIndex);
    if (!(indexType.flags & TypeFlags.Instantiable)) {
      const distributedOverObject = distributeIndexOverObjectType(objectType, indexType, writing);
      if (distributedOverObject) return (type[cache] = distributedOverObject);
    }
    if (isGenericMappedType(objectType)) return (type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), (t) => getSimplifiedType(t, writing)));
    return (type[cache] = type);
  }
  function getSimplifiedConditionalType(type: ConditionalType, writing: boolean) {
    const checkType = type.checkType;
    const extendsType = type.extendsType;
    const trueType = getTrueTypeFromConditionalType(type);
    const falseType = getFalseTypeFromConditionalType(type);
    if (falseType.flags & TypeFlags.Never && getActualTypeVariable(trueType) === getActualTypeVariable(checkType)) {
      if (checkType.flags & TypeFlags.Any || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) return getSimplifiedType(trueType, writing);
      else if (isIntersectionEmpty(checkType, extendsType)) return neverType;
    } else if (trueType.flags & TypeFlags.Never && getActualTypeVariable(falseType) === getActualTypeVariable(checkType)) {
      if (!(checkType.flags & TypeFlags.Any) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) return neverType;
      else if (checkType.flags & TypeFlags.Any || isIntersectionEmpty(checkType, extendsType)) return getSimplifiedType(falseType, writing);
    }
    return type;
  }
  function isIntersectionEmpty(type1: Type, type2: Type) {
    return !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & TypeFlags.Never);
  }
  function substituteIndexedMappedType(objectType: MappedType, index: Type) {
    const mapper = createTypeMapper([getTypeParameterFromMappedType(objectType)], [index]);
    const templateMapper = combineTypeMappers(objectType.mapper, mapper);
    return instantiateType(getTemplateTypeFromMappedType(objectType), templateMapper);
  }
  function getIndexedAccessType(objectType: Type, indexType: Type, accessNode?: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression): Type {
    return getIndexedAccessTypeOrUndefined(objectType, indexType, accessNode, AccessFlags.None) || (accessNode ? errorType : unknownType);
  }
  function getIndexedAccessTypeOrUndefined(
    objectType: Type,
    indexType: Type,
    accessNode?: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression,
    accessFlags = AccessFlags.None
  ): Type | undefined {
    if (objectType === wildcardType || indexType === wildcardType) return wildcardType;
    if (isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & TypeFlags.Nullable) && isTypeAssignableToKind(indexType, TypeFlags.String | TypeFlags.Number)) indexType = stringType;
    if (isGenericIndexType(indexType) || (!(accessNode && accessNode.kind !== Syntax.IndexedAccessType) && isGenericObjectType(objectType))) {
      if (objectType.flags & TypeFlags.AnyOrUnknown) return objectType;
      const id = objectType.id + ',' + indexType.id;
      let type = indexedAccessTypes.get(id);
      if (!type) indexedAccessTypes.set(id, (type = createIndexedAccessType(objectType, indexType)));
      return type;
    }
    const apparentObjectType = getReducedApparentType(objectType);
    if (indexType.flags & TypeFlags.Union && !(indexType.flags & TypeFlags.Boolean)) {
      const propTypes: Type[] = [];
      let wasMissingProp = false;
      for (const t of (<UnionType>indexType).types) {
        const propType = getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, wasMissingProp, accessNode, accessFlags);
        if (propType) propTypes.push(propType);
        else if (!accessNode) {
          return;
        } else {
          wasMissingProp = true;
        }
      }
      if (wasMissingProp) return;
      return accessFlags & AccessFlags.Writing ? getIntersectionType(propTypes) : getUnionType(propTypes);
    }
    return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, false, accessNode, accessFlags | AccessFlags.CacheSymbol);
  }
  function getTypeFromIndexedAccessTypeNode(node: IndexedAccessTypeNode) {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      const objectType = getTypeFromTypeNode(node.objectType);
      const indexType = getTypeFromTypeNode(node.indexType);
      const resolved = getIndexedAccessType(objectType, indexType, node);
      links.resolvedType =
        resolved.flags & TypeFlags.IndexedAccess && (<IndexedAccessType>resolved).objectType === objectType && (<IndexedAccessType>resolved).indexType === indexType
          ? getConditionalFlowTypeOfType(resolved, node)
          : resolved;
    }
    return links.resolvedType;
  }
  function getTypeFromMappedTypeNode(node: MappedTypeNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      const type = <MappedType>createObjectType(ObjectFlags.Mapped, node.symbol);
      type.declaration = node;
      type.aliasSymbol = getAliasSymbolForTypeNode(node);
      type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type.aliasSymbol);
      links.resolvedType = type;
      getConstraintTypeFromMappedType(type);
    }
    return links.resolvedType;
  }
  function getActualTypeVariable(type: Type): Type {
    if (type.flags & TypeFlags.Substitution) return (<SubstitutionType>type).baseType;
    if (type.flags & TypeFlags.IndexedAccess && ((<IndexedAccessType>type).objectType.flags & TypeFlags.Substitution || (<IndexedAccessType>type).indexType.flags & TypeFlags.Substitution))
      return getIndexedAccessType(getActualTypeVariable((<IndexedAccessType>type).objectType), getActualTypeVariable((<IndexedAccessType>type).indexType));
    return type;
  }
  function getConditionalType(root: ConditionalRoot, mapper: TypeMapper | undefined): Type {
    let result;
    let extraTypes: Type[] | undefined;
    while (true) {
      const checkType = instantiateType(root.checkType, mapper);
      const checkTypeInstantiable = isGenericObjectType(checkType) || isGenericIndexType(checkType);
      const extendsType = instantiateType(root.extendsType, mapper);
      if (checkType === wildcardType || extendsType === wildcardType) return wildcardType;
      let combinedMapper: TypeMapper | undefined;
      if (root.inferTypeParameters) {
        const context = createInferenceContext(root.inferTypeParameters, undefined, InferenceFlags.None);
        if (!checkTypeInstantiable || !some(root.inferTypeParameters, (t) => t === extendsType))
          inferTypes(context.inferences, checkType, extendsType, InferencePriority.NoConstraints | InferencePriority.AlwaysStrict);
        combinedMapper = mergeTypeMappers(mapper, context.mapper);
      }
      const inferredExtendsType = combinedMapper ? instantiateType(root.extendsType, combinedMapper) : extendsType;
      if (!checkTypeInstantiable && !isGenericObjectType(inferredExtendsType) && !isGenericIndexType(inferredExtendsType)) {
        if (
          !(inferredExtendsType.flags & TypeFlags.AnyOrUnknown) &&
          (checkType.flags & TypeFlags.Any || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))
        ) {
          if (checkType.flags & TypeFlags.Any) (extraTypes || (extraTypes = [])).push(instantiateTypeWithoutDepthIncrease(root.trueType, combinedMapper || mapper));
          const falseType = root.falseType;
          if (falseType.flags & TypeFlags.Conditional) {
            const newRoot = (<ConditionalType>falseType).root;
            if (newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)) {
              root = newRoot;
              continue;
            }
          }
          result = instantiateTypeWithoutDepthIncrease(falseType, mapper);
          break;
        }
        if (inferredExtendsType.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {
          result = instantiateTypeWithoutDepthIncrease(root.trueType, combinedMapper || mapper);
          break;
        }
      }
      const erasedCheckType = getActualTypeVariable(checkType);
      result = <ConditionalType>createType(TypeFlags.Conditional);
      result.root = root;
      result.checkType = erasedCheckType;
      result.extendsType = extendsType;
      result.mapper = mapper;
      result.combinedMapper = combinedMapper;
      result.aliasSymbol = root.aliasSymbol;
      result.aliasTypeArguments = instantiateTypes(root.aliasTypeArguments, mapper!);
      break;
    }
    return extraTypes ? getUnionType(append(extraTypes, result)) : result;
  }
  function getTrueTypeFromConditionalType(type: ConditionalType) {
    return type.resolvedTrueType || (type.resolvedTrueType = instantiateType(type.root.trueType, type.mapper));
  }
  function getFalseTypeFromConditionalType(type: ConditionalType) {
    return type.resolvedFalseType || (type.resolvedFalseType = instantiateType(type.root.falseType, type.mapper));
  }
  function getInferredTrueTypeFromConditionalType(type: ConditionalType) {
    return type.resolvedInferredTrueType || (type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(type.root.trueType, type.combinedMapper) : getTrueTypeFromConditionalType(type));
  }
  function getInferTypeParameters(node: ConditionalTypeNode): TypeParameter[] | undefined {
    let result: TypeParameter[] | undefined;
    if (node.locals) {
      node.locals.forEach((symbol) => {
        if (symbol.flags & SymbolFlags.TypeParameter) result = append(result, getDeclaredTypeOfSymbol(symbol));
      });
    }
    return result;
  }
  function getTypeFromConditionalTypeNode(node: ConditionalTypeNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      const checkType = getTypeFromTypeNode(node.checkType);
      const aliasSymbol = getAliasSymbolForTypeNode(node);
      const aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
      const allOuterTypeParameters = getOuterTypeParameters(node, true);
      const outerTypeParameters = aliasTypeArguments ? allOuterTypeParameters : filter(allOuterTypeParameters, (tp) => isTypeParameterPossiblyReferenced(tp, node));
      const root: ConditionalRoot = {
        node,
        checkType,
        extendsType: getTypeFromTypeNode(node.extendsType),
        trueType: getTypeFromTypeNode(node.trueType),
        falseType: getTypeFromTypeNode(node.falseType),
        isDistributive: !!(checkType.flags & TypeFlags.TypeParameter),
        inferTypeParameters: getInferTypeParameters(node),
        outerTypeParameters,
        instantiations: undefined,
        aliasSymbol,
        aliasTypeArguments,
      };
      links.resolvedType = getConditionalType(root, undefined);
      if (outerTypeParameters) {
        root.instantiations = new qb.QMap<Type>();
        root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType);
      }
    }
    return links.resolvedType;
  }
  function getTypeFromInferTypeNode(node: InferTypeNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node.typeParameter));
    return links.resolvedType;
  }
  function getIdentifierChain(node: EntityName): Identifier[] {
    if (qc.is.kind(Identifier, node)) return [node];
    return append(getIdentifierChain(node.left), node.right);
  }
  function getTypeFromImportTypeNode(node: ImportTypeNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      if (node.isTypeOf && node.typeArguments) {
        error(node, qd.Type_arguments_cannot_be_used_here);
        links.resolvedSymbol = unknownSymbol;
        return (links.resolvedType = errorType);
      }
      if (!qc.is.literalImportTypeNode(node)) {
        error(node.argument, qd.String_literal_expected);
        links.resolvedSymbol = unknownSymbol;
        return (links.resolvedType = errorType);
      }
      const targetMeaning = node.isTypeOf ? SymbolFlags.Value : node.flags & NodeFlags.JSDoc ? SymbolFlags.Value | SymbolFlags.Type : SymbolFlags.Type;
      const innerModuleSymbol = resolveExternalModuleName(node, node.argument.literal);
      if (!innerModuleSymbol) {
        links.resolvedSymbol = unknownSymbol;
        return (links.resolvedType = errorType);
      }
      const moduleSymbol = resolveExternalModuleSymbol(innerModuleSymbol, false);
      if (!qc.is.missing(node.qualifier)) {
        const nameStack: Identifier[] = getIdentifierChain(node.qualifier!);
        let currentNamespace = moduleSymbol;
        let current: Identifier | undefined;
        while ((current = nameStack.shift())) {
          const meaning = nameStack.length ? SymbolFlags.Namespace : targetMeaning;
          const next = getSymbol(getMergedSymbol(currentNamespace.resolveSymbol()).getExportsOfSymbol(), current.escapedText, meaning);
          if (!next) {
            error(current, qd.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), declarationNameToString(current));
            return (links.resolvedType = errorType);
          }
          getNodeLinks(current).resolvedSymbol = next;
          getNodeLinks(current.parent).resolvedSymbol = next;
          currentNamespace = next;
        }
        links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning);
      } else {
        if (moduleSymbol.flags & targetMeaning) links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning);
        else {
          const errorMessage =
            targetMeaning === SymbolFlags.Value
              ? qd.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here
              : qd.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0;
          error(node, errorMessage, node.argument.literal.text);
          links.resolvedSymbol = unknownSymbol;
          links.resolvedType = errorType;
        }
      }
    }
    return links.resolvedType;
  }
  function resolveImportSymbolType(node: ImportTypeNode, links: NodeLinks, symbol: Symbol, meaning: SymbolFlags) {
    const resolvedSymbol = symbol.resolveSymbol();
    links.resolvedSymbol = resolvedSymbol;
    if (meaning === SymbolFlags.Value) return this.getTypeOfSymbol();
    return getTypeReferenceType(node, resolvedSymbol);
  }
  function getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node: TypeNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      const aliasSymbol = getAliasSymbolForTypeNode(node);
      if (getMembersOfSymbol(node.symbol).size === 0 && !aliasSymbol) links.resolvedType = emptyTypeLiteralType;
      else {
        let type = createObjectType(ObjectFlags.Anonymous, node.symbol);
        type.aliasSymbol = aliasSymbol;
        type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
        if (qc.is.kind(JSDocTypeLiteral, node) && node.isArrayType) type = createArrayType(type);
        links.resolvedType = type;
      }
    }
    return links.resolvedType;
  }
  function getAliasSymbolForTypeNode(node: Node) {
    let host = node.parent;
    while (qc.is.kind(ParenthesizedTypeNode, host) || (qc.is.kind(TypeOperatorNode, host) && host.operator === Syntax.ReadonlyKeyword)) {
      host = host.parent;
    }
    return qc.is.typeAlias(host) ? getSymbolOfNode(host) : undefined;
  }
  function getTypeArgumentsForAliasSymbol(symbol: Symbol | undefined) {
    return symbol ? this.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias() : undefined;
  }
  function isNonGenericObjectType(type: Type) {
    return !!(type.flags & TypeFlags.Object) && !isGenericMappedType(type);
  }
  function isEmptyObjectTypeOrSpreadsIntoEmptyObject(type: Type) {
    return (
      isEmptyObjectType(type) ||
      !!(
        type.flags &
        (TypeFlags.Null |
          TypeFlags.Undefined |
          TypeFlags.BooleanLike |
          TypeFlags.NumberLike |
          TypeFlags.BigIntLike |
          TypeFlags.StringLike |
          TypeFlags.EnumLike |
          TypeFlags.NonPrimitive |
          TypeFlags.Index)
      )
    );
  }
  function isSinglePropertyAnonymousObjectType(type: Type) {
    return (
      !!(type.flags & TypeFlags.Object) &&
      !!(getObjectFlags(type) & ObjectFlags.Anonymous) &&
      (length(getPropertiesOfType(type)) === 1 || every(getPropertiesOfType(type), (p) => !!(p.flags & SymbolFlags.Optional)))
    );
  }
  function tryMergeUnionOfObjectTypeAndEmptyObject(type: UnionType, readonly: boolean): Type | undefined {
    if (type.types.length === 2) {
      const firstType = type.types[0];
      const secondType = type.types[1];
      if (every(type.types, isEmptyObjectTypeOrSpreadsIntoEmptyObject)) return isEmptyObjectType(firstType) ? firstType : isEmptyObjectType(secondType) ? secondType : emptyObjectType;
      if (isEmptyObjectTypeOrSpreadsIntoEmptyObject(firstType) && isSinglePropertyAnonymousObjectType(secondType)) return getAnonymousPartialType(secondType);
      if (isEmptyObjectTypeOrSpreadsIntoEmptyObject(secondType) && isSinglePropertyAnonymousObjectType(firstType)) return getAnonymousPartialType(firstType);
    }
    function getAnonymousPartialType(type: Type) {
      const members = new SymbolTable();
      for (const prop of getPropertiesOfType(type)) {
        if (getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlags.Private | ModifierFlags.Protected)) {
        } else if (isSpreadableProperty(prop)) {
          const isSetonlyAccessor = prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor);
          const flags = SymbolFlags.Property | SymbolFlags.Optional;
          const result = new QSymbol(flags, prop.escName, readonly ? CheckFlags.Readonly : 0);
          result.type = isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop);
          result.declarations = prop.declarations;
          result.nameType = s.getLinks(prop).nameType;
          result.syntheticOrigin = prop;
          members.set(prop.escName, result);
        }
      }
      const spread = createAnonymousType(type.symbol, members, empty, empty, getIndexInfoOfType(type, IndexKind.String), getIndexInfoOfType(type, IndexKind.Number));
      spread.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
      return spread;
    }
  }
  function getSpreadType(left: Type, right: Type, symbol: Symbol | undefined, objectFlags: ObjectFlags, readonly: boolean): Type {
    if (left.flags & TypeFlags.Any || right.flags & TypeFlags.Any) return anyType;
    if (left.flags & TypeFlags.Unknown || right.flags & TypeFlags.Unknown) return unknownType;
    if (left.flags & TypeFlags.Never) return right;
    if (right.flags & TypeFlags.Never) return left;
    if (left.flags & TypeFlags.Union) {
      const merged = tryMergeUnionOfObjectTypeAndEmptyObject(left as UnionType, readonly);
      if (merged) return getSpreadType(merged, right, symbol, objectFlags, readonly);
      return mapType(left, (t) => getSpreadType(t, right, symbol, objectFlags, readonly));
    }
    if (right.flags & TypeFlags.Union) {
      const merged = tryMergeUnionOfObjectTypeAndEmptyObject(right as UnionType, readonly);
      if (merged) return getSpreadType(left, merged, symbol, objectFlags, readonly);
      return mapType(right, (t) => getSpreadType(left, t, symbol, objectFlags, readonly));
    }
    if (right.flags & (TypeFlags.BooleanLike | TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.EnumLike | TypeFlags.NonPrimitive | TypeFlags.Index)) return left;
    if (isGenericObjectType(left) || isGenericObjectType(right)) {
      if (isEmptyObjectType(left)) return right;
      if (left.flags & TypeFlags.Intersection) {
        const types = (<IntersectionType>left).types;
        const lastLeft = types[types.length - 1];
        if (isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right))
          return getIntersectionType(concatenate(types.slice(0, types.length - 1), [getSpreadType(lastLeft, right, symbol, objectFlags, readonly)]));
      }
      return getIntersectionType([left, right]);
    }
    const members = new SymbolTable();
    const skippedPrivateMembers = createUnderscoreEscapedMap<boolean>();
    let stringIndexInfo: IndexInfo | undefined;
    let numberIndexInfo: IndexInfo | undefined;
    if (left === emptyObjectType) {
      stringIndexInfo = getIndexInfoOfType(right, IndexKind.String);
      numberIndexInfo = getIndexInfoOfType(right, IndexKind.Number);
    } else {
      stringIndexInfo = unionSpreadIndexInfos(getIndexInfoOfType(left, IndexKind.String), getIndexInfoOfType(right, IndexKind.String));
      numberIndexInfo = unionSpreadIndexInfos(getIndexInfoOfType(left, IndexKind.Number), getIndexInfoOfType(right, IndexKind.Number));
    }
    for (const rightProp of getPropertiesOfType(right)) {
      if (getDeclarationModifierFlagsFromSymbol(rightProp) & (ModifierFlags.Private | ModifierFlags.Protected)) skippedPrivateMembers.set(rightProp.escName, true);
      else if (isSpreadableProperty(rightProp)) {
        members.set(rightProp.escName, getSpreadSymbol(rightProp, readonly));
      }
    }
    for (const leftProp of getPropertiesOfType(left)) {
      if (skippedPrivateMembers.has(leftProp.escName) || !isSpreadableProperty(leftProp)) continue;
      if (members.has(leftProp.escName)) {
        const rightProp = members.get(leftProp.escName)!;
        const rightType = getTypeOfSymbol(rightProp);
        if (rightProp.flags & SymbolFlags.Optional) {
          const declarations = concatenate(leftProp.declarations, rightProp.declarations);
          const flags = SymbolFlags.Property | (leftProp.flags & SymbolFlags.Optional);
          const result = new QSymbol(flags, leftProp.escName);
          result.type = getUnionType([getTypeOfSymbol(leftProp), getTypeWithFacts(rightType, TypeFacts.NEUndefined)]);
          result.leftSpread = leftProp;
          result.rightSpread = rightProp;
          result.declarations = declarations;
          result.nameType = s.getLinks(leftProp).nameType;
          members.set(leftProp.escName, result);
        }
      } else {
        members.set(leftProp.escName, getSpreadSymbol(leftProp, readonly));
      }
    }
    const spread = createAnonymousType(symbol, members, empty, empty, getIndexInfoWithReadonly(stringIndexInfo, readonly), getIndexInfoWithReadonly(numberIndexInfo, readonly));
    spread.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral | ObjectFlags.ContainsSpread | objectFlags;
    return spread;
  }
  function isSpreadableProperty(prop: Symbol): boolean {
    return (
      !some(prop.declarations, isPrivateIdentifierPropertyDeclaration) &&
      (!(prop.flags & (SymbolFlags.Method | SymbolFlags.GetAccessor | SymbolFlags.SetAccessor)) || !prop.declarations.some((decl) => qc.is.classLike(decl.parent)))
    );
  }
  function getSpreadSymbol(prop: Symbol, readonly: boolean) {
    const isSetonlyAccessor = prop.flags & SymbolFlags.SetAccessor && !(prop.flags & SymbolFlags.GetAccessor);
    if (!isSetonlyAccessor && readonly === isReadonlySymbol(prop)) return prop;
    const flags = SymbolFlags.Property | (prop.flags & SymbolFlags.Optional);
    const result = new QSymbol(flags, prop.escName, readonly ? CheckFlags.Readonly : 0);
    result.type = isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop);
    result.declarations = prop.declarations;
    result.nameType = s.getLinks(prop).nameType;
    result.syntheticOrigin = prop;
    return result;
  }
  function getIndexInfoWithReadonly(info: IndexInfo | undefined, readonly: boolean) {
    return info && info.isReadonly !== readonly ? createIndexInfo(info.type, readonly, info.declaration) : info;
  }
  function createLiteralType(flags: TypeFlags, value: string | number | PseudoBigInt, symbol: Symbol | undefined) {
    const type = <LiteralType>createType(flags);
    type.symbol = symbol!;
    type.value = value;
    return type;
  }
  function getFreshTypeOfLiteralType(type: Type): Type {
    if (type.flags & TypeFlags.Literal) {
      if (!(<LiteralType>type).freshType) {
        const freshType = createLiteralType(type.flags, (<LiteralType>type).value, (<LiteralType>type).symbol);
        freshType.regularType = <LiteralType>type;
        freshType.freshType = freshType;
        (<LiteralType>type).freshType = freshType;
      }
      return (<LiteralType>type).freshType;
    }
    return type;
  }
  function getRegularTypeOfLiteralType(type: Type): Type {
    return type.flags & TypeFlags.Literal
      ? (<LiteralType>type).regularType
      : type.flags & TypeFlags.Union
      ? (<UnionType>type).regularType || ((<UnionType>type).regularType = getUnionType(sameMap((<UnionType>type).types, getRegularTypeOfLiteralType)) as UnionType)
      : type;
  }
  function isFreshLiteralType(type: Type) {
    return !!(type.flags & TypeFlags.Literal) && (<LiteralType>type).freshType === type;
  }
  function getLiteralType(value: string | number | PseudoBigInt, enumId?: number, symbol?: Symbol) {
    const qualifier = typeof value === 'number' ? '#' : typeof value === 'string' ? '@' : 'n';
    const key = (enumId ? enumId : '') + qualifier + (typeof value === 'object' ? pseudoBigIntToString(value) : value);
    let type = literalTypes.get(key);
    if (!type) {
      const flags = (typeof value === 'number' ? TypeFlags.NumberLiteral : typeof value === 'string' ? TypeFlags.StringLiteral : TypeFlags.BigIntLiteral) | (enumId ? TypeFlags.EnumLiteral : 0);
      literalTypes.set(key, (type = createLiteralType(flags, value, symbol)));
      type.regularType = type;
    }
    return type;
  }
  function getTypeFromLiteralTypeNode(node: LiteralTypeNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal));
    return links.resolvedType;
  }
  function getESSymbolLikeTypeForNode(node: Node) {
    if (qc.is.validESSymbolDeclaration(node)) {
      const symbol = getSymbolOfNode(node);
      const links = s.getLinks(symbol);
      return links.uniqueESSymbolType || (links.uniqueESSymbolType = createUniqueESSymbolType(symbol));
    }
    return esSymbolType;
  }
  function getThisType(node: Node): Type {
    const container = qc.get.thisContainer(node, false);
    const parent = container && container.parent;
    if (parent && (qc.is.classLike(parent) || parent.kind === Syntax.InterfaceDeclaration)) {
      if (!hasSyntacticModifier(container, ModifierFlags.Static) && (!qc.is.kind(ConstructorDeclaration, container) || qc.is.descendantOf(node, container.body)))
        return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent as ClassLikeDeclaration | InterfaceDeclaration)).thisType!;
    }
    if (parent && qc.is.kind(ObjectLiteralExpression, parent) && qc.is.kind(BinaryExpression, parent.parent) && getAssignmentDeclarationKind(parent.parent) === AssignmentDeclarationKind.Prototype) {
      return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left)!.parent!).thisType!;
    }
    const host = node.flags & NodeFlags.JSDoc ? getHostSignatureFromJSDoc(node) : undefined;
    if (host && qc.is.kind(FunctionExpression, host) && qc.is.kind(BinaryExpression, host.parent) && getAssignmentDeclarationKind(host.parent) === AssignmentDeclarationKind.PrototypeProperty)
      return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left)!.parent!).thisType!;
    if (isJSConstructor(container) && qc.is.descendantOf(node, container.body)) return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(container)).thisType!;
    error(node, qd.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface);
    return errorType;
  }
  function getTypeFromThisNodeTypeNode(node: ThisExpression | ThisTypeNode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) links.resolvedType = getThisType(node);
    return links.resolvedType;
  }
  function getTypeFromNamedTupleTypeNode(node: NamedTupleMember): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      let type = getTypeFromTypeNode(node.type);
      if (node.dot3Token) type = getElementTypeOfArrayType(type) || errorType;
      if (node.questionToken && strictNullChecks) type = getOptionalType(type);
      links.resolvedType = type;
    }
    return links.resolvedType;
  }
  function getTypeFromTypeNode(node: TypeNode): Type {
    return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node);
  }
  function getTypeFromTypeNodeWorker(node: TypeNode): Type {
    switch (node.kind) {
      case Syntax.AnyKeyword:
      case Syntax.JSDocAllType:
      case Syntax.JSDocUnknownType:
        return anyType;
      case Syntax.UnknownKeyword:
        return unknownType;
      case Syntax.StringKeyword:
        return stringType;
      case Syntax.NumberKeyword:
        return numberType;
      case Syntax.BigIntKeyword:
        return bigintType;
      case Syntax.BooleanKeyword:
        return booleanType;
      case Syntax.SymbolKeyword:
        return esSymbolType;
      case Syntax.VoidKeyword:
        return voidType;
      case Syntax.UndefinedKeyword:
        return undefinedType;
      case Syntax.NullKeyword:
        return nullType;
      case Syntax.NeverKeyword:
        return neverType;
      case Syntax.ObjectKeyword:
        return node.flags & NodeFlags.JavaScriptFile && !noImplicitAny ? anyType : nonPrimitiveType;
      case Syntax.ThisType:
      case Syntax.ThisKeyword:
        return getTypeFromThisNodeTypeNode(node as ThisExpression | ThisTypeNode);
      case Syntax.LiteralType:
        return getTypeFromLiteralTypeNode(<LiteralTypeNode>node);
      case Syntax.TypeReference:
        return getTypeFromTypeReference(<TypeReferenceNode>node);
      case Syntax.TypePredicate:
        return (<TypePredicateNode>node).assertsModifier ? voidType : booleanType;
      case Syntax.ExpressionWithTypeArguments:
        return getTypeFromTypeReference(<ExpressionWithTypeArguments>node);
      case Syntax.TypeQuery:
        return getTypeFromTypeQueryNode(<TypeQueryNode>node);
      case Syntax.ArrayType:
      case Syntax.TupleType:
        return getTypeFromArrayOrTupleTypeNode(<ArrayTypeNode | TupleTypeNode>node);
      case Syntax.OptionalType:
        return getTypeFromOptionalTypeNode(<OptionalTypeNode>node);
      case Syntax.UnionType:
        return getTypeFromUnionTypeNode(<UnionTypeNode>node);
      case Syntax.IntersectionType:
        return getTypeFromIntersectionTypeNode(<IntersectionTypeNode>node);
      case Syntax.JSDocNullableType:
        return getTypeFromJSDocNullableTypeNode(<JSDocNullableType>node);
      case Syntax.JSDocOptionalType:
        return addOptionality(getTypeFromTypeNode((node as JSDocOptionalType).type));
      case Syntax.NamedTupleMember:
        return getTypeFromNamedTupleTypeNode(node as NamedTupleMember);
      case Syntax.ParenthesizedType:
      case Syntax.JSDocNonNullableType:
      case Syntax.JSDocTypeExpression:
        return getTypeFromTypeNode((<ParenthesizedTypeNode | JSDocTypeReferencingNode | JSDocTypeExpression | NamedTupleMember>node).type);
      case Syntax.RestType:
        return getElementTypeOfArrayType(getTypeFromTypeNode((<RestTypeNode>node).type)) || errorType;
      case Syntax.JSDocVariadicType:
        return getTypeFromJSDocVariadicType(node as JSDocVariadicType);
      case Syntax.FunctionType:
      case Syntax.ConstructorType:
      case Syntax.TypeLiteral:
      case Syntax.JSDocTypeLiteral:
      case Syntax.JSDocFunctionType:
      case Syntax.JSDocSignature:
        return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
      case Syntax.TypeOperator:
        return getTypeFromTypeOperatorNode(<TypeOperatorNode>node);
      case Syntax.IndexedAccessType:
        return getTypeFromIndexedAccessTypeNode(<IndexedAccessTypeNode>node);
      case Syntax.MappedType:
        return getTypeFromMappedTypeNode(<MappedTypeNode>node);
      case Syntax.ConditionalType:
        return getTypeFromConditionalTypeNode(<ConditionalTypeNode>node);
      case Syntax.InferType:
        return getTypeFromInferTypeNode(<InferTypeNode>node);
      case Syntax.ImportType:
        return getTypeFromImportTypeNode(<ImportTypeNode>node);
      case Syntax.Identifier:
      case Syntax.QualifiedName:
        const symbol = getSymbolAtLocation(node);
        return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
      default:
        return errorType;
    }
  }
  function instantiateList<T>(items: readonly T[], mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[];
  function instantiateList<T>(items: readonly T[] | undefined, mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[] | undefined;
  function instantiateList<T>(items: readonly T[] | undefined, mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[] | undefined {
    if (items && items.length) {
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const mapped = instantiator(item, mapper);
        if (item !== mapped) {
          const result = i === 0 ? [] : items.slice(0, i);
          result.push(mapped);
          for (i++; i < items.length; i++) {
            result.push(instantiator(items[i], mapper));
          }
          return result;
        }
      }
    }
    return items;
  }
  function instantiateTypes(types: readonly Type[], mapper: TypeMapper): readonly Type[];
  function instantiateTypes(types: readonly Type[] | undefined, mapper: TypeMapper): readonly Type[] | undefined;
  function instantiateTypes(types: readonly Type[] | undefined, mapper: TypeMapper): readonly Type[] | undefined {
    return instantiateList<Type>(types, mapper, instantiateType);
  }
  function instantiateSignatures(signatures: readonly Signature[], mapper: TypeMapper): readonly Signature[] {
    return instantiateList<Signature>(signatures, mapper, instantiateSignature);
  }
  function createTypeMapper(sources: readonly TypeParameter[], targets: readonly Type[] | undefined): TypeMapper {
    return sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets);
  }
  function getMappedType(type: Type, mapper: TypeMapper): Type {
    switch (mapper.kind) {
      case TypeMapKind.Simple:
        return type === mapper.source ? mapper.target : type;
      case TypeMapKind.Array:
        const sources = mapper.sources;
        const targets = mapper.targets;
        for (let i = 0; i < sources.length; i++) {
          if (type === sources[i]) return targets ? targets[i] : anyType;
        }
        return type;
      case TypeMapKind.Function:
        return mapper.func(type);
      case TypeMapKind.Composite:
      case TypeMapKind.Merged:
        const t1 = getMappedType(type, mapper.mapper1);
        return t1 !== type && mapper.kind === TypeMapKind.Composite ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2);
    }
  }
  function makeUnaryTypeMapper(source: Type, target: Type): TypeMapper {
    return { kind: TypeMapKind.Simple, source, target };
  }
  function makeArrayTypeMapper(sources: readonly TypeParameter[], targets: readonly Type[] | undefined): TypeMapper {
    return { kind: TypeMapKind.Array, sources, targets };
  }
  function makeFunctionTypeMapper(func: (t: Type) => Type): TypeMapper {
    return { kind: TypeMapKind.Function, func };
  }
  function makeCompositeTypeMapper(kind: TypeMapKind.Composite | TypeMapKind.Merged, mapper1: TypeMapper, mapper2: TypeMapper): TypeMapper {
    return { kind, mapper1, mapper2 };
  }
  function createTypeEraser(sources: readonly TypeParameter[]): TypeMapper {
    return createTypeMapper(sources, undefined);
  }
  function createBackreferenceMapper(context: InferenceContext, index: number): TypeMapper {
    return makeFunctionTypeMapper((t) => (findIndex(context.inferences, (info) => info.typeParameter === t) >= index ? unknownType : t));
  }
  function combineTypeMappers(mapper1: TypeMapper | undefined, mapper2: TypeMapper): TypeMapper {
    return mapper1 ? makeCompositeTypeMapper(TypeMapKind.Composite, mapper1, mapper2) : mapper2;
  }
  function mergeTypeMappers(mapper1: TypeMapper | undefined, mapper2: TypeMapper): TypeMapper {
    return mapper1 ? makeCompositeTypeMapper(TypeMapKind.Merged, mapper1, mapper2) : mapper2;
  }
  function prependTypeMapping(source: Type, target: Type, mapper: TypeMapper | undefined) {
    return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, makeUnaryTypeMapper(source, target), mapper);
  }
  function appendTypeMapping(mapper: TypeMapper | undefined, source: Type, target: Type) {
    return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, mapper, makeUnaryTypeMapper(source, target));
  }
  function getRestrictiveTypeParameter(tp: TypeParameter) {
    return tp.constraint === unknownType
      ? tp
      : tp.restrictiveInstantiation ||
          ((tp.restrictiveInstantiation = createTypeParameter(tp.symbol)), ((tp.restrictiveInstantiation as TypeParameter).constraint = unknownType), tp.restrictiveInstantiation);
  }
  function cloneTypeParameter(typeParameter: TypeParameter): TypeParameter {
    const result = createTypeParameter(typeParameter.symbol);
    result.target = typeParameter;
    return result;
  }
  function instantiateTypePredicate(predicate: TypePredicate, mapper: TypeMapper): TypePredicate {
    return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type, mapper));
  }
  function instantiateSignature(signature: Signature, mapper: TypeMapper, eraseTypeParameters?: boolean): Signature {
    let freshTypeParameters: TypeParameter[] | undefined;
    if (signature.typeParameters && !eraseTypeParameters) {
      freshTypeParameters = map(signature.typeParameters, cloneTypeParameter);
      mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
      for (const tp of freshTypeParameters) {
        tp.mapper = mapper;
      }
    }
    const result = createSignature(
      signature.declaration,
      freshTypeParameters,
      signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper),
      instantiateList(signature.parameters, mapper, instantiateSymbol),
      undefined,
      undefined,
      signature.minArgumentCount,
      signature.flags & SignatureFlags.PropagatingFlags
    );
    result.target = signature;
    result.mapper = mapper;
    return result;
  }
  function instantiateSymbol(symbol: Symbol, mapper: TypeMapper): Symbol {
    const links = s.getLinks(symbol);
    if (links.type && !couldContainTypeVariables(links.type)) return symbol;
    if (this.getCheckFlags() & CheckFlags.Instantiated) {
      symbol = links.target!;
      mapper = combineTypeMappers(links.mapper, mapper);
    }
    const result = new QSymbol(
      symbol.flags,
      symbol.escName,
      CheckFlags.Instantiated | (this.getCheckFlags() & (CheckFlags.Readonly | CheckFlags.Late | CheckFlags.OptionalParameter | CheckFlags.RestParameter))
    );
    result.declarations = symbol.declarations;
    result.parent = symbol.parent;
    result.target = symbol;
    result.mapper = mapper;
    if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;
    if (links.nameType) result.nameType = links.nameType;
    return result;
  }
  function getObjectTypeInstantiation(type: AnonymousType | DeferredTypeReference, mapper: TypeMapper) {
    const target = type.objectFlags & ObjectFlags.Instantiated ? type.target! : type;
    const node = type.objectFlags & ObjectFlags.Reference ? (<TypeReference>type).node! : type.symbol.declarations[0];
    const links = getNodeLinks(node);
    let typeParameters = links.outerTypeParameters;
    if (!typeParameters) {
      let declaration = node;
      if (isInJSFile(declaration)) {
        const paramTag = Node.findAncestor(declaration, isJSDocParameterTag);
        if (paramTag) {
          const paramSymbol = getParameterSymbolFromJSDoc(paramTag);
          if (paramSymbol) declaration = paramSymbol.valueDeclaration;
        }
      }
      let outerTypeParameters = getOuterTypeParameters(declaration, true);
      if (isJSConstructor(declaration)) {
        const templateTagParameters = getTypeParametersFromDeclaration(declaration as DeclarationWithTypeParameters);
        outerTypeParameters = addRange(outerTypeParameters, templateTagParameters);
      }
      typeParameters = outerTypeParameters || empty;
      typeParameters =
        (target.objectFlags & ObjectFlags.Reference || target.symbol.flags & SymbolFlags.TypeLiteral) && !target.aliasTypeArguments
          ? filter(typeParameters, (tp) => isTypeParameterPossiblyReferenced(tp, declaration))
          : typeParameters;
      links.outerTypeParameters = typeParameters;
      if (typeParameters.length) {
        links.instantiations = new qb.QMap<Type>();
        links.instantiations.set(getTypeListId(typeParameters), target);
      }
    }
    if (typeParameters.length) {
      const combinedMapper = combineTypeMappers(type.mapper, mapper);
      const typeArguments = map(typeParameters, (t) => getMappedType(t, combinedMapper));
      const id = getTypeListId(typeArguments);
      let result = links.instantiations!.get(id);
      if (!result) {
        const newMapper = createTypeMapper(typeParameters, typeArguments);
        result =
          target.objectFlags & ObjectFlags.Reference
            ? createDeferredTypeReference((<DeferredTypeReference>type).target, (<DeferredTypeReference>type).node, newMapper)
            : target.objectFlags & ObjectFlags.Mapped
            ? instantiateMappedType(<MappedType>target, newMapper)
            : instantiateAnonymousType(target, newMapper);
        links.instantiations!.set(id, result);
      }
      return result;
    }
    return type;
  }
  function maybeTypeParameterReference(node: Node) {
    return !(
      node.kind === Syntax.QualifiedName ||
      (node.parent.kind === Syntax.TypeReference && (<TypeReferenceNode>node.parent).typeArguments && node === (<TypeReferenceNode>node.parent).typeName) ||
      (node.parent.kind === Syntax.ImportType && (node.parent as ImportTypeNode).typeArguments && node === (node.parent as ImportTypeNode).qualifier)
    );
  }
  function isTypeParameterPossiblyReferenced(tp: TypeParameter, node: Node) {
    if (tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length === 1) {
      const container = tp.symbol.declarations[0].parent;
      for (let n = node; n !== container; n = n.parent) {
        if (!n || n.kind === Syntax.Block || (n.kind === Syntax.ConditionalType && qc.forEach.child((<ConditionalTypeNode>n).extendsType, containsReference))) return true;
      }
      return !!qc.forEach.child(node, containsReference);
    }
    return true;
    function containsReference(node: Node): boolean {
      switch (node.kind) {
        case Syntax.ThisType:
          return !!tp.isThisType;
        case Syntax.Identifier:
          return !tp.isThisType && qc.is.partOfTypeNode(node) && maybeTypeParameterReference(node) && getTypeFromTypeNodeWorker(<TypeNode>node) === tp;
        case Syntax.TypeQuery:
          return true;
      }
      return !!qc.forEach.child(node, containsReference);
    }
  }
  function getHomomorphicTypeVariable(type: MappedType) {
    const constraintType = getConstraintTypeFromMappedType(type);
    if (constraintType.flags & TypeFlags.Index) {
      const typeVariable = getActualTypeVariable((<IndexType>constraintType).type);
      if (typeVariable.flags & TypeFlags.TypeParameter) return <TypeParameter>typeVariable;
    }
    return;
  }
  function instantiateMappedType(type: MappedType, mapper: TypeMapper): Type {
    const typeVariable = getHomomorphicTypeVariable(type);
    if (typeVariable) {
      const mappedTypeVariable = instantiateType(typeVariable, mapper);
      if (typeVariable !== mappedTypeVariable) {
        return mapType(getReducedType(mappedTypeVariable), (t) => {
          if (t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.InstantiableNonPrimitive | TypeFlags.Object | TypeFlags.Intersection) && t !== wildcardType && t !== errorType) {
            const replacementMapper = prependTypeMapping(typeVariable, t, mapper);
            return isArrayType(t)
              ? instantiateMappedArrayType(t, type, replacementMapper)
              : isTupleType(t)
              ? instantiateMappedTupleType(t, type, replacementMapper)
              : instantiateAnonymousType(type, replacementMapper);
          }
          return t;
        });
      }
    }
    return instantiateAnonymousType(type, mapper);
  }
  function getModifiedReadonlyState(state: boolean, modifiers: MappedTypeModifiers) {
    return modifiers & MappedTypeModifiers.IncludeReadonly ? true : modifiers & MappedTypeModifiers.ExcludeReadonly ? false : state;
  }
  function instantiateMappedArrayType(arrayType: Type, mappedType: MappedType, mapper: TypeMapper) {
    const elementType = instantiateMappedTypeTemplate(mappedType, numberType, true, mapper);
    return elementType === errorType ? errorType : createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType)));
  }
  function instantiateMappedTupleType(tupleType: TupleTypeReference, mappedType: MappedType, mapper: TypeMapper) {
    const minLength = tupleType.target.minLength;
    const elementTypes = map(getTypeArguments(tupleType), (_, i) => instantiateMappedTypeTemplate(mappedType, getLiteralType('' + i), i >= minLength, mapper));
    const modifiers = getMappedTypeModifiers(mappedType);
    const newMinLength =
      modifiers & MappedTypeModifiers.IncludeOptional ? 0 : modifiers & MappedTypeModifiers.ExcludeOptional ? getTypeReferenceArity(tupleType) - (tupleType.target.hasRestElement ? 1 : 0) : minLength;
    const newReadonly = getModifiedReadonlyState(tupleType.target.readonly, modifiers);
    return contains(elementTypes, errorType) ? errorType : createTupleType(elementTypes, newMinLength, tupleType.target.hasRestElement, newReadonly, tupleType.target.labeledElementDeclarations);
  }
  function instantiateMappedTypeTemplate(type: MappedType, key: Type, isOptional: boolean, mapper: TypeMapper) {
    const templateMapper = appendTypeMapping(mapper, getTypeParameterFromMappedType(type), key);
    const propType = instantiateType(getTemplateTypeFromMappedType(<MappedType>type.target || type), templateMapper);
    const modifiers = getMappedTypeModifiers(type);
    return strictNullChecks && modifiers & MappedTypeModifiers.IncludeOptional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void)
      ? getOptionalType(propType)
      : strictNullChecks && modifiers & MappedTypeModifiers.ExcludeOptional && isOptional
      ? getTypeWithFacts(propType, TypeFacts.NEUndefined)
      : propType;
  }
  function instantiateAnonymousType(type: AnonymousType, mapper: TypeMapper): AnonymousType {
    const result = <AnonymousType>createObjectType(type.objectFlags | ObjectFlags.Instantiated, type.symbol);
    if (type.objectFlags & ObjectFlags.Mapped) {
      (<MappedType>result).declaration = (<MappedType>type).declaration;
      const origTypeParameter = getTypeParameterFromMappedType(<MappedType>type);
      const freshTypeParameter = cloneTypeParameter(origTypeParameter);
      (<MappedType>result).typeParameter = freshTypeParameter;
      mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper);
      freshTypeParameter.mapper = mapper;
    }
    result.target = type;
    result.mapper = mapper;
    result.aliasSymbol = type.aliasSymbol;
    result.aliasTypeArguments = instantiateTypes(type.aliasTypeArguments, mapper);
    return result;
  }
  function getConditionalTypeInstantiation(type: ConditionalType, mapper: TypeMapper): Type {
    const root = type.root;
    if (root.outerTypeParameters) {
      const typeArguments = map(root.outerTypeParameters, (t) => getMappedType(t, mapper));
      const id = getTypeListId(typeArguments);
      let result = root.instantiations!.get(id);
      if (!result) {
        const newMapper = createTypeMapper(root.outerTypeParameters, typeArguments);
        result = instantiateConditionalType(root, newMapper);
        root.instantiations!.set(id, result);
      }
      return result;
    }
    return type;
  }
  function instantiateConditionalType(root: ConditionalRoot, mapper: TypeMapper): Type {
    if (root.isDistributive) {
      const checkType = <TypeParameter>root.checkType;
      const instantiatedType = getMappedType(checkType, mapper);
      if (checkType !== instantiatedType && instantiatedType.flags & (TypeFlags.Union | TypeFlags.Never))
        return mapType(instantiatedType, (t) => getConditionalType(root, prependTypeMapping(checkType, t, mapper)));
    }
    return getConditionalType(root, mapper);
  }
  function instantiateType(type: Type, mapper: TypeMapper | undefined): Type;
  function instantiateType(type: Type | undefined, mapper: TypeMapper | undefined): Type | undefined;
  function instantiateType(type: Type | undefined, mapper: TypeMapper | undefined): Type | undefined {
    if (!(type && mapper && couldContainTypeVariables(type))) return type;
    if (instantiationDepth === 50 || instantiationCount >= 5000000) {
      error(currentNode, qd.Type_instantiation_is_excessively_deep_and_possibly_infinite);
      return errorType;
    }
    totalInstantiationCount++;
    instantiationCount++;
    instantiationDepth++;
    const result = instantiateTypeWorker(type, mapper);
    instantiationDepth--;
    return result;
  }
  function instantiateTypeWithoutDepthIncrease(type: Type, mapper: TypeMapper | undefined) {
    instantiationDepth--;
    const result = instantiateType(type, mapper);
    instantiationDepth++;
    return result;
  }
  function instantiateTypeWorker(type: Type, mapper: TypeMapper): Type {
    const flags = type.flags;
    if (flags & TypeFlags.TypeParameter) return getMappedType(type, mapper);
    if (flags & TypeFlags.Object) {
      const objectFlags = (<ObjectType>type).objectFlags;
      if (objectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous | ObjectFlags.Mapped)) {
        if (objectFlags & ObjectFlags.Reference && !(<TypeReference>type).node) {
          const resolvedTypeArguments = (<TypeReference>type).resolvedTypeArguments;
          const newTypeArguments = instantiateTypes(resolvedTypeArguments, mapper);
          return newTypeArguments !== resolvedTypeArguments ? createTypeReference((<TypeReference>type).target, newTypeArguments) : type;
        }
        return getObjectTypeInstantiation(<TypeReference | AnonymousType | MappedType>type, mapper);
      }
      return type;
    }
    if (flags & TypeFlags.UnionOrIntersection) {
      const types = (<UnionOrIntersectionType>type).types;
      const newTypes = instantiateTypes(types, mapper);
      return newTypes === types
        ? type
        : flags & TypeFlags.Intersection
        ? getIntersectionType(newTypes, type.aliasSymbol, instantiateTypes(type.aliasTypeArguments, mapper))
        : getUnionType(newTypes, UnionReduction.Literal, type.aliasSymbol, instantiateTypes(type.aliasTypeArguments, mapper));
    }
    if (flags & TypeFlags.Index) return getIndexType(instantiateType((<IndexType>type).type, mapper));
    if (flags & TypeFlags.IndexedAccess) return getIndexedAccessType(instantiateType((<IndexedAccessType>type).objectType, mapper), instantiateType((<IndexedAccessType>type).indexType, mapper));
    if (flags & TypeFlags.Conditional) return getConditionalTypeInstantiation(<ConditionalType>type, combineTypeMappers((<ConditionalType>type).mapper, mapper));
    if (flags & TypeFlags.Substitution) {
      const maybeVariable = instantiateType((<SubstitutionType>type).baseType, mapper);
      if (maybeVariable.flags & TypeFlags.TypeVariable) return getSubstitutionType(maybeVariable as TypeVariable, instantiateType((<SubstitutionType>type).substitute, mapper));
      else {
        const sub = instantiateType((<SubstitutionType>type).substitute, mapper);
        if (sub.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(maybeVariable), getRestrictiveInstantiation(sub))) return maybeVariable;
        return sub;
      }
    }
    return type;
  }
  function getPermissiveInstantiation(type: Type) {
    return type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never)
      ? type
      : type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper));
  }
  function getRestrictiveInstantiation(type: Type) {
    if (type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never)) return type;
    if (type.restrictiveInstantiation) return type.restrictiveInstantiation;
    type.restrictiveInstantiation = instantiateType(type, restrictiveMapper);
    type.restrictiveInstantiation.restrictiveInstantiation = type.restrictiveInstantiation;
    return type.restrictiveInstantiation;
  }
  function instantiateIndexInfo(info: IndexInfo | undefined, mapper: TypeMapper): IndexInfo | undefined {
    return info && createIndexInfo(instantiateType(info.type, mapper), info.isReadonly, info.declaration);
  }
  function isContextSensitive(node: Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike | JsxChild): boolean {
    assert(node.kind !== Syntax.MethodDeclaration || qc.is.objectLiteralMethod(node));
    switch (node.kind) {
      case Syntax.FunctionExpression:
      case Syntax.ArrowFunction:
      case Syntax.MethodDeclaration:
      case Syntax.FunctionDeclaration:
        return isContextSensitiveFunctionLikeDeclaration(<FunctionExpression | ArrowFunction | MethodDeclaration>node);
      case Syntax.ObjectLiteralExpression:
        return some((<ObjectLiteralExpression>node).properties, isContextSensitive);
      case Syntax.ArrayLiteralExpression:
        return some((<ArrayLiteralExpression>node).elements, isContextSensitive);
      case Syntax.ConditionalExpression:
        return isContextSensitive((<ConditionalExpression>node).whenTrue) || isContextSensitive((<ConditionalExpression>node).whenFalse);
      case Syntax.BinaryExpression:
        return (
          ((<BinaryExpression>node).operatorToken.kind === Syntax.Bar2Token || (<BinaryExpression>node).operatorToken.kind === Syntax.Question2Token) &&
          (isContextSensitive((<BinaryExpression>node).left) || isContextSensitive((<BinaryExpression>node).right))
        );
      case Syntax.PropertyAssignment:
        return isContextSensitive((<PropertyAssignment>node).initializer);
      case Syntax.ParenthesizedExpression:
        return isContextSensitive((<ParenthesizedExpression>node).expression);
      case Syntax.JsxAttributes:
        return some((<JsxAttributes>node).properties, isContextSensitive) || (qc.is.kind(JsxOpeningElement, node.parent) && some(node.parent.parent.children, isContextSensitive));
      case Syntax.JsxAttribute: {
        const { initializer } = node as JsxAttribute;
        return !!initializer && isContextSensitive(initializer);
      }
      case Syntax.JsxExpression: {
        const { expression } = node as JsxExpression;
        return !!expression && isContextSensitive(expression);
      }
    }
    return false;
  }
  function isContextSensitiveFunctionLikeDeclaration(node: FunctionLikeDeclaration): boolean {
    return (
      (!qc.is.kind(FunctionDeclaration, node) || (isInJSFile(node) && !!getTypeForDeclarationFromJSDocComment(node))) &&
      (hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node))
    );
  }
  function hasContextSensitiveParameters(node: FunctionLikeDeclaration) {
    if (!node.typeParameters) {
      if (some(node.parameters, (p) => !getEffectiveTypeAnnotationNode(p))) return true;
      if (node.kind !== Syntax.ArrowFunction) {
        const parameter = firstOrUndefined(node.parameters);
        if (!(parameter && parameterIsThsyntax.is.keyword(parameter))) return true;
      }
    }
    return false;
  }
  function hasContextSensitiveReturnExpression(node: FunctionLikeDeclaration) {
    return !node.typeParameters && !getEffectiveReturnTypeNode(node) && !!node.body && node.body.kind !== Syntax.Block && isContextSensitive(node.body);
  }
  function isContextSensitiveFunctionOrObjectLiteralMethod(func: Node): func is FunctionExpression | ArrowFunction | MethodDeclaration {
    return (
      ((isInJSFile(func) && qc.is.kind(FunctionDeclaration, func)) || isFunctionExpressionOrArrowFunction(func) || qc.is.objectLiteralMethod(func)) && isContextSensitiveFunctionLikeDeclaration(func)
    );
  }
  function getTypeWithoutSignatures(type: Type): Type {
    if (type.flags & TypeFlags.Object) {
      const resolved = resolveStructuredTypeMembers(<ObjectType>type);
      if (resolved.constructSignatures.length || resolved.callSignatures.length) {
        const result = createObjectType(ObjectFlags.Anonymous, type.symbol);
        result.members = resolved.members;
        result.properties = resolved.properties;
        result.callSignatures = empty;
        result.constructSignatures = empty;
        return result;
      }
    } else if (type.flags & TypeFlags.Intersection) {
      return getIntersectionType(map((<IntersectionType>type).types, getTypeWithoutSignatures));
    }
    return type;
  }
  function isTypeIdenticalTo(source: Type, target: Type): boolean {
    return isTypeRelatedTo(source, target, identityRelation);
  }
  function compareTypesIdentical(source: Type, target: Type): Ternary {
    return isTypeRelatedTo(source, target, identityRelation) ? Ternary.True : Ternary.False;
  }
  function compareTypesAssignable(source: Type, target: Type): Ternary {
    return isTypeRelatedTo(source, target, assignableRelation) ? Ternary.True : Ternary.False;
  }
  function compareTypesSubtypeOf(source: Type, target: Type): Ternary {
    return isTypeRelatedTo(source, target, subtypeRelation) ? Ternary.True : Ternary.False;
  }
  function isTypeSubtypeOf(source: Type, target: Type): boolean {
    return isTypeRelatedTo(source, target, subtypeRelation);
  }
  function isTypeAssignableTo(source: Type, target: Type): boolean {
    return isTypeRelatedTo(source, target, assignableRelation);
  }
  function isTypeDerivedFrom(source: Type, target: Type): boolean {
    return source.flags & TypeFlags.Union
      ? every((<UnionType>source).types, (t) => isTypeDerivedFrom(t, target))
      : target.flags & TypeFlags.Union
      ? some((<UnionType>target).types, (t) => isTypeDerivedFrom(source, t))
      : source.flags & TypeFlags.InstantiableNonPrimitive
      ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target)
      : target === globalObjectType
      ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive))
      : target === globalFunctionType
      ? !!(source.flags & TypeFlags.Object) && isFunctionObjectType(source as ObjectType)
      : hasBaseType(source, getTargetType(target));
  }
  function isTypeComparableTo(source: Type, target: Type): boolean {
    return isTypeRelatedTo(source, target, comparableRelation);
  }
  function areTypesComparable(type1: Type, type2: Type): boolean {
    return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1);
  }
  function checkTypeAssignableTo(
    source: Type,
    target: Type,
    errorNode: Node | undefined,
    headMessage?: DiagnosticMessage,
    containingMessageChain?: () => DiagnosticMessageChain | undefined,
    errorOutputObject?: { errors?: Diagnostic[] }
  ): boolean {
    return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject);
  }
  function checkTypeAssignableToAndOptionallyElaborate(
    source: Type,
    target: Type,
    errorNode: Node | undefined,
    expr: Expression | undefined,
    headMessage?: DiagnosticMessage,
    containingMessageChain?: () => DiagnosticMessageChain | undefined
  ): boolean {
    return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, undefined);
  }
  function checkTypeRelatedToAndOptionallyElaborate(
    source: Type,
    target: Type,
    relation: qb.QMap<RelationComparisonResult>,
    errorNode: Node | undefined,
    expr: Expression | undefined,
    headMessage: DiagnosticMessage | undefined,
    containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
    errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean } | undefined
  ): boolean {
    if (isTypeRelatedTo(source, target, relation)) return true;
    if (!errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer))
      return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer);
    return false;
  }
  function isOrHasGenericConditional(type: Type): boolean {
    return !!(type.flags & TypeFlags.Conditional || (type.flags & TypeFlags.Intersection && some((type as IntersectionType).types, isOrHasGenericConditional)));
  }
  function elaborateError(
    node: Expression | undefined,
    source: Type,
    target: Type,
    relation: qb.QMap<RelationComparisonResult>,
    headMessage: DiagnosticMessage | undefined,
    containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
    errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean } | undefined
  ): boolean {
    if (!node || isOrHasGenericConditional(target)) return false;
    if (!checkTypeRelatedTo(source, target, relation, undefined) && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer))
      return true;
    switch (node.kind) {
      case Syntax.JsxExpression:
      case Syntax.ParenthesizedExpression:
        return elaborateError((node as ParenthesizedExpression | JsxExpression).expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
      case Syntax.BinaryExpression:
        switch ((node as BinaryExpression).operatorToken.kind) {
          case Syntax.EqualsToken:
          case Syntax.CommaToken:
            return elaborateError((node as BinaryExpression).right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
        }
        break;
      case Syntax.ObjectLiteralExpression:
        return elaborateObjectLiteral(node as ObjectLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);
      case Syntax.ArrayLiteralExpression:
        return elaborateArrayLiteral(node as ArrayLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);
      case Syntax.JsxAttributes:
        return elaborateJsxComponents(node as JsxAttributes, source, target, relation, containingMessageChain, errorOutputContainer);
      case Syntax.ArrowFunction:
        return elaborateArrowFunction(node as ArrowFunction, source, target, relation, containingMessageChain, errorOutputContainer);
    }
    return false;
  }
  function elaborateDidYouMeanToCallOrConstruct(
    node: Expression,
    source: Type,
    target: Type,
    relation: qb.QMap<RelationComparisonResult>,
    headMessage: DiagnosticMessage | undefined,
    containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
    errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean } | undefined
  ): boolean {
    const callSignatures = getSignaturesOfType(source, SignatureKind.Call);
    const constructSignatures = getSignaturesOfType(source, SignatureKind.Construct);
    for (const signatures of [constructSignatures, callSignatures]) {
      if (
        some(signatures, (s) => {
          const returnType = getReturnTypeOfSignature(s);
          return !(returnType.flags & (TypeFlags.Any | TypeFlags.Never)) && checkTypeRelatedTo(returnType, target, relation, undefined);
        })
      ) {
        const resultObj: { errors?: Diagnostic[] } = errorOutputContainer || {};
        checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj);
        const diagnostic = resultObj.errors![resultObj.errors!.length - 1];
        addRelatedInfo(diagnostic, createDiagnosticForNode(node, signatures === constructSignatures ? qd.Did_you_mean_to_use_new_with_this_expression : qd.Did_you_mean_to_call_this_expression));
        return true;
      }
    }
    return false;
  }
  function elaborateArrowFunction(
    node: ArrowFunction,
    source: Type,
    target: Type,
    relation: qb.QMap<RelationComparisonResult>,
    containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
    errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean } | undefined
  ): boolean {
    if (qc.is.kind(Block, node.body)) return false;
    if (some(node.parameters, qnr.hasType)) return false;
    const sourceSig = getSingleCallSignature(source);
    if (!sourceSig) return false;
    const targetSignatures = getSignaturesOfType(target, SignatureKind.Call);
    if (!length(targetSignatures)) return false;
    const returnExpression = node.body;
    const sourceReturn = getReturnTypeOfSignature(sourceSig);
    const targetReturn = getUnionType(map(targetSignatures, getReturnTypeOfSignature));
    if (!checkTypeRelatedTo(sourceReturn, targetReturn, relation, undefined)) {
      const elaborated = returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, undefined, containingMessageChain, errorOutputContainer);
      if (elaborated) return elaborated;
      const resultObj: { errors?: Diagnostic[] } = errorOutputContainer || {};
      checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, undefined, containingMessageChain, resultObj);
      if (resultObj.errors) {
        if (target.symbol && length(target.symbol.declarations)) {
          addRelatedInfo(resultObj.errors[resultObj.errors.length - 1], createDiagnosticForNode(target.symbol.declarations[0], qd.The_expected_type_comes_from_the_return_type_of_this_signature));
        }
        if (
          (getFunctionFlags(node) & FunctionFlags.Async) === 0 &&
          !getTypeOfPropertyOfType(sourceReturn, 'then' as __String) &&
          checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation, undefined)
        ) {
          addRelatedInfo(resultObj.errors[resultObj.errors.length - 1], createDiagnosticForNode(node, qd.Did_you_mean_to_mark_this_function_as_async));
        }
        return true;
      }
    }
    return false;
  }
  function getBestMatchIndexedAccessTypeOrUndefined(source: Type, target: Type, nameType: Type) {
    const idx = getIndexedAccessTypeOrUndefined(target, nameType);
    if (idx) return idx;
    if (target.flags & TypeFlags.Union) {
      const best = getBestMatchingType(source, target as UnionType);
      if (best) return getIndexedAccessTypeOrUndefined(best, nameType);
    }
  }
  function checkExpressionForMutableLocationWithContextualType(next: Expression, sourcePropType: Type) {
    next.contextualType = sourcePropType;
    try {
      return checkExpressionForMutableLocation(next, CheckMode.Contextual, sourcePropType);
    } finally {
      next.contextualType = undefined;
    }
  }
  type ElaborationIterator = IterableIterator<{
    errorNode: Node;
    innerExpression: Expression | undefined;
    nameType: Type;
    errorMessage?: DiagnosticMessage | undefined;
  }>;
  function elaborateElementwise(
    iterator: ElaborationIterator,
    source: Type,
    target: Type,
    relation: qb.QMap<RelationComparisonResult>,
    containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
    errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean } | undefined
  ) {
    let reportedError = false;
    for (let status = iterator.next(); !status.done; status = iterator.next()) {
      const { errorNode: prop, innerExpression: next, nameType, errorMessage } = status.value;
      const targetPropType = getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType);
      if (!targetPropType || targetPropType.flags & TypeFlags.IndexedAccess) continue;
      const sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);
      if (sourcePropType && !checkTypeRelatedTo(sourcePropType, targetPropType, relation, undefined)) {
        const elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, undefined, containingMessageChain, errorOutputContainer);
        if (elaborated) reportedError = true;
        else {
          const resultObj: { errors?: Diagnostic[] } = errorOutputContainer || {};
          const specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;
          const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
          if (result && specificSource !== sourcePropType) checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
          if (resultObj.errors) {
            const reportedDiag = resultObj.errors[resultObj.errors.length - 1];
            const propertyName = isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;
            const targetProp = propertyName !== undefined ? getPropertyOfType(target, propertyName) : undefined;
            let issuedElaboration = false;
            if (!targetProp) {
              const indexInfo = (isTypeAssignableToKind(nameType, TypeFlags.NumberLike) && getIndexInfoOfType(target, IndexKind.Number)) || getIndexInfoOfType(target, IndexKind.String) || undefined;
              if (indexInfo && indexInfo.declaration && !qc.get.sourceFileOf(indexInfo.declaration).hasNoDefaultLib) {
                issuedElaboration = true;
                addRelatedInfo(reportedDiag, createDiagnosticForNode(indexInfo.declaration, qd.The_expected_type_comes_from_this_index_signature));
              }
            }
            if (!issuedElaboration && ((targetProp && length(targetProp.declarations)) || (target.symbol && length(target.symbol.declarations)))) {
              const targetNode = targetProp && length(targetProp.declarations) ? targetProp.declarations[0] : target.symbol.declarations[0];
              if (!qc.get.sourceFileOf(targetNode).hasNoDefaultLib) {
                addRelatedInfo(
                  reportedDiag,
                  createDiagnosticForNode(
                    targetNode,
                    qd.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1,
                    propertyName && !(nameType.flags & TypeFlags.UniqueESSymbol) ? syntax.get.unescUnderscores(propertyName) : typeToString(nameType),
                    typeToString(target)
                  )
                );
              }
            }
          }
          reportedError = true;
        }
      }
    }
    return reportedError;
  }
  function* generateJsxAttributes(node: JsxAttributes): ElaborationIterator {
    if (!length(node.properties)) return;
    for (const prop of node.properties) {
      if (qc.is.kind(JsxSpreadAttribute, prop)) continue;
      yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: getLiteralType(idText(prop.name)) };
    }
  }
  function* generateJsxChildren(node: JsxElement, getInvalidTextDiagnostic: () => DiagnosticMessage): ElaborationIterator {
    if (!length(node.children)) return;
    let memberOffset = 0;
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      const nameType = getLiteralType(i - memberOffset);
      const elem = getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic);
      if (elem) yield elem;
      else {
        memberOffset++;
      }
    }
  }
  function getElaborationElementForJsxChild(child: JsxChild, nameType: LiteralType, getInvalidTextDiagnostic: () => DiagnosticMessage) {
    switch (child.kind) {
      case Syntax.JsxExpression:
        return { errorNode: child, innerExpression: child.expression, nameType };
      case Syntax.JsxText:
        if (child.onlyTriviaWhitespaces) break;
        return { errorNode: child, innerExpression: undefined, nameType, errorMessage: getInvalidTextDiagnostic() };
      case Syntax.JsxElement:
      case Syntax.JsxSelfClosingElement:
      case Syntax.JsxFragment:
        return { errorNode: child, innerExpression: child, nameType };
      default:
        return Debug.assertNever(child, 'Found invalid jsx child');
    }
    return;
  }
  function getSemanticJsxChildren(children: Nodes<JsxChild>) {
    return filter(children, (i) => !qc.is.kind(JsxText, i) || !i.onlyTriviaWhitespaces);
  }
  function elaborateJsxComponents(
    node: JsxAttributes,
    source: Type,
    target: Type,
    relation: qb.QMap<RelationComparisonResult>,
    containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
    errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean } | undefined
  ) {
    let result = elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer);
    let invalidTextDiagnostic: DiagnosticMessage | undefined;
    if (qc.is.kind(JsxOpeningElement, node.parent) && qc.is.kind(JsxElement, node.parent.parent)) {
      const containingElement = node.parent.parent;
      const childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
      const childrenPropName = childPropName === undefined ? 'children' : syntax.get.unescUnderscores(childPropName);
      const childrenNameType = getLiteralType(childrenPropName);
      const childrenTargetType = getIndexedAccessType(target, childrenNameType);
      const validChildren = getSemanticJsxChildren(containingElement.children);
      if (!length(validChildren)) return result;
      const moreThanOneRealChildren = length(validChildren) > 1;
      const arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType);
      const nonArrayLikeTargetParts = filterType(childrenTargetType, (t) => !isArrayOrTupleLikeType(t));
      if (moreThanOneRealChildren) {
        if (arrayLikeTargetParts !== neverType) {
          const realSource = createTupleType(checkJsxChildren(containingElement, CheckMode.Normal));
          const children = generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic);
          result = elaborateElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result;
        } else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
          result = true;
          const diag = error(
            containingElement.openingElement.tagName,
            qd.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided,
            childrenPropName,
            typeToString(childrenTargetType)
          );
          if (errorOutputContainer && errorOutputContainer.skipLogging) (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
        }
      } else {
        if (nonArrayLikeTargetParts !== neverType) {
          const child = validChildren[0];
          const elem = getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic);
          if (elem) {
            result =
              elaborateElementwise(
                (function* () {
                  yield elem;
                })(),
                source,
                target,
                relation,
                containingMessageChain,
                errorOutputContainer
              ) || result;
          }
        } else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
          result = true;
          const diag = error(
            containingElement.openingElement.tagName,
            qd.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided,
            childrenPropName,
            typeToString(childrenTargetType)
          );
          if (errorOutputContainer && errorOutputContainer.skipLogging) (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
        }
      }
    }
    return result;
    function getInvalidTextualChildDiagnostic() {
      if (!invalidTextDiagnostic) {
        const tagNameText = qc.get.textOf(node.parent.tagName);
        const childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
        const childrenPropName = childPropName === undefined ? 'children' : syntax.get.unescUnderscores(childPropName);
        const childrenTargetType = getIndexedAccessType(target, getLiteralType(childrenPropName));
        const diagnostic = qd._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2;
        invalidTextDiagnostic = {
          ...diagnostic,
          key: '!!ALREADY FORMATTED!!',
          message: formatMessage(undefined, diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)),
        };
      }
      return invalidTextDiagnostic;
    }
  }
  function* generateLimitedTupleElements(node: ArrayLiteralExpression, target: Type): ElaborationIterator {
    const len = length(node.elements);
    if (!len) return;
    for (let i = 0; i < len; i++) {
      if (isTupleLikeType(target) && !getPropertyOfType(target, ('' + i) as __String)) continue;
      const elem = node.elements[i];
      if (qc.is.kind(OmittedExpression, elem)) continue;
      const nameType = getLiteralType(i);
      yield { errorNode: elem, innerExpression: elem, nameType };
    }
  }
  function elaborateArrayLiteral(
    node: ArrayLiteralExpression,
    source: Type,
    target: Type,
    relation: qb.QMap<RelationComparisonResult>,
    containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
    errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean } | undefined
  ) {
    if (target.flags & TypeFlags.Primitive) return false;
    if (isTupleLikeType(source)) return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer);
    const oldContext = node.contextualType;
    node.contextualType = target;
    try {
      const tupleizedType = checkArrayLiteral(node, CheckMode.Contextual, true);
      node.contextualType = oldContext;
      if (isTupleLikeType(tupleizedType)) return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer);
      return false;
    } finally {
      node.contextualType = oldContext;
    }
  }
  function* generateObjectLiteralElements(node: ObjectLiteralExpression): ElaborationIterator {
    if (!length(node.properties)) return;
    for (const prop of node.properties) {
      if (qc.is.kind(SpreadAssignment, prop)) continue;
      const type = getLiteralTypeFromProperty(getSymbolOfNode(prop), TypeFlags.StringOrNumberLiteralOrUnique);
      if (!type || type.flags & TypeFlags.Never) continue;
      switch (prop.kind) {
        case Syntax.SetAccessor:
        case Syntax.GetAccessor:
        case Syntax.MethodDeclaration:
        case Syntax.ShorthandPropertyAssignment:
          yield { errorNode: prop.name, innerExpression: undefined, nameType: type };
          break;
        case Syntax.PropertyAssignment:
          yield {
            errorNode: prop.name,
            innerExpression: prop.initializer,
            nameType: type,
            errorMessage: isComputedNonLiteralName(prop.name) ? qd.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : undefined,
          };
          break;
        default:
          Debug.assertNever(prop);
      }
    }
  }
  function elaborateObjectLiteral(
    node: ObjectLiteralExpression,
    source: Type,
    target: Type,
    relation: qb.QMap<RelationComparisonResult>,
    containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
    errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean } | undefined
  ) {
    if (target.flags & TypeFlags.Primitive) return false;
    return elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer);
  }
  function checkTypeComparableTo(source: Type, target: Type, errorNode: Node, headMessage?: DiagnosticMessage, containingMessageChain?: () => DiagnosticMessageChain | undefined): boolean {
    return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain);
  }
  function isSignatureAssignableTo(source: Signature, target: Signature, ignoreReturnTypes: boolean): boolean {
    return compareSignaturesRelated(source, target, ignoreReturnTypes ? SignatureCheckMode.IgnoreReturnTypes : 0, false, undefined, undefined, compareTypesAssignable, undefined) !== Ternary.False;
  }
  type ErrorReporter = (message: DiagnosticMessage, arg0?: string, arg1?: string) => void;
  function isAnySignature(s: Signature) {
    return (
      !s.typeParameters &&
      (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) &&
      s.parameters.length === 1 &&
      signatureHasRestParameter(s) &&
      (getTypeOfParameter(s.parameters[0]) === anyArrayType || isTypeAny(getTypeOfParameter(s.parameters[0]))) &&
      isTypeAny(getReturnTypeOfSignature(s))
    );
  }
  function compareSignaturesRelated(
    source: Signature,
    target: Signature,
    checkMode: SignatureCheckMode,
    reportErrors: boolean,
    errorReporter: ErrorReporter | undefined,
    incompatibleErrorReporter: ((source: Type, target: Type) => void) | undefined,
    compareTypes: TypeComparer,
    reportUnreliableMarkers: TypeMapper | undefined
  ): Ternary {
    if (source === target) return Ternary.True;
    if (isAnySignature(target)) return Ternary.True;
    const targetCount = getParameterCount(target);
    const sourceHasMoreParameters =
      !hasEffectiveRestParameter(target) &&
      (checkMode & SignatureCheckMode.StrictArity ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount);
    if (sourceHasMoreParameters) return Ternary.False;
    if (source.typeParameters && source.typeParameters !== target.typeParameters) {
      target = getCanonicalSignature(target);
      source = instantiateSignatureInContextOf(source, target, undefined, compareTypes);
    }
    const sourceCount = getParameterCount(source);
    const sourceRestType = getNonArrayRestType(source);
    const targetRestType = getNonArrayRestType(target);
    if (sourceRestType || targetRestType) void instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers);
    if (sourceRestType && targetRestType && sourceCount !== targetCount) return Ternary.False;
    const kind = target.declaration ? target.declaration.kind : Syntax.Unknown;
    const strictVariance = !(checkMode & SignatureCheckMode.Callback) && strictFunctionTypes && kind !== Syntax.MethodDeclaration && kind !== Syntax.MethodSignature && kind !== Syntax.Constructor;
    let result = Ternary.True;
    const sourceThisType = getThisTypeOfSignature(source);
    if (sourceThisType && sourceThisType !== voidType) {
      const targetThisType = getThisTypeOfSignature(target);
      if (targetThisType) {
        const related = (!strictVariance && compareTypes(sourceThisType, targetThisType, false)) || compareTypes(targetThisType, sourceThisType, reportErrors);
        if (!related) {
          if (reportErrors) errorReporter!(qd.The_this_types_of_each_signature_are_incompatible);
          return Ternary.False;
        }
        result &= related;
      }
    }
    const paramCount = sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount);
    const restIndex = sourceRestType || targetRestType ? paramCount - 1 : -1;
    for (let i = 0; i < paramCount; i++) {
      const sourceType = i === restIndex ? getRestTypeAtPosition(source, i) : getTypeAtPosition(source, i);
      const targetType = i === restIndex ? getRestTypeAtPosition(target, i) : getTypeAtPosition(target, i);
      const sourceSig = checkMode & SignatureCheckMode.Callback ? undefined : getSingleCallSignature(getNonNullableType(sourceType));
      const targetSig = checkMode & SignatureCheckMode.Callback ? undefined : getSingleCallSignature(getNonNullableType(targetType));
      const callbacks =
        sourceSig &&
        targetSig &&
        !getTypePredicateOfSignature(sourceSig) &&
        !getTypePredicateOfSignature(targetSig) &&
        (getFalsyFlags(sourceType) & TypeFlags.Nullable) === (getFalsyFlags(targetType) & TypeFlags.Nullable);
      let related = callbacks
        ? compareSignaturesRelated(
            targetSig!,
            sourceSig!,
            (checkMode & SignatureCheckMode.StrictArity) | (strictVariance ? SignatureCheckMode.StrictCallback : SignatureCheckMode.BivariantCallback),
            reportErrors,
            errorReporter,
            incompatibleErrorReporter,
            compareTypes,
            reportUnreliableMarkers
          )
        : (!(checkMode & SignatureCheckMode.Callback) && !strictVariance && compareTypes(sourceType, targetType, false)) || compareTypes(targetType, sourceType, reportErrors);
      if (related && checkMode & SignatureCheckMode.StrictArity && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, false))
        related = Ternary.False;
      if (!related) {
        if (reportErrors) {
          errorReporter!(
            qd.Types_of_parameters_0_and_1_are_incompatible,
            syntax.get.unescUnderscores(getParameterNameAtPosition(source, i)),
            syntax.get.unescUnderscores(getParameterNameAtPosition(target, i))
          );
        }
        return Ternary.False;
      }
      result &= related;
    }
    if (!(checkMode & SignatureCheckMode.IgnoreReturnTypes)) {
      const targetReturnType = isResolvingReturnTypeOfSignature(target)
        ? anyType
        : target.declaration && isJSConstructor(target.declaration)
        ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol))
        : getReturnTypeOfSignature(target);
      if (targetReturnType === voidType) return result;
      const sourceReturnType = isResolvingReturnTypeOfSignature(source)
        ? anyType
        : source.declaration && isJSConstructor(source.declaration)
        ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol))
        : getReturnTypeOfSignature(source);
      const targetTypePredicate = getTypePredicateOfSignature(target);
      if (targetTypePredicate) {
        const sourceTypePredicate = getTypePredicateOfSignature(source);
        if (sourceTypePredicate) result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes);
        else if (isIdentifierTypePredicate(targetTypePredicate)) {
          if (reportErrors) errorReporter!(qd.Signature_0_must_be_a_type_predicate, signatureToString(source));
          return Ternary.False;
        }
      } else {
        result &= (checkMode & SignatureCheckMode.BivariantCallback && compareTypes(targetReturnType, sourceReturnType, false)) || compareTypes(sourceReturnType, targetReturnType, reportErrors);
        if (!result && reportErrors && incompatibleErrorReporter) incompatibleErrorReporter(sourceReturnType, targetReturnType);
      }
    }
    return result;
  }
  function compareTypePredicateRelatedTo(
    source: TypePredicate,
    target: TypePredicate,
    reportErrors: boolean,
    errorReporter: ErrorReporter | undefined,
    compareTypes: (s: Type, t: Type, reportErrors?: boolean) => Ternary
  ): Ternary {
    if (source.kind !== target.kind) {
      if (reportErrors) {
        errorReporter!(qd.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard);
        errorReporter!(qd.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
      }
      return Ternary.False;
    }
    if (source.kind === TypePredicateKind.Identifier || source.kind === TypePredicateKind.AssertsIdentifier) {
      if (source.parameterIndex !== (target as IdentifierTypePredicate).parameterIndex) {
        if (reportErrors) {
          errorReporter!(qd.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, (target as IdentifierTypePredicate).parameterName);
          errorReporter!(qd.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
        }
        return Ternary.False;
      }
    }
    const related = source.type === target.type ? Ternary.True : source.type && target.type ? compareTypes(source.type, target.type, reportErrors) : Ternary.False;
    if (related === Ternary.False && reportErrors) errorReporter!(qd.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
    return related;
  }
  function isImplementationCompatibleWithOverload(implementation: Signature, overload: Signature): boolean {
    const erasedSource = getErasedSignature(implementation);
    const erasedTarget = getErasedSignature(overload);
    const sourceReturnType = getReturnTypeOfSignature(erasedSource);
    const targetReturnType = getReturnTypeOfSignature(erasedTarget);
    if (targetReturnType === voidType || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation) || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation))
      return isSignatureAssignableTo(erasedSource, erasedTarget, true);
    return false;
  }
  function isEmptyResolvedType(t: ResolvedType) {
    return t !== anyFunctionType && t.properties.length === 0 && t.callSignatures.length === 0 && t.constructSignatures.length === 0 && !t.stringIndexInfo && !t.numberIndexInfo;
  }
  function isEmptyObjectType(type: Type): boolean {
    return type.flags & TypeFlags.Object
      ? !isGenericMappedType(type) && isEmptyResolvedType(resolveStructuredTypeMembers(<ObjectType>type))
      : type.flags & TypeFlags.NonPrimitive
      ? true
      : type.flags & TypeFlags.Union
      ? some((<UnionType>type).types, isEmptyObjectType)
      : type.flags & TypeFlags.Intersection
      ? every((<UnionType>type).types, isEmptyObjectType)
      : false;
  }
  function isEmptyAnonymousObjectType(type: Type) {
    return !!(
      getObjectFlags(type) & ObjectFlags.Anonymous &&
      (((<ResolvedType>type).members && isEmptyResolvedType(<ResolvedType>type)) || (type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral && getMembersOfSymbol(type.symbol).size === 0))
    );
  }
  function isStringIndexSignatureOnlyType(type: Type): boolean {
    return (
      (type.flags & TypeFlags.Object &&
        !isGenericMappedType(type) &&
        getPropertiesOfType(type).length === 0 &&
        getIndexInfoOfType(type, IndexKind.String) &&
        !getIndexInfoOfType(type, IndexKind.Number)) ||
      (type.flags & TypeFlags.UnionOrIntersection && every((<UnionOrIntersectionType>type).types, isStringIndexSignatureOnlyType)) ||
      false
    );
  }
  function isEnumTypeRelatedTo(sourceSymbol: Symbol, targetSymbol: Symbol, errorReporter?: ErrorReporter) {
    if (sourceSymbol === targetSymbol) return true;
    const id = sourceSymbol.getId() + ',' + targetSymbol.getId();
    const entry = enumRelation.get(id);
    if (entry !== undefined && !(!(entry & RelationComparisonResult.Reported) && entry & RelationComparisonResult.Failed && errorReporter)) return !!(entry & RelationComparisonResult.Succeeded);
    if (sourceSymbol.escName !== targetSymbol.escName || !(sourceSymbol.flags & SymbolFlags.RegularEnum) || !(targetSymbol.flags & SymbolFlags.RegularEnum)) {
      enumRelation.set(id, RelationComparisonResult.Failed | RelationComparisonResult.Reported);
      return false;
    }
    const targetEnumType = getTypeOfSymbol(targetSymbol);
    for (const property of getPropertiesOfType(getTypeOfSymbol(sourceSymbol))) {
      if (property.flags & SymbolFlags.EnumMember) {
        const targetProperty = getPropertyOfType(targetEnumType, property.escName);
        if (!targetProperty || !(targetProperty.flags & SymbolFlags.EnumMember)) {
          if (errorReporter) {
            errorReporter(qd.Property_0_is_missing_in_type_1, property.name, typeToString(getDeclaredTypeOfSymbol(targetSymbol), undefined, TypeFormatFlags.UseFullyQualifiedType));
            enumRelation.set(id, RelationComparisonResult.Failed | RelationComparisonResult.Reported);
          } else enumRelation.set(id, RelationComparisonResult.Failed);
          return false;
        }
      }
    }
    enumRelation.set(id, RelationComparisonResult.Succeeded);
    return true;
  }
  function isSimpleTypeRelatedTo(source: Type, target: Type, relation: qb.QMap<RelationComparisonResult>, errorReporter?: ErrorReporter) {
    const s = source.flags;
    const t = target.flags;
    if (t & TypeFlags.AnyOrUnknown || s & TypeFlags.Never || source === wildcardType) return true;
    if (t & TypeFlags.Never) return false;
    if (s & TypeFlags.StringLike && t & TypeFlags.String) return true;
    if (
      s & TypeFlags.StringLiteral &&
      s & TypeFlags.EnumLiteral &&
      t & TypeFlags.StringLiteral &&
      !(t & TypeFlags.EnumLiteral) &&
      (<StringLiteralType>source).value === (<StringLiteralType>target).value
    )
      return true;
    if (s & TypeFlags.NumberLike && t & TypeFlags.Number) return true;
    if (
      s & TypeFlags.NumberLiteral &&
      s & TypeFlags.EnumLiteral &&
      t & TypeFlags.NumberLiteral &&
      !(t & TypeFlags.EnumLiteral) &&
      (<NumberLiteralType>source).value === (<NumberLiteralType>target).value
    )
      return true;
    if (s & TypeFlags.BigIntLike && t & TypeFlags.BigInt) return true;
    if (s & TypeFlags.BooleanLike && t & TypeFlags.Boolean) return true;
    if (s & TypeFlags.ESSymbolLike && t & TypeFlags.ESSymbol) return true;
    if (s & TypeFlags.Enum && t & TypeFlags.Enum && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter)) return true;
    if (s & TypeFlags.EnumLiteral && t & TypeFlags.EnumLiteral) {
      if (s & TypeFlags.Union && t & TypeFlags.Union && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter)) return true;
      if (
        s & TypeFlags.Literal &&
        t & TypeFlags.Literal &&
        (<LiteralType>source).value === (<LiteralType>target).value &&
        isEnumTypeRelatedTo(getParentOfSymbol(source.symbol)!, getParentOfSymbol(target.symbol)!, errorReporter)
      )
        return true;
    }
    if (s & TypeFlags.Undefined && (!strictNullChecks || t & (TypeFlags.Undefined | TypeFlags.Void))) return true;
    if (s & TypeFlags.Null && (!strictNullChecks || t & TypeFlags.Null)) return true;
    if (s & TypeFlags.Object && t & TypeFlags.NonPrimitive) return true;
    if (relation === assignableRelation || relation === comparableRelation) {
      if (s & TypeFlags.Any) return true;
      if (s & (TypeFlags.Number | TypeFlags.NumberLiteral) && !(s & TypeFlags.EnumLiteral) && (t & TypeFlags.Enum || (t & TypeFlags.NumberLiteral && t & TypeFlags.EnumLiteral))) return true;
    }
    return false;
  }
  function isTypeRelatedTo(source: Type, target: Type, relation: qb.QMap<RelationComparisonResult>) {
    if (isFreshLiteralType(source)) source = (<FreshableType>source).regularType;
    if (isFreshLiteralType(target)) target = (<FreshableType>target).regularType;
    if (source === target) return true;
    if (relation !== identityRelation) {
      if ((relation === comparableRelation && !(target.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(target, source, relation)) || isSimpleTypeRelatedTo(source, target, relation)) return true;
    } else {
      if (!(source.flags & TypeFlags.UnionOrIntersection) && !(target.flags & TypeFlags.UnionOrIntersection) && source.flags !== target.flags && !(source.flags & TypeFlags.Substructure)) return false;
    }
    if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {
      const related = relation.get(getRelationKey(source, target, IntersectionState.None, relation));
      if (related !== undefined) return !!(related & RelationComparisonResult.Succeeded);
    }
    if (source.flags & TypeFlags.StructuredOrInstantiable || target.flags & TypeFlags.StructuredOrInstantiable) return checkTypeRelatedTo(source, target, relation, undefined);
    return false;
  }
  function isIgnoredJsxProperty(source: Type, sourceProp: Symbol) {
    return getObjectFlags(source) & ObjectFlags.JsxAttributes && !isUnhyphenatedJsxName(sourceProp.escName);
  }
  function getNormalizedType(type: Type, writing: boolean): Type {
    while (true) {
      const t = isFreshLiteralType(type)
        ? (<FreshableType>type).regularType
        : getObjectFlags(type) & ObjectFlags.Reference && (<TypeReference>type).node
        ? createTypeReference((<TypeReference>type).target, getTypeArguments(<TypeReference>type))
        : type.flags & TypeFlags.UnionOrIntersection
        ? getReducedType(type)
        : type.flags & TypeFlags.Substitution
        ? writing
          ? (<SubstitutionType>type).baseType
          : (<SubstitutionType>type).substitute
        : type.flags & TypeFlags.Simplifiable
        ? getSimplifiedType(type, writing)
        : type;
      if (t === type) break;
      type = t;
    }
    return type;
  }
  function checkTypeRelatedTo(
    source: Type,
    target: Type,
    relation: qb.QMap<RelationComparisonResult>,
    errorNode: Node | undefined,
    headMessage?: DiagnosticMessage,
    containingMessageChain?: () => DiagnosticMessageChain | undefined,
    errorOutputContainer?: { errors?: Diagnostic[]; skipLogging?: boolean }
  ): boolean {
    let errorInfo: DiagnosticMessageChain | undefined;
    let relatedInfo: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined;
    let maybeKeys: string[];
    let sourceStack: Type[];
    let targetStack: Type[];
    let maybeCount = 0;
    let depth = 0;
    let expandingFlags = ExpandingFlags.None;
    let overflow = false;
    let overrideNextErrorInfo = 0;
    let lastSkippedInfo: [Type, Type] | undefined;
    let incompatibleStack: [DiagnosticMessage, (string | number)?, (string | number)?, (string | number)?, (string | number)?][] = [];
    let inPropertyCheck = false;
    assert(relation !== identityRelation || !errorNode, 'no error reporting in identity checking');
    const result = isRelatedTo(source, target, !!errorNode, headMessage);
    if (incompatibleStack.length) reportIncompatibleStack();
    if (overflow) {
      const diag = error(errorNode || currentNode, qd.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));
      if (errorOutputContainer) (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
    } else if (errorInfo) {
      if (containingMessageChain) {
        const chain = containingMessageChain();
        if (chain) {
          concatenateDiagnosticMessageChains(chain, errorInfo);
          errorInfo = chain;
        }
      }
      let relatedInformation: DiagnosticRelatedInformation[] | undefined;
      if (headMessage && errorNode && !result && source.symbol) {
        const links = s.getLinks(source.symbol);
        if (links.originatingImport && !qc.is.importCall(links.originatingImport)) {
          const helpfulRetry = checkTypeRelatedTo(getTypeOfSymbol(links.target!), target, relation, undefined);
          if (helpfulRetry) {
            const diag = createDiagnosticForNode(
              links.originatingImport,
              qd.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead
            );
            relatedInformation = append(relatedInformation, diag);
          }
        }
      }
      const diag = createDiagnosticForNodeFromMessageChain(errorNode!, errorInfo, relatedInformation);
      if (relatedInfo) addRelatedInfo(diag, ...relatedInfo);
      if (errorOutputContainer) (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
      if (!errorOutputContainer || !errorOutputContainer.skipLogging) diagnostics.add(diag);
    }
    if (errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result === Ternary.False) assert(!!errorOutputContainer.errors, 'missed opportunity to interact with error.');
    return result !== Ternary.False;
    function resetErrorInfo(saved: ReturnType<typeof captureErrorCalculationState>) {
      errorInfo = saved.errorInfo;
      lastSkippedInfo = saved.lastSkippedInfo;
      incompatibleStack = saved.incompatibleStack;
      overrideNextErrorInfo = saved.overrideNextErrorInfo;
      relatedInfo = saved.relatedInfo;
    }
    function captureErrorCalculationState() {
      return {
        errorInfo,
        lastSkippedInfo,
        incompatibleStack: incompatibleStack.slice(),
        overrideNextErrorInfo,
        relatedInfo: !relatedInfo ? undefined : (relatedInfo.slice() as [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined),
      };
    }
    function reportIncompatibleError(message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number) {
      overrideNextErrorInfo++;
      lastSkippedInfo = undefined;
      incompatibleStack.push([message, arg0, arg1, arg2, arg3]);
    }
    function reportIncompatibleStack() {
      const stack = incompatibleStack;
      incompatibleStack = [];
      const info = lastSkippedInfo;
      lastSkippedInfo = undefined;
      if (stack.length === 1) {
        reportError(...stack[0]);
        if (info) reportRelationError(undefined, ...info);
        return;
      }
      let path = '';
      const secondaryRootErrors: typeof incompatibleStack = [];
      while (stack.length) {
        const [msg, ...args] = stack.pop()!;
        switch (msg.code) {
          case qd.Types_of_property_0_are_incompatible.code: {
            if (path.indexOf('new ') === 0) path = `(${path})`;
            const str = '' + args[0];
            if (path.length === 0) path = `${str}`;
            else if (syntax.is.identifierText(str)) {
              path = `${path}.${str}`;
            } else if (str[0] === '[' && str[str.length - 1] === ']') {
              path = `${path}${str}`;
            } else {
              path = `${path}[${str}]`;
            }
            break;
          }
          case qd.Call_signature_return_types_0_and_1_are_incompatible.code:
          case qd.Construct_signature_return_types_0_and_1_are_incompatible.code:
          case qd.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
          case qd.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code: {
            if (path.length === 0) {
              let mappedMsg = msg;
              if (msg.code === qd.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) mappedMsg = qd.Call_signature_return_types_0_and_1_are_incompatible;
              else if (msg.code === qd.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {
                mappedMsg = qd.Construct_signature_return_types_0_and_1_are_incompatible;
              }
              secondaryRootErrors.unshift([mappedMsg, args[0], args[1]]);
            } else {
              const prefix =
                msg.code === qd.Construct_signature_return_types_0_and_1_are_incompatible.code || msg.code === qd.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code
                  ? 'new '
                  : '';
              const params =
                msg.code === qd.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code ||
                msg.code === qd.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code
                  ? ''
                  : '...';
              path = `${prefix}${path}(${params})`;
            }
            break;
          }
          default:
            return fail(`Unhandled Diagnostic: ${msg.code}`);
        }
      }
      if (path) reportError(path[path.length - 1] === ')' ? qd.The_types_returned_by_0_are_incompatible_between_these_types : qd.The_types_of_0_are_incompatible_between_these_types, path);
      else {
        secondaryRootErrors.shift();
      }
      for (const [msg, ...args] of secondaryRootErrors) {
        const originalValue = msg.elidedInCompatabilityPyramid;
        msg.elidedInCompatabilityPyramid = false;
        reportError(msg, ...args);
        msg.elidedInCompatabilityPyramid = originalValue;
      }
      if (info) reportRelationError(undefined, ...info);
    }
    function reportError(message: DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number, arg3?: string | number): void {
      assert(!!errorNode);
      if (incompatibleStack.length) reportIncompatibleStack();
      if (message.elidedInCompatabilityPyramid) return;
      errorInfo = chainDiagnosticMessages(errorInfo, message, arg0, arg1, arg2, arg3);
    }
    function associateRelatedInfo(info: DiagnosticRelatedInformation) {
      assert(!!errorInfo);
      if (!relatedInfo) relatedInfo = [info];
      else {
        relatedInfo.push(info);
      }
    }
    function reportRelationError(message: DiagnosticMessage | undefined, source: Type, target: Type) {
      if (incompatibleStack.length) reportIncompatibleStack();
      const [sourceType, targetType] = getTypeNamesForErrorDisplay(source, target);
      let generalizedSource = source;
      let generalizedSourceType = sourceType;
      if (isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target)) {
        generalizedSource = getBaseTypeOfLiteralType(source);
        generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource);
      }
      if (target.flags & TypeFlags.TypeParameter) {
        const constraint = getBaseConstraintOfType(target);
        let needsOriginalSource;
        if (constraint && (isTypeAssignableTo(generalizedSource, constraint) || (needsOriginalSource = isTypeAssignableTo(source, constraint)))) {
          reportError(
            qd._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2,
            needsOriginalSource ? sourceType : generalizedSourceType,
            targetType,
            typeToString(constraint)
          );
        } else {
          reportError(qd._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1, targetType, generalizedSourceType);
        }
      }
      if (!message) {
        if (relation === comparableRelation) message = qd.Type_0_is_not_comparable_to_type_1;
        else if (sourceType === targetType) {
          message = qd.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated;
        } else {
          message = qd.Type_0_is_not_assignable_to_type_1;
        }
      }
      reportError(message, generalizedSourceType, targetType);
    }
    function tryElaborateErrorsForPrimitivesAndObjects(source: Type, target: Type) {
      const sourceType = symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(source, source.symbol.valueDeclaration) : typeToString(source);
      const targetType = symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(target, target.symbol.valueDeclaration) : typeToString(target);
      if (
        (globalStringType === source && stringType === target) ||
        (globalNumberType === source && numberType === target) ||
        (globalBooleanType === source && booleanType === target) ||
        (getGlobalESSymbolType(false) === source && esSymbolType === target)
      ) {
        reportError(qd._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType);
      }
    }
    function tryElaborateArrayLikeErrors(source: Type, target: Type, reportErrors: boolean): boolean {
      if (isTupleType(source)) {
        if (source.target.readonly && isMutableArrayOrTuple(target)) {
          if (reportErrors) reportError(qd.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target));
          return false;
        }
        return isTupleType(target) || isArrayType(target);
      }
      if (isReadonlyArrayType(source) && isMutableArrayOrTuple(target)) {
        if (reportErrors) reportError(qd.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target));
        return false;
      }
      if (isTupleType(target)) return isArrayType(source);
      return true;
    }
    function isRelatedTo(originalSource: Type, originalTarget: Type, reportErrors = false, headMessage?: DiagnosticMessage, intersectionState = IntersectionState.None): Ternary {
      if (originalSource.flags & TypeFlags.Object && originalTarget.flags & TypeFlags.Primitive) {
        if (isSimpleTypeRelatedTo(originalSource, originalTarget, relation, reportErrors ? reportError : undefined)) return Ternary.True;
        reportErrorResults(originalSource, originalTarget, Ternary.False, !!(getObjectFlags(originalSource) & ObjectFlags.JsxAttributes));
        return Ternary.False;
      }
      const source = getNormalizedType(originalSource, false);
      let target = getNormalizedType(originalTarget, true);
      if (source === target) return Ternary.True;
      if (relation === identityRelation) return isIdenticalTo(source, target);
      if (source.flags & TypeFlags.TypeParameter && getConstraintOfType(source) === target) return Ternary.True;
      if (target.flags & TypeFlags.Union && source.flags & TypeFlags.Object && (target as UnionType).types.length <= 3 && maybeTypeOfKind(target, TypeFlags.Nullable)) {
        const nullStrippedTarget = extractTypesOfKind(target, ~TypeFlags.Nullable);
        if (!(nullStrippedTarget.flags & (TypeFlags.Union | TypeFlags.Never))) {
          if (source === nullStrippedTarget) return Ternary.True;
          target = nullStrippedTarget;
        }
      }
      if (
        (relation === comparableRelation && !(target.flags & TypeFlags.Never) && isSimpleTypeRelatedTo(target, source, relation)) ||
        isSimpleTypeRelatedTo(source, target, relation, reportErrors ? reportError : undefined)
      )
        return Ternary.True;
      const isComparingJsxAttributes = !!(getObjectFlags(source) & ObjectFlags.JsxAttributes);
      const isPerformingExcessPropertyChecks = !(intersectionState & IntersectionState.Target) && isObjectLiteralType(source) && getObjectFlags(source) & ObjectFlags.FreshLiteral;
      if (isPerformingExcessPropertyChecks) {
        if (hasExcessProperties(<FreshObjectLiteralType>source, target, reportErrors)) {
          if (reportErrors) reportRelationError(headMessage, source, target);
          return Ternary.False;
        }
      }
      const isPerformingCommonPropertyChecks =
        relation !== comparableRelation &&
        !(intersectionState & IntersectionState.Target) &&
        source.flags & (TypeFlags.Primitive | TypeFlags.Object | TypeFlags.Intersection) &&
        source !== globalObjectType &&
        target.flags & (TypeFlags.Object | TypeFlags.Intersection) &&
        isWeakType(target) &&
        (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source));
      if (isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, isComparingJsxAttributes)) {
        if (reportErrors) {
          const calls = getSignaturesOfType(source, SignatureKind.Call);
          const constructs = getSignaturesOfType(source, SignatureKind.Construct);
          if ((calls.length > 0 && isRelatedTo(getReturnTypeOfSignature(calls[0]), target, false)) || (constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature(constructs[0]), target, false)))
            reportError(qd.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, typeToString(source), typeToString(target));
          else {
            reportError(qd.Type_0_has_no_properties_in_common_with_type_1, typeToString(source), typeToString(target));
          }
        }
        return Ternary.False;
      }
      let result = Ternary.False;
      const saveErrorInfo = captureErrorCalculationState();
      if (source.flags & TypeFlags.Union) {
        result =
          relation === comparableRelation
            ? someTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState)
            : eachTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState);
      } else {
        if (target.flags & TypeFlags.Union)
          result = typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), <UnionType>target, reportErrors && !(source.flags & TypeFlags.Primitive) && !(target.flags & TypeFlags.Primitive));
        else if (target.flags & TypeFlags.Intersection) {
          result = typeRelatedToEachType(getRegularTypeOfObjectLiteral(source), target as IntersectionType, reportErrors, IntersectionState.Target);
        } else if (source.flags & TypeFlags.Intersection) {
          result = someTypeRelatedToType(<IntersectionType>source, target, false, IntersectionState.Source);
        }
        if (!result && (source.flags & TypeFlags.StructuredOrInstantiable || target.flags & TypeFlags.StructuredOrInstantiable)) {
          if ((result = recursiveTypeRelatedTo(source, target, reportErrors, intersectionState))) resetErrorInfo(saveErrorInfo);
        }
      }
      if (!result && source.flags & (TypeFlags.Intersection | TypeFlags.TypeParameter)) {
        const constraint = getEffectiveConstraintOfIntersection(source.flags & TypeFlags.Intersection ? (<IntersectionType>source).types : [source], !!(target.flags & TypeFlags.Union));
        if (constraint && (source.flags & TypeFlags.Intersection || target.flags & TypeFlags.Union)) {
          if (everyType(constraint, (c) => c !== source)) {
            if ((result = isRelatedTo(constraint, target, false, undefined, intersectionState))) resetErrorInfo(saveErrorInfo);
          }
        }
      }
      if (
        result &&
        !inPropertyCheck &&
        ((target.flags & TypeFlags.Intersection && (isPerformingExcessPropertyChecks || isPerformingCommonPropertyChecks)) ||
          (isNonGenericObjectType(target) &&
            !isArrayType(target) &&
            !isTupleType(target) &&
            source.flags & TypeFlags.Intersection &&
            getApparentType(source).flags & TypeFlags.StructuredType &&
            !some((<IntersectionType>source).types, (t) => !!(getObjectFlags(t) & ObjectFlags.NonInferrableType))))
      ) {
        inPropertyCheck = true;
        result &= recursiveTypeRelatedTo(source, target, reportErrors, IntersectionState.PropertyCheck);
        inPropertyCheck = false;
      }
      reportErrorResults(source, target, result, isComparingJsxAttributes);
      return result;
      function reportErrorResults(source: Type, target: Type, result: Ternary, isComparingJsxAttributes: boolean) {
        if (!result && reportErrors) {
          source = originalSource.aliasSymbol ? originalSource : source;
          target = originalTarget.aliasSymbol ? originalTarget : target;
          let maybeSuppress = overrideNextErrorInfo > 0;
          if (maybeSuppress) overrideNextErrorInfo--;
          if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) {
            const currentError = errorInfo;
            tryElaborateArrayLikeErrors(source, target, reportErrors);
            if (errorInfo !== currentError) maybeSuppress = !!errorInfo;
          }
          if (source.flags & TypeFlags.Object && target.flags & TypeFlags.Primitive) tryElaborateErrorsForPrimitivesAndObjects(source, target);
          else if (source.symbol && source.flags & TypeFlags.Object && globalObjectType === source) {
            reportError(qd.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead);
          } else if (isComparingJsxAttributes && target.flags & TypeFlags.Intersection) {
            const targetTypes = (target as IntersectionType).types;
            const intrinsicAttributes = getJsxType(JsxNames.IntrinsicAttributes, errorNode);
            const intrinsicClassAttributes = getJsxType(JsxNames.IntrinsicClassAttributes, errorNode);
            if (intrinsicAttributes !== errorType && intrinsicClassAttributes !== errorType && (contains(targetTypes, intrinsicAttributes) || contains(targetTypes, intrinsicClassAttributes)))
              return result;
          } else {
            errorInfo = elaborateNeverIntersection(errorInfo, originalTarget);
          }
          if (!headMessage && maybeSuppress) {
            lastSkippedInfo = [source, target];
            return result;
          }
          reportRelationError(headMessage, source, target);
        }
      }
    }
    function isIdenticalTo(source: Type, target: Type): Ternary {
      const flags = source.flags & target.flags;
      if (!(flags & TypeFlags.Substructure)) return Ternary.False;
      if (flags & TypeFlags.UnionOrIntersection) {
        let result = eachTypeRelatedToSomeType(<UnionOrIntersectionType>source, <UnionOrIntersectionType>target);
        if (result) result &= eachTypeRelatedToSomeType(<UnionOrIntersectionType>target, <UnionOrIntersectionType>source);
        return result;
      }
      return recursiveTypeRelatedTo(source, target, false, IntersectionState.None);
    }
    function getTypeOfPropertyInTypes(types: Type[], name: __String) {
      const appendPropType = (propTypes: Type[] | undefined, type: Type) => {
        type = getApparentType(type);
        const prop = type.flags & TypeFlags.UnionOrIntersection ? getPropertyOfUnionOrIntersectionType(<UnionOrIntersectionType>type, name) : getPropertyOfObjectType(type, name);
        const propType = (prop && getTypeOfSymbol(prop)) || (NumericLiteral.name(name) && getIndexTypeOfType(type, IndexKind.Number)) || getIndexTypeOfType(type, IndexKind.String) || undefinedType;
        return append(propTypes, propType);
      };
      return getUnionType(reduceLeft(types, appendPropType, undefined) || empty);
    }
    function hasExcessProperties(source: FreshObjectLiteralType, target: Type, reportErrors: boolean): boolean {
      if (!isExcessPropertyCheckTarget(target) || (!noImplicitAny && getObjectFlags(target) & ObjectFlags.JSLiteral)) return false;
      const isComparingJsxAttributes = !!(getObjectFlags(source) & ObjectFlags.JsxAttributes);
      if ((relation === assignableRelation || relation === comparableRelation) && (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target)))) return false;
      let reducedTarget = target;
      let checkTypes: Type[] | undefined;
      if (target.flags & TypeFlags.Union) {
        reducedTarget = findMatchingDiscriminantType(source, <UnionType>target, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(<UnionType>target);
        checkTypes = reducedTarget.flags & TypeFlags.Union ? (<UnionType>reducedTarget).types : [reducedTarget];
      }
      for (const prop of getPropertiesOfType(source)) {
        if (shouldCheckAsExcessProperty(prop, source.symbol) && !isIgnoredJsxProperty(source, prop)) {
          if (!isKnownProperty(reducedTarget, prop.escName, isComparingJsxAttributes)) {
            if (reportErrors) {
              const errorTarget = filterType(reducedTarget, isExcessPropertyCheckTarget);
              if (!errorNode) return fail();
              if (qc.is.kind(JsxAttributes, errorNode) || qc.isJsx.openingLikeElement(errorNode) || qc.isJsx.openingLikeElement(errorNode.parent)) {
                if (prop.valueDeclaration && qc.is.kind(JsxAttribute, prop.valueDeclaration) && qc.get.sourceFileOf(errorNode) === qc.get.sourceFileOf(prop.valueDeclaration.name))
                  errorNode = prop.valueDeclaration.name;
                reportError(qd.Property_0_does_not_exist_on_type_1, prop.symbolToString(), typeToString(errorTarget));
              } else {
                const objectLiteralDeclaration = source.symbol && firstOrUndefined(source.symbol.declarations);
                let suggestion;
                if (
                  prop.valueDeclaration &&
                  Node.findAncestor(prop.valueDeclaration, (d) => d === objectLiteralDeclaration) &&
                  qc.get.sourceFileOf(objectLiteralDeclaration) === qc.get.sourceFileOf(errorNode)
                ) {
                  const propDeclaration = prop.valueDeclaration as ObjectLiteralElementLike;
                  Debug.assertNode(propDeclaration, isObjectLiteralElementLike);
                  errorNode = propDeclaration;
                  const name = propDeclaration.name!;
                  if (qc.is.kind(Identifier, name)) suggestion = getSuggestionForNonexistentProperty(name, errorTarget);
                }
                if (suggestion !== undefined) {
                  reportError(qd.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, prop.symbolToString(), typeToString(errorTarget), suggestion);
                } else {
                  reportError(qd.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, prop.symbolToString(), typeToString(errorTarget));
                }
              }
            }
            return true;
          }
          if (checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.escName), reportErrors)) {
            if (reportErrors) reportIncompatibleError(qd.Types_of_property_0_are_incompatible, prop.symbolToString());
            return true;
          }
        }
      }
      return false;
    }
    function shouldCheckAsExcessProperty(prop: Symbol, container: Symbol) {
      return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent === container.valueDeclaration;
    }
    function eachTypeRelatedToSomeType(source: UnionOrIntersectionType, target: UnionOrIntersectionType): Ternary {
      let result = Ternary.True;
      const sourceTypes = source.types;
      for (const sourceType of sourceTypes) {
        const related = typeRelatedToSomeType(sourceType, target, false);
        if (!related) return Ternary.False;
        result &= related;
      }
      return result;
    }
    function typeRelatedToSomeType(source: Type, target: UnionOrIntersectionType, reportErrors: boolean): Ternary {
      const targetTypes = target.types;
      if (target.flags & TypeFlags.Union && containsType(targetTypes, source)) return Ternary.True;
      for (const type of targetTypes) {
        const related = isRelatedTo(source, type, false);
        if (related) return related;
      }
      if (reportErrors) {
        const bestMatchingType = getBestMatchingType(source, target, isRelatedTo);
        isRelatedTo(source, bestMatchingType || targetTypes[targetTypes.length - 1], true);
      }
      return Ternary.False;
    }
    function typeRelatedToEachType(source: Type, target: IntersectionType, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
      let result = Ternary.True;
      const targetTypes = target.types;
      for (const targetType of targetTypes) {
        const related = isRelatedTo(source, targetType, reportErrors, undefined, intersectionState);
        if (!related) return Ternary.False;
        result &= related;
      }
      return result;
    }
    function someTypeRelatedToType(source: UnionOrIntersectionType, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
      const sourceTypes = source.types;
      if (source.flags & TypeFlags.Union && containsType(sourceTypes, target)) return Ternary.True;
      const len = sourceTypes.length;
      for (let i = 0; i < len; i++) {
        const related = isRelatedTo(sourceTypes[i], target, reportErrors && i === len - 1, undefined, intersectionState);
        if (related) return related;
      }
      return Ternary.False;
    }
    function eachTypeRelatedToType(source: UnionOrIntersectionType, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
      let result = Ternary.True;
      const sourceTypes = source.types;
      for (let i = 0; i < sourceTypes.length; i++) {
        const sourceType = sourceTypes[i];
        if (target.flags & TypeFlags.Union && (target as UnionType).types.length === sourceTypes.length) {
          const related = isRelatedTo(sourceType, (target as UnionType).types[i], false, undefined, intersectionState);
          if (related) {
            result &= related;
            continue;
          }
        }
        const related = isRelatedTo(sourceType, target, reportErrors, undefined, intersectionState);
        if (!related) return Ternary.False;
        result &= related;
      }
      return result;
    }
    function typeArgumentsRelatedTo(
      sources: readonly Type[] = empty,
      targets: readonly Type[] = empty,
      variances: readonly VarianceFlags[] = empty,
      reportErrors: boolean,
      intersectionState: IntersectionState
    ): Ternary {
      if (sources.length !== targets.length && relation === identityRelation) return Ternary.False;
      const length = sources.length <= targets.length ? sources.length : targets.length;
      let result = Ternary.True;
      for (let i = 0; i < length; i++) {
        const varianceFlags = i < variances.length ? variances[i] : VarianceFlags.Covariant;
        const variance = varianceFlags & VarianceFlags.VarianceMask;
        if (variance !== VarianceFlags.Independent) {
          const s = sources[i];
          const t = targets[i];
          let related = Ternary.True;
          if (varianceFlags & VarianceFlags.Unmeasurable) related = relation === identityRelation ? isRelatedTo(s, t, false) : compareTypesIdentical(s, t);
          else if (variance === VarianceFlags.Covariant) {
            related = isRelatedTo(s, t, reportErrors, undefined, intersectionState);
          } else if (variance === VarianceFlags.Contravariant) {
            related = isRelatedTo(t, s, reportErrors, undefined, intersectionState);
          } else if (variance === VarianceFlags.Bivariant) {
            related = isRelatedTo(t, s, false);
            if (!related) related = isRelatedTo(s, t, reportErrors, undefined, intersectionState);
          } else {
            related = isRelatedTo(s, t, reportErrors, undefined, intersectionState);
            if (related) related &= isRelatedTo(t, s, reportErrors, undefined, intersectionState);
          }
          if (!related) return Ternary.False;
          result &= related;
        }
      }
      return result;
    }
    function recursiveTypeRelatedTo(source: Type, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
      if (overflow) return Ternary.False;
      const id = getRelationKey(source, target, intersectionState | (inPropertyCheck ? IntersectionState.InPropertyCheck : 0), relation);
      const entry = relation.get(id);
      if (entry !== undefined) {
        if (reportErrors && entry & RelationComparisonResult.Failed && !(entry & RelationComparisonResult.Reported)) {
        } else {
          if (outofbandVarianceMarkerHandler) {
            const saved = entry & RelationComparisonResult.ReportsMask;
            if (saved & RelationComparisonResult.ReportsUnmeasurable) instantiateType(source, makeFunctionTypeMapper(reportUnmeasurableMarkers));
            if (saved & RelationComparisonResult.ReportsUnreliable) instantiateType(source, makeFunctionTypeMapper(reportUnreliableMarkers));
          }
          return entry & RelationComparisonResult.Succeeded ? Ternary.True : Ternary.False;
        }
      }
      if (!maybeKeys) {
        maybeKeys = [];
        sourceStack = [];
        targetStack = [];
      } else {
        for (let i = 0; i < maybeCount; i++) {
          if (id === maybeKeys[i]) return Ternary.Maybe;
        }
        if (depth === 100) {
          overflow = true;
          return Ternary.False;
        }
      }
      const maybeStart = maybeCount;
      maybeKeys[maybeCount] = id;
      maybeCount++;
      sourceStack[depth] = source;
      targetStack[depth] = target;
      depth++;
      const saveExpandingFlags = expandingFlags;
      if (!(expandingFlags & ExpandingFlags.Source) && isDeeplyNestedType(source, sourceStack, depth)) expandingFlags |= ExpandingFlags.Source;
      if (!(expandingFlags & ExpandingFlags.Target) && isDeeplyNestedType(target, targetStack, depth)) expandingFlags |= ExpandingFlags.Target;
      let originalHandler: typeof outofbandVarianceMarkerHandler;
      let propagatingVarianceFlags: RelationComparisonResult = 0;
      if (outofbandVarianceMarkerHandler) {
        originalHandler = outofbandVarianceMarkerHandler;
        outofbandVarianceMarkerHandler = (onlyUnreliable) => {
          propagatingVarianceFlags |= onlyUnreliable ? RelationComparisonResult.ReportsUnreliable : RelationComparisonResult.ReportsUnmeasurable;
          return originalHandler!(onlyUnreliable);
        };
      }
      const result = expandingFlags !== ExpandingFlags.Both ? structuredTypeRelatedTo(source, target, reportErrors, intersectionState) : Ternary.Maybe;
      if (outofbandVarianceMarkerHandler) outofbandVarianceMarkerHandler = originalHandler;
      expandingFlags = saveExpandingFlags;
      depth--;
      if (result) {
        if (result === Ternary.True || depth === 0) {
          for (let i = maybeStart; i < maybeCount; i++) {
            relation.set(maybeKeys[i], RelationComparisonResult.Succeeded | propagatingVarianceFlags);
          }
          maybeCount = maybeStart;
        }
      } else {
        relation.set(id, (reportErrors ? RelationComparisonResult.Reported : 0) | RelationComparisonResult.Failed | propagatingVarianceFlags);
        maybeCount = maybeStart;
      }
      return result;
    }
    function structuredTypeRelatedTo(source: Type, target: Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
      if (intersectionState & IntersectionState.PropertyCheck) return propertiesRelatedTo(source, target, reportErrors, undefined, IntersectionState.None);
      const flags = source.flags & target.flags;
      if (relation === identityRelation && !(flags & TypeFlags.Object)) {
        if (flags & TypeFlags.Index) return isRelatedTo((<IndexType>source).type, (<IndexType>target).type, false);
        let result = Ternary.False;
        if (flags & TypeFlags.IndexedAccess) {
          if ((result = isRelatedTo((<IndexedAccessType>source).objectType, (<IndexedAccessType>target).objectType, false))) {
            if ((result &= isRelatedTo((<IndexedAccessType>source).indexType, (<IndexedAccessType>target).indexType, false))) return result;
          }
        }
        if (flags & TypeFlags.Conditional) {
          if ((<ConditionalType>source).root.isDistributive === (<ConditionalType>target).root.isDistributive) {
            if ((result = isRelatedTo((<ConditionalType>source).checkType, (<ConditionalType>target).checkType, false))) {
              if ((result &= isRelatedTo((<ConditionalType>source).extendsType, (<ConditionalType>target).extendsType, false))) {
                if ((result &= isRelatedTo(getTrueTypeFromConditionalType(<ConditionalType>source), getTrueTypeFromConditionalType(<ConditionalType>target), false))) {
                  if ((result &= isRelatedTo(getFalseTypeFromConditionalType(<ConditionalType>source), getFalseTypeFromConditionalType(<ConditionalType>target), false))) return result;
                }
              }
            }
          }
        }
        if (flags & TypeFlags.Substitution) return isRelatedTo((<SubstitutionType>source).substitute, (<SubstitutionType>target).substitute, false);
        return Ternary.False;
      }
      let result: Ternary;
      let originalErrorInfo: DiagnosticMessageChain | undefined;
      let varianceCheckFailed = false;
      const saveErrorInfo = captureErrorCalculationState();
      if (
        source.flags & (TypeFlags.Object | TypeFlags.Conditional) &&
        source.aliasSymbol &&
        source.aliasTypeArguments &&
        source.aliasSymbol === target.aliasSymbol &&
        !(source.aliasTypeArgumentsContainsMarker || target.aliasTypeArgumentsContainsMarker)
      ) {
        const variances = getAliasVariances(source.aliasSymbol);
        if (variances === empty) return Ternary.Maybe;
        const varianceResult = relateVariances(source.aliasTypeArguments, target.aliasTypeArguments, variances, intersectionState);
        if (varianceResult !== undefined) return varianceResult;
      }
      if (target.flags & TypeFlags.TypeParameter) {
        if (getObjectFlags(source) & ObjectFlags.Mapped && isRelatedTo(getIndexType(target), getConstraintTypeFromMappedType(<MappedType>source))) {
          if (!(getMappedTypeModifiers(<MappedType>source) & MappedTypeModifiers.IncludeOptional)) {
            const templateType = getTemplateTypeFromMappedType(<MappedType>source);
            const indexedAccessType = getIndexedAccessType(target, getTypeParameterFromMappedType(<MappedType>source));
            if ((result = isRelatedTo(templateType, indexedAccessType, reportErrors))) return result;
          }
        }
      } else if (target.flags & TypeFlags.Index) {
        if (source.flags & TypeFlags.Index) {
          if ((result = isRelatedTo((<IndexType>target).type, (<IndexType>source).type, false))) return result;
        }
        const constraint = getSimplifiedTypeOrConstraint((<IndexType>target).type);
        if (constraint) {
          if (isRelatedTo(source, getIndexType(constraint, (target as IndexType).stringsOnly), reportErrors) === Ternary.True) return Ternary.True;
        }
      } else if (target.flags & TypeFlags.IndexedAccess) {
        if (relation !== identityRelation) {
          const objectType = (<IndexedAccessType>target).objectType;
          const indexType = (<IndexedAccessType>target).indexType;
          const baseObjectType = getBaseConstraintOfType(objectType) || objectType;
          const baseIndexType = getBaseConstraintOfType(indexType) || indexType;
          if (!isGenericObjectType(baseObjectType) && !isGenericIndexType(baseIndexType)) {
            const accessFlags = AccessFlags.Writing | (baseObjectType !== objectType ? AccessFlags.NoIndexSignatures : 0);
            const constraint = getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, undefined, accessFlags);
            if (constraint && (result = isRelatedTo(source, constraint, reportErrors))) return result;
          }
        }
      } else if (isGenericMappedType(target)) {
        const template = getTemplateTypeFromMappedType(target);
        const modifiers = getMappedTypeModifiers(target);
        if (!(modifiers & MappedTypeModifiers.ExcludeOptional)) {
          if (template.flags & TypeFlags.IndexedAccess && (<IndexedAccessType>template).objectType === source && (<IndexedAccessType>template).indexType === getTypeParameterFromMappedType(target))
            return Ternary.True;
          if (!isGenericMappedType(source)) {
            const targetConstraint = getConstraintTypeFromMappedType(target);
            const sourceKeys = getIndexType(source, true);
            const includeOptional = modifiers & MappedTypeModifiers.IncludeOptional;
            const filteredByApplicability = includeOptional ? intersectTypes(targetConstraint, sourceKeys) : undefined;
            if (includeOptional ? !(filteredByApplicability!.flags & TypeFlags.Never) : isRelatedTo(targetConstraint, sourceKeys)) {
              const typeParameter = getTypeParameterFromMappedType(target);
              const indexingType = filteredByApplicability ? getIntersectionType([filteredByApplicability, typeParameter]) : typeParameter;
              const indexedAccessType = getIndexedAccessType(source, indexingType);
              const templateType = getTemplateTypeFromMappedType(target);
              if ((result = isRelatedTo(indexedAccessType, templateType, reportErrors))) return result;
            }
            originalErrorInfo = errorInfo;
            resetErrorInfo(saveErrorInfo);
          }
        }
      }
      if (source.flags & TypeFlags.TypeVariable) {
        if (source.flags & TypeFlags.IndexedAccess && target.flags & TypeFlags.IndexedAccess) {
          if ((result = isRelatedTo((<IndexedAccessType>source).objectType, (<IndexedAccessType>target).objectType, reportErrors)))
            result &= isRelatedTo((<IndexedAccessType>source).indexType, (<IndexedAccessType>target).indexType, reportErrors);
          if (result) {
            resetErrorInfo(saveErrorInfo);
            return result;
          }
        } else {
          const constraint = getConstraintOfType(<TypeVariable>source);
          if (!constraint || (source.flags & TypeFlags.TypeParameter && constraint.flags & TypeFlags.Any)) {
            if ((result = isRelatedTo(emptyObjectType, extractTypesOfKind(target, ~TypeFlags.NonPrimitive)))) {
              resetErrorInfo(saveErrorInfo);
              return result;
            }
          } else if ((result = isRelatedTo(constraint, target, false, undefined, intersectionState))) {
            resetErrorInfo(saveErrorInfo);
            return result;
          } else if ((result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, reportErrors, undefined, intersectionState))) {
            resetErrorInfo(saveErrorInfo);
            return result;
          }
        }
      } else if (source.flags & TypeFlags.Index) {
        if ((result = isRelatedTo(keyofConstraintType, target, reportErrors))) {
          resetErrorInfo(saveErrorInfo);
          return result;
        }
      } else if (source.flags & TypeFlags.Conditional) {
        if (target.flags & TypeFlags.Conditional) {
          const sourceParams = (source as ConditionalType).root.inferTypeParameters;
          let sourceExtends = (<ConditionalType>source).extendsType;
          let mapper: TypeMapper | undefined;
          if (sourceParams) {
            const ctx = createInferenceContext(sourceParams, undefined, InferenceFlags.None, isRelatedTo);
            inferTypes(ctx.inferences, (<ConditionalType>target).extendsType, sourceExtends, InferencePriority.NoConstraints | InferencePriority.AlwaysStrict);
            sourceExtends = instantiateType(sourceExtends, ctx.mapper);
            mapper = ctx.mapper;
          }
          if (
            isTypeIdenticalTo(sourceExtends, (<ConditionalType>target).extendsType) &&
            (isRelatedTo((<ConditionalType>source).checkType, (<ConditionalType>target).checkType) || isRelatedTo((<ConditionalType>target).checkType, (<ConditionalType>source).checkType))
          ) {
            if ((result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(<ConditionalType>source), mapper), getTrueTypeFromConditionalType(<ConditionalType>target), reportErrors)))
              result &= isRelatedTo(getFalseTypeFromConditionalType(<ConditionalType>source), getFalseTypeFromConditionalType(<ConditionalType>target), reportErrors);
            if (result) {
              resetErrorInfo(saveErrorInfo);
              return result;
            }
          }
        } else {
          const distributiveConstraint = getConstraintOfDistributiveConditionalType(<ConditionalType>source);
          if (distributiveConstraint) {
            if ((result = isRelatedTo(distributiveConstraint, target, reportErrors))) {
              resetErrorInfo(saveErrorInfo);
              return result;
            }
          }
        }
        const defaultConstraint = getDefaultConstraintOfConditionalType(<ConditionalType>source);
        if (defaultConstraint) {
          if ((result = isRelatedTo(defaultConstraint, target, reportErrors))) {
            resetErrorInfo(saveErrorInfo);
            return result;
          }
        }
      } else {
        if (relation !== subtypeRelation && relation !== strictSubtypeRelation && isPartialMappedType(target) && isEmptyObjectType(source)) return Ternary.True;
        if (isGenericMappedType(target)) {
          if (isGenericMappedType(source)) {
            if ((result = mappedTypeRelatedTo(source, target, reportErrors))) {
              resetErrorInfo(saveErrorInfo);
              return result;
            }
          }
          return Ternary.False;
        }
        const sourceIsPrimitive = !!(source.flags & TypeFlags.Primitive);
        if (relation !== identityRelation) source = getApparentType(source);
        else if (isGenericMappedType(source)) return Ternary.False;
        if (
          getObjectFlags(source) & ObjectFlags.Reference &&
          getObjectFlags(target) & ObjectFlags.Reference &&
          (<TypeReference>source).target === (<TypeReference>target).target &&
          !(getObjectFlags(source) & ObjectFlags.MarkerType || getObjectFlags(target) & ObjectFlags.MarkerType)
        ) {
          const variances = getVariances((<TypeReference>source).target);
          if (variances === empty) return Ternary.Maybe;
          const varianceResult = relateVariances(getTypeArguments(<TypeReference>source), getTypeArguments(<TypeReference>target), variances, intersectionState);
          if (varianceResult !== undefined) return varianceResult;
        } else if (isReadonlyArrayType(target) ? isArrayType(source) || isTupleType(source) : isArrayType(target) && isTupleType(source) && !source.target.readonly) {
          if (relation !== identityRelation) return isRelatedTo(getIndexTypeOfType(source, IndexKind.Number) || anyType, getIndexTypeOfType(target, IndexKind.Number) || anyType, reportErrors);
          return Ternary.False;
        } else if (
          (relation === subtypeRelation || relation === strictSubtypeRelation) &&
          isEmptyObjectType(target) &&
          getObjectFlags(target) & ObjectFlags.FreshLiteral &&
          !isEmptyObjectType(source)
        ) {
          return Ternary.False;
        }
        if (source.flags & (TypeFlags.Object | TypeFlags.Intersection) && target.flags & TypeFlags.Object) {
          const reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo.errorInfo && !sourceIsPrimitive;
          result = propertiesRelatedTo(source, target, reportStructuralErrors, undefined, intersectionState);
          if (result) {
            result &= signaturesRelatedTo(source, target, SignatureKind.Call, reportStructuralErrors);
            if (result) {
              result &= signaturesRelatedTo(source, target, SignatureKind.Construct, reportStructuralErrors);
              if (result) {
                result &= indexTypesRelatedTo(source, target, IndexKind.String, sourceIsPrimitive, reportStructuralErrors, intersectionState);
                if (result) result &= indexTypesRelatedTo(source, target, IndexKind.Number, sourceIsPrimitive, reportStructuralErrors, intersectionState);
              }
            }
          }
          if (varianceCheckFailed && result) errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo;
          else if (result) return result;
        }
        if (source.flags & (TypeFlags.Object | TypeFlags.Intersection) && target.flags & TypeFlags.Union) {
          const objectOnlyTarget = extractTypesOfKind(target, TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Substitution);
          if (objectOnlyTarget.flags & TypeFlags.Union) {
            const result = typeRelatedToDiscriminatedType(source, objectOnlyTarget as UnionType);
            if (result) return result;
          }
        }
      }
      return Ternary.False;
      function relateVariances(sourceTypeArguments: readonly Type[] | undefined, targetTypeArguments: readonly Type[] | undefined, variances: VarianceFlags[], intersectionState: IntersectionState) {
        if ((result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState))) return result;
        if (some(variances, (v) => !!(v & VarianceFlags.AllowsStructuralFallback))) {
          originalErrorInfo = undefined;
          resetErrorInfo(saveErrorInfo);
          return;
        }
        const allowStructuralFallback = targetTypeArguments && hasCovariantVoidArgument(targetTypeArguments, variances);
        varianceCheckFailed = !allowStructuralFallback;
        if (variances !== empty && !allowStructuralFallback) {
          if (varianceCheckFailed && !(reportErrors && some(variances, (v) => (v & VarianceFlags.VarianceMask) === VarianceFlags.Invariant))) return Ternary.False;
          originalErrorInfo = errorInfo;
          resetErrorInfo(saveErrorInfo);
        }
      }
    }
    function reportUnmeasurableMarkers(p: TypeParameter) {
      if (outofbandVarianceMarkerHandler && (p === markerSuperType || p === markerSubType || p === markerOtherType)) outofbandVarianceMarkerHandler(false);
      return p;
    }
    function reportUnreliableMarkers(p: TypeParameter) {
      if (outofbandVarianceMarkerHandler && (p === markerSuperType || p === markerSubType || p === markerOtherType)) outofbandVarianceMarkerHandler(true);
      return p;
    }
    function mappedTypeRelatedTo(source: MappedType, target: MappedType, reportErrors: boolean): Ternary {
      const modifiersRelated =
        relation === comparableRelation ||
        (relation === identityRelation ? getMappedTypeModifiers(source) === getMappedTypeModifiers(target) : getCombinedMappedTypeOptionality(source) <= getCombinedMappedTypeOptionality(target));
      if (modifiersRelated) {
        let result: Ternary;
        const targetConstraint = getConstraintTypeFromMappedType(target);
        const sourceConstraint = instantiateType(
          getConstraintTypeFromMappedType(source),
          makeFunctionTypeMapper(getCombinedMappedTypeOptionality(source) < 0 ? reportUnmeasurableMarkers : reportUnreliableMarkers)
        );
        if ((result = isRelatedTo(targetConstraint, sourceConstraint, reportErrors))) {
          const mapper = createTypeMapper([getTypeParameterFromMappedType(source)], [getTypeParameterFromMappedType(target)]);
          return result & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), reportErrors);
        }
      }
      return Ternary.False;
    }
    function typeRelatedToDiscriminatedType(source: Type, target: UnionType) {
      const sourceProperties = getPropertiesOfType(source);
      const sourcePropertiesFiltered = findDiscriminantProperties(sourceProperties, target);
      if (!sourcePropertiesFiltered) return Ternary.False;
      let numCombinations = 1;
      for (const sourceProperty of sourcePropertiesFiltered) {
        numCombinations *= countTypes(getTypeOfSymbol(sourceProperty));
        if (numCombinations > 25) return Ternary.False;
      }
      const sourceDiscriminantTypes: Type[][] = new Array<Type[]>(sourcePropertiesFiltered.length);
      const excludedProperties = createUnderscoreEscapedMap<true>();
      for (let i = 0; i < sourcePropertiesFiltered.length; i++) {
        const sourceProperty = sourcePropertiesFiltered[i];
        const sourcePropertyType = getTypeOfSymbol(sourceProperty);
        sourceDiscriminantTypes[i] = sourcePropertyType.flags & TypeFlags.Union ? (sourcePropertyType as UnionType).types : [sourcePropertyType];
        excludedProperties.set(sourceProperty.escName, true);
      }
      const discriminantCombinations = cartesianProduct(sourceDiscriminantTypes);
      const matchingTypes: Type[] = [];
      for (const combination of discriminantCombinations) {
        let hasMatch = false;
        outer: for (const type of target.types) {
          for (let i = 0; i < sourcePropertiesFiltered.length; i++) {
            const sourceProperty = sourcePropertiesFiltered[i];
            const targetProperty = getPropertyOfType(type, sourceProperty.escName);
            if (!targetProperty) continue outer;
            if (sourceProperty === targetProperty) continue;
            const related = propertyRelatedTo(
              source,
              target,
              sourceProperty,
              targetProperty,
              (_) => combination[i],
              false,
              IntersectionState.None,
              strictNullChecks || relation === comparableRelation
            );
            if (!related) continue outer;
          }
          pushIfUnique(matchingTypes, type, equateValues);
          hasMatch = true;
        }
        if (!hasMatch) return Ternary.False;
      }
      let result = Ternary.True;
      for (const type of matchingTypes) {
        result &= propertiesRelatedTo(source, type, false, excludedProperties, IntersectionState.None);
        if (result) {
          result &= signaturesRelatedTo(source, type, SignatureKind.Call, false);
          if (result) {
            result &= signaturesRelatedTo(source, type, SignatureKind.Construct, false);
            if (result) {
              result &= indexTypesRelatedTo(source, type, IndexKind.String, false, IntersectionState.None);
              if (result) result &= indexTypesRelatedTo(source, type, IndexKind.Number, false, IntersectionState.None);
            }
          }
        }
        if (!result) return result;
      }
      return result;
    }
    function excludeProperties(properties: Symbol[], excludedProperties: UnderscoreEscapedMap<true> | undefined) {
      if (!excludedProperties || properties.length === 0) return properties;
      let result: Symbol[] | undefined;
      for (let i = 0; i < properties.length; i++) {
        if (!excludedProperties.has(properties[i].escName)) {
          if (result) result.push(properties[i]);
        } else if (!result) {
          result = properties.slice(0, i);
        }
      }
      return result || properties;
    }
    function isPropertySymbolTypeRelated(sourceProp: Symbol, targetProp: Symbol, getTypeOfSourceProperty: (sym: Symbol) => Type, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
      const targetIsOptional = strictNullChecks && !!(getCheckFlags(targetProp) & CheckFlags.Partial);
      const source = getTypeOfSourceProperty(sourceProp);
      if (getCheckFlags(targetProp) & CheckFlags.DeferredType && !s.getLinks(targetProp).type) {
        const links = s.getLinks(targetProp);
        Debug.assertIsDefined(links.deferralParent);
        Debug.assertIsDefined(links.deferralConstituents);
        const unionParent = !!(links.deferralParent.flags & TypeFlags.Union);
        let result = unionParent ? Ternary.False : Ternary.True;
        const targetTypes = links.deferralConstituents;
        for (const targetType of targetTypes) {
          const related = isRelatedTo(source, targetType, false, undefined, unionParent ? 0 : IntersectionState.Target);
          if (!unionParent) {
            if (!related) return isRelatedTo(source, addOptionality(getTypeOfSymbol(targetProp), targetIsOptional), reportErrors);
            result &= related;
          } else {
            if (related) return related;
          }
        }
        if (unionParent && !result && targetIsOptional) result = isRelatedTo(source, undefinedType);
        if (unionParent && !result && reportErrors) return isRelatedTo(source, addOptionality(getTypeOfSymbol(targetProp), targetIsOptional), reportErrors);
        return result;
      }
      return isRelatedTo(source, addOptionality(getTypeOfSymbol(targetProp), targetIsOptional), reportErrors, undefined, intersectionState);
    }
    function propertyRelatedTo(
      source: Type,
      target: Type,
      sourceProp: Symbol,
      targetProp: Symbol,
      getTypeOfSourceProperty: (sym: Symbol) => Type,
      reportErrors: boolean,
      intersectionState: IntersectionState,
      skipOptional: boolean
    ): Ternary {
      const sourcePropFlags = getDeclarationModifierFlagsFromSymbol(sourceProp);
      const targetPropFlags = getDeclarationModifierFlagsFromSymbol(targetProp);
      if (sourcePropFlags & ModifierFlags.Private || targetPropFlags & ModifierFlags.Private) {
        if (sourceProp.valueDeclaration !== targetProp.valueDeclaration) {
          if (reportErrors) {
            if (sourcePropFlags & ModifierFlags.Private && targetPropFlags & ModifierFlags.Private)
              reportError(qd.Types_have_separate_declarations_of_a_private_property_0, targetProp.symbolToString());
            else {
              reportError(
                qd.Property_0_is_private_in_type_1_but_not_in_type_2,
                targetProp.symbolToString(),
                typeToString(sourcePropFlags & ModifierFlags.Private ? source : target),
                typeToString(sourcePropFlags & ModifierFlags.Private ? target : source)
              );
            }
          }
          return Ternary.False;
        }
      } else if (targetPropFlags & ModifierFlags.Protected) {
        if (!isValidOverrideOf(sourceProp, targetProp)) {
          if (reportErrors) {
            reportError(
              qd.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2,
              targetProp.symbolToString(),
              typeToString(getDeclaringClass(sourceProp) || source),
              typeToString(getDeclaringClass(targetProp) || target)
            );
          }
          return Ternary.False;
        }
      } else if (sourcePropFlags & ModifierFlags.Protected) {
        if (reportErrors) reportError(qd.Property_0_is_protected_in_type_1_but_public_in_type_2, targetProp.symbolToString(), typeToString(source), typeToString(target));
        return Ternary.False;
      }
      const related = isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState);
      if (!related) {
        if (reportErrors) reportIncompatibleError(qd.Types_of_property_0_are_incompatible, targetProp.symbolToString());
        return Ternary.False;
      }
      if (!skipOptional && sourceProp.flags & SymbolFlags.Optional && !(targetProp.flags & SymbolFlags.Optional)) {
        if (reportErrors) reportError(qd.Property_0_is_optional_in_type_1_but_required_in_type_2, targetProp.symbolToString(), typeToString(source), typeToString(target));
        return Ternary.False;
      }
      return related;
    }
    function reportUnmatchedProperty(source: Type, target: Type, unmatchedProperty: Symbol, requireOptionalProperties: boolean) {
      let shouldSkipElaboration = false;
      if (
        unmatchedProperty.valueDeclaration &&
        qc.is.namedDeclaration(unmatchedProperty.valueDeclaration) &&
        qc.is.kind(PrivateIdentifier, unmatchedProperty.valueDeclaration.name) &&
        source.symbol &&
        source.symbol.flags & SymbolFlags.Class
      ) {
        const privateIdentifierDescription = unmatchedProperty.valueDeclaration.name.escapedText;
        const symbolTableKey = getSymbolNameForPrivateIdentifier(source.symbol, privateIdentifierDescription);
        if (symbolTableKey && getPropertyOfType(source, symbolTableKey)) {
          const sourceName = getDeclarationName(source.symbol.valueDeclaration);
          const targetName = getDeclarationName(target.symbol.valueDeclaration);
          reportError(
            qd.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2,
            diagnosticName(privateIdentifierDescription),
            diagnosticName(sourceName.escapedText === '' ? anon : sourceName),
            diagnosticName(targetName.escapedText === '' ? anon : targetName)
          );
          return;
        }
      }
      const props = arrayFrom(getUnmatchedProperties(source, target, requireOptionalProperties, false));
      if (
        !headMessage ||
        (headMessage.code !== qd.Class_0_incorrectly_implements_interface_1.code &&
          headMessage.code !== qd.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code)
      ) {
        shouldSkipElaboration = true;
      }
      if (props.length === 1) {
        const propName = unmatchedProperty.symbolToString();
        reportError(qd.Property_0_is_missing_in_type_1_but_required_in_type_2, propName, ...getTypeNamesForErrorDisplay(source, target));
        if (length(unmatchedProperty.declarations)) associateRelatedInfo(createDiagnosticForNode(unmatchedProperty.declarations[0], qd._0_is_declared_here, propName));
        if (shouldSkipElaboration && errorInfo) overrideNextErrorInfo++;
      } else if (tryElaborateArrayLikeErrors(source, target, false)) {
        if (props.length > 5) {
          reportError(
            qd.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more,
            typeToString(source),
            typeToString(target),
            map(props.slice(0, 4), (p) => p.symbolToString()).join(', '),
            props.length - 4
          );
        } else {
          reportError(qd.Type_0_is_missing_the_following_properties_from_type_1_Colon_2, typeToString(source), typeToString(target), map(props, (p) => p.symbolToString()).join(', '));
        }
        if (shouldSkipElaboration && errorInfo) overrideNextErrorInfo++;
      }
    }
    function propertiesRelatedTo(source: Type, target: Type, reportErrors: boolean, excludedProperties: UnderscoreEscapedMap<true> | undefined, intersectionState: IntersectionState): Ternary {
      if (relation === identityRelation) return propertiesIdenticalTo(source, target, excludedProperties);
      const requireOptionalProperties =
        (relation === subtypeRelation || relation === strictSubtypeRelation) && !isObjectLiteralType(source) && !isEmptyArrayLiteralType(source) && !isTupleType(source);
      const unmatchedProperty = getUnmatchedProperty(source, target, requireOptionalProperties, false);
      if (unmatchedProperty) {
        if (reportErrors) reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties);
        return Ternary.False;
      }
      if (isObjectLiteralType(target)) {
        for (const sourceProp of excludeProperties(getPropertiesOfType(source), excludedProperties)) {
          if (!getPropertyOfObjectType(target, sourceProp.escName)) {
            const sourceType = getTypeOfSymbol(sourceProp);
            if (!(sourceType === undefinedType || sourceType === undefinedWideningType || sourceType === optionalType)) {
              if (reportErrors) reportError(qd.Property_0_does_not_exist_on_type_1, sourceProp.symbolToString(), typeToString(target));
              return Ternary.False;
            }
          }
        }
      }
      let result = Ternary.True;
      if (isTupleType(target)) {
        const targetRestType = getRestTypeOfTupleType(target);
        if (targetRestType) {
          if (!isTupleType(source)) return Ternary.False;
          const sourceRestType = getRestTypeOfTupleType(source);
          if (sourceRestType && !isRelatedTo(sourceRestType, targetRestType, reportErrors)) {
            if (reportErrors) reportError(qd.Rest_signatures_are_incompatible);
            return Ternary.False;
          }
          const targetCount = getTypeReferenceArity(target) - 1;
          const sourceCount = getTypeReferenceArity(source) - (sourceRestType ? 1 : 0);
          const sourceTypeArguments = getTypeArguments(<TypeReference>source);
          for (let i = targetCount; i < sourceCount; i++) {
            const related = isRelatedTo(sourceTypeArguments[i], targetRestType, reportErrors);
            if (!related) {
              if (reportErrors) reportError(qd.Property_0_is_incompatible_with_rest_element_type, '' + i);
              return Ternary.False;
            }
            result &= related;
          }
        }
      }
      const properties = getPropertiesOfType(target);
      const numericNamesOnly = isTupleType(source) && isTupleType(target);
      for (const targetProp of excludeProperties(properties, excludedProperties)) {
        const name = targetProp.escName;
        if (!(targetProp.flags & SymbolFlags.Prototype) && (!numericNamesOnly || NumericLiteral.name(name) || name === 'length')) {
          const sourceProp = getPropertyOfType(source, name);
          if (sourceProp && sourceProp !== targetProp) {
            const related = propertyRelatedTo(source, target, sourceProp, targetProp, getTypeOfSymbol, reportErrors, intersectionState, relation === comparableRelation);
            if (!related) return Ternary.False;
            result &= related;
          }
        }
      }
      return result;
    }
    function propertiesIdenticalTo(source: Type, target: Type, excludedProperties: UnderscoreEscapedMap<true> | undefined): Ternary {
      if (!(source.flags & TypeFlags.Object && target.flags & TypeFlags.Object)) return Ternary.False;
      const sourceProperties = excludeProperties(getPropertiesOfObjectType(source), excludedProperties);
      const targetProperties = excludeProperties(getPropertiesOfObjectType(target), excludedProperties);
      if (sourceProperties.length !== targetProperties.length) return Ternary.False;
      let result = Ternary.True;
      for (const sourceProp of sourceProperties) {
        const targetProp = getPropertyOfObjectType(target, sourceProp.escName);
        if (!targetProp) return Ternary.False;
        const related = compareProperties(sourceProp, targetProp, isRelatedTo);
        if (!related) return Ternary.False;
        result &= related;
      }
      return result;
    }
    function signaturesRelatedTo(source: Type, target: Type, kind: SignatureKind, reportErrors: boolean): Ternary {
      if (relation === identityRelation) return signaturesIdenticalTo(source, target, kind);
      if (target === anyFunctionType || source === anyFunctionType) return Ternary.True;
      const sourceIsJSConstructor = source.symbol && isJSConstructor(source.symbol.valueDeclaration);
      const targetIsJSConstructor = target.symbol && isJSConstructor(target.symbol.valueDeclaration);
      const sourceSignatures = getSignaturesOfType(source, sourceIsJSConstructor && kind === SignatureKind.Construct ? SignatureKind.Call : kind);
      const targetSignatures = getSignaturesOfType(target, targetIsJSConstructor && kind === SignatureKind.Construct ? SignatureKind.Call : kind);
      if (kind === SignatureKind.Construct && sourceSignatures.length && targetSignatures.length) {
        if (isAbstractConstructorType(source) && !isAbstractConstructorType(target)) {
          if (reportErrors) reportError(qd.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type);
          return Ternary.False;
        }
        if (!constructorVisibilitiesAreCompatible(sourceSignatures[0], targetSignatures[0], reportErrors)) return Ternary.False;
      }
      let result = Ternary.True;
      const saveErrorInfo = captureErrorCalculationState();
      const incompatibleReporter = kind === SignatureKind.Construct ? reportIncompatibleConstructSignatureReturn : reportIncompatibleCallSignatureReturn;
      if (getObjectFlags(source) & ObjectFlags.Instantiated && getObjectFlags(target) & ObjectFlags.Instantiated && source.symbol === target.symbol) {
        for (let i = 0; i < targetSignatures.length; i++) {
          const related = signatureRelatedTo(sourceSignatures[i], targetSignatures[i], true, reportErrors, incompatibleReporter(sourceSignatures[i], targetSignatures[i]));
          if (!related) return Ternary.False;
          result &= related;
        }
      } else if (sourceSignatures.length === 1 && targetSignatures.length === 1) {
        const eraseGenerics = relation === comparableRelation || !!compilerOptions.noStrictGenericChecks;
        result = signatureRelatedTo(sourceSignatures[0], targetSignatures[0], eraseGenerics, reportErrors, incompatibleReporter(sourceSignatures[0], targetSignatures[0]));
      } else {
        outer: for (const t of targetSignatures) {
          let shouldElaborateErrors = reportErrors;
          for (const s of sourceSignatures) {
            const related = signatureRelatedTo(s, t, true, shouldElaborateErrors, incompatibleReporter(s, t));
            if (related) {
              result &= related;
              resetErrorInfo(saveErrorInfo);
              continue outer;
            }
            shouldElaborateErrors = false;
          }
          if (shouldElaborateErrors) reportError(qd.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, undefined, undefined, kind));
          return Ternary.False;
        }
      }
      return result;
    }
    function reportIncompatibleCallSignatureReturn(siga: Signature, sigb: Signature) {
      if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
        return (source: Type, target: Type) => reportIncompatibleError(qd.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target));
      }
      return (source: Type, target: Type) => reportIncompatibleError(qd.Call_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target));
    }
    function reportIncompatibleConstructSignatureReturn(siga: Signature, sigb: Signature) {
      if (siga.parameters.length === 0 && sigb.parameters.length === 0) {
        return (source: Type, target: Type) => reportIncompatibleError(qd.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target));
      }
      return (source: Type, target: Type) => reportIncompatibleError(qd.Construct_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target));
    }
    function signatureRelatedTo(source: Signature, target: Signature, erase: boolean, reportErrors: boolean, incompatibleReporter: (source: Type, target: Type) => void): Ternary {
      return compareSignaturesRelated(
        erase ? getErasedSignature(source) : source,
        erase ? getErasedSignature(target) : target,
        relation === strictSubtypeRelation ? SignatureCheckMode.StrictArity : 0,
        reportErrors,
        reportError,
        incompatibleReporter,
        isRelatedTo,
        makeFunctionTypeMapper(reportUnreliableMarkers)
      );
    }
    function signaturesIdenticalTo(source: Type, target: Type, kind: SignatureKind): Ternary {
      const sourceSignatures = getSignaturesOfType(source, kind);
      const targetSignatures = getSignaturesOfType(target, kind);
      if (sourceSignatures.length !== targetSignatures.length) return Ternary.False;
      let result = Ternary.True;
      for (let i = 0; i < sourceSignatures.length; i++) {
        const related = compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], false, isRelatedTo);
        if (!related) return Ternary.False;
        result &= related;
      }
      return result;
    }
    function eachPropertyRelatedTo(source: Type, target: Type, kind: IndexKind, reportErrors: boolean): Ternary {
      let result = Ternary.True;
      const props = source.flags & TypeFlags.Intersection ? getPropertiesOfUnionOrIntersectionType(<IntersectionType>source) : getPropertiesOfObjectType(source);
      for (const prop of props) {
        if (isIgnoredJsxProperty(source, prop)) continue;
        const nameType = s.getLinks(prop).nameType;
        if (nameType && nameType.flags & TypeFlags.UniqueESSymbol) continue;
        if (kind === IndexKind.String || NumericLiteral.name(prop.escName)) {
          const related = isRelatedTo(getTypeOfSymbol(prop), target, reportErrors);
          if (!related) {
            if (reportErrors) reportError(qd.Property_0_is_incompatible_with_index_signature, prop.symbolToString());
            return Ternary.False;
          }
          result &= related;
        }
      }
      return result;
    }
    function indexTypeRelatedTo(sourceType: Type, targetType: Type, reportErrors: boolean) {
      const related = isRelatedTo(sourceType, targetType, reportErrors);
      if (!related && reportErrors) reportError(qd.Index_signatures_are_incompatible);
      return related;
    }
    function indexTypesRelatedTo(source: Type, target: Type, kind: IndexKind, sourceIsPrimitive: boolean, reportErrors: boolean, intersectionState: IntersectionState): Ternary {
      if (relation === identityRelation) return indexTypesIdenticalTo(source, target, kind);
      const targetType = getIndexTypeOfType(target, kind);
      if (!targetType || (targetType.flags & TypeFlags.Any && !sourceIsPrimitive)) return Ternary.True;
      if (isGenericMappedType(source)) return getIndexTypeOfType(target, IndexKind.String) ? isRelatedTo(getTemplateTypeFromMappedType(source), targetType, reportErrors) : Ternary.False;
      const indexType = getIndexTypeOfType(source, kind) || (kind === IndexKind.Number && getIndexTypeOfType(source, IndexKind.String));
      if (indexType) return indexTypeRelatedTo(indexType, targetType, reportErrors);
      if (!(intersectionState & IntersectionState.Source) && isObjectTypeWithInferableIndex(source)) {
        let related = eachPropertyRelatedTo(source, targetType, kind, reportErrors);
        if (related && kind === IndexKind.String) {
          const numberIndexType = getIndexTypeOfType(source, IndexKind.Number);
          if (numberIndexType) related &= indexTypeRelatedTo(numberIndexType, targetType, reportErrors);
        }
        return related;
      }
      if (reportErrors) reportError(qd.Index_signature_is_missing_in_type_0, typeToString(source));
      return Ternary.False;
    }
    function indexTypesIdenticalTo(source: Type, target: Type, indexKind: IndexKind): Ternary {
      const targetInfo = getIndexInfoOfType(target, indexKind);
      const sourceInfo = getIndexInfoOfType(source, indexKind);
      if (!sourceInfo && !targetInfo) return Ternary.True;
      if (sourceInfo && targetInfo && sourceInfo.isReadonly === targetInfo.isReadonly) return isRelatedTo(sourceInfo.type, targetInfo.type);
      return Ternary.False;
    }
    function constructorVisibilitiesAreCompatible(sourceSignature: Signature, targetSignature: Signature, reportErrors: boolean) {
      if (!sourceSignature.declaration || !targetSignature.declaration) return true;
      const sourceAccessibility = getSelectedEffectiveModifierFlags(sourceSignature.declaration, ModifierFlags.NonPublicAccessibilityModifier);
      const targetAccessibility = getSelectedEffectiveModifierFlags(targetSignature.declaration, ModifierFlags.NonPublicAccessibilityModifier);
      if (targetAccessibility === ModifierFlags.Private) return true;
      if (targetAccessibility === ModifierFlags.Protected && sourceAccessibility !== ModifierFlags.Private) return true;
      if (targetAccessibility !== ModifierFlags.Protected && !sourceAccessibility) return true;
      if (reportErrors) reportError(qd.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility));
      return false;
    }
  }
  function typeCouldHaveTopLevelSingletonTypes(type: Type): boolean {
    if (type.flags & TypeFlags.UnionOrIntersection) return !!forEach((type as IntersectionType).types, typeCouldHaveTopLevelSingletonTypes);
    if (type.flags & TypeFlags.Instantiable) {
      const constraint = getConstraintOfType(type);
      if (constraint) return typeCouldHaveTopLevelSingletonTypes(constraint);
    }
    return isUnitType(type);
  }
  function getBestMatchingType(source: Type, target: UnionOrIntersectionType, isRelatedTo = compareTypesAssignable) {
    return (
      findMatchingDiscriminantType(source, target, isRelatedTo, true) ||
      findMatchingTypeReferenceOrTypeAliasReference(source, target) ||
      findBestTypeForObjectLiteral(source, target) ||
      findBestTypeForInvokable(source, target) ||
      findMostOverlappyType(source, target)
    );
  }
  function discriminateTypeByDiscriminableItems(
    target: UnionType,
    discriminators: [() => Type, __String][],
    related: (source: Type, target: Type) => boolean | Ternary,
    defaultValue?: undefined,
    skipPartial?: boolean
  ): Type | undefined;
  function discriminateTypeByDiscriminableItems(
    target: UnionType,
    discriminators: [() => Type, __String][],
    related: (source: Type, target: Type) => boolean | Ternary,
    defaultValue: Type,
    skipPartial?: boolean
  ): Type;
  function discriminateTypeByDiscriminableItems(
    target: UnionType,
    discriminators: [() => Type, __String][],
    related: (source: Type, target: Type) => boolean | Ternary,
    defaultValue?: Type,
    skipPartial?: boolean
  ) {
    const discriminable = target.types.map((_) => undefined) as (boolean | undefined)[];
    for (const [getDiscriminatingType, propertyName] of discriminators) {
      const targetProp = getUnionOrIntersectionProperty(target, propertyName);
      if (skipPartial && targetProp && getCheckFlags(targetProp) & CheckFlags.ReadPartial) continue;
      let i = 0;
      for (const type of target.types) {
        const targetType = getTypeOfPropertyOfType(type, propertyName);
        if (targetType && related(getDiscriminatingType(), targetType)) discriminable[i] = discriminable[i] === undefined ? true : discriminable[i];
        else {
          discriminable[i] = false;
        }
        i++;
      }
    }
    const match = discriminable.indexOf(true);
    return match === -1 || discriminable.indexOf(true, match + 1) !== -1 ? defaultValue : target.types[match];
  }
  function isWeakType(type: Type): boolean {
    if (type.flags & TypeFlags.Object) {
      const resolved = resolveStructuredTypeMembers(<ObjectType>type);
      return (
        resolved.callSignatures.length === 0 &&
        resolved.constructSignatures.length === 0 &&
        !resolved.stringIndexInfo &&
        !resolved.numberIndexInfo &&
        resolved.properties.length > 0 &&
        every(resolved.properties, (p) => !!(p.flags & SymbolFlags.Optional))
      );
    }
    if (type.flags & TypeFlags.Intersection) return every((<IntersectionType>type).types, isWeakType);
    return false;
  }
  function hasCommonProperties(source: Type, target: Type, isComparingJsxAttributes: boolean) {
    for (const prop of getPropertiesOfType(source)) {
      if (isKnownProperty(target, prop.escName, isComparingJsxAttributes)) return true;
    }
    return false;
  }
  function getMarkerTypeReference(type: GenericType, source: TypeParameter, target: Type) {
    const result = createTypeReference(
      type,
      map(type.typeParameters, (t) => (t === source ? target : t))
    );
    result.objectFlags |= ObjectFlags.MarkerType;
    return result;
  }
  function getVariancesWorker<TCache extends { variances?: VarianceFlags[] }>(
    typeParameters: readonly TypeParameter[] = empty,
    cache: TCache,
    createMarkerType: (input: TCache, param: TypeParameter, marker: Type) => Type
  ): VarianceFlags[] {
    let variances = cache.variances;
    if (!variances) {
      cache.variances = empty;
      variances = [];
      for (const tp of typeParameters) {
        let unmeasurable = false;
        let unreliable = false;
        const oldHandler = outofbandVarianceMarkerHandler;
        outofbandVarianceMarkerHandler = (onlyUnreliable) => (onlyUnreliable ? (unreliable = true) : (unmeasurable = true));
        const typeWithSuper = createMarkerType(cache, tp, markerSuperType);
        const typeWithSub = createMarkerType(cache, tp, markerSubType);
        let variance = (isTypeAssignableTo(typeWithSub, typeWithSuper) ? VarianceFlags.Covariant : 0) | (isTypeAssignableTo(typeWithSuper, typeWithSub) ? VarianceFlags.Contravariant : 0);
        if (variance === VarianceFlags.Bivariant && isTypeAssignableTo(createMarkerType(cache, tp, markerOtherType), typeWithSuper)) variance = VarianceFlags.Independent;
        outofbandVarianceMarkerHandler = oldHandler;
        if (unmeasurable || unreliable) {
          if (unmeasurable) variance |= VarianceFlags.Unmeasurable;
          if (unreliable) variance |= VarianceFlags.Unreliable;
        }
        variances.push(variance);
      }
      cache.variances = variances;
    }
    return variances;
  }
  function getVariances(type: GenericType): VarianceFlags[] {
    if (type === globalArrayType || type === globalReadonlyArrayType || type.objectFlags & ObjectFlags.Tuple) return arrayVariances;
    return getVariancesWorker(type.typeParameters, type, getMarkerTypeReference);
  }
  function hasCovariantVoidArgument(typeArguments: readonly Type[], variances: VarianceFlags[]): boolean {
    for (let i = 0; i < variances.length; i++) {
      if ((variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Covariant && typeArguments[i].flags & TypeFlags.Void) return true;
    }
    return false;
  }
  function isUnconstrainedTypeParameter(type: Type) {
    return type.flags & TypeFlags.TypeParameter && !getConstraintOfTypeParameter(<TypeParameter>type);
  }
  function isNonDeferredTypeReference(type: Type): type is TypeReference {
    return !!(getObjectFlags(type) & ObjectFlags.Reference) && !(<TypeReference>type).node;
  }
  function isTypeReferenceWithGenericArguments(type: Type): boolean {
    return isNonDeferredTypeReference(type) && some(getTypeArguments(type), (t) => isUnconstrainedTypeParameter(t) || isTypeReferenceWithGenericArguments(t));
  }
  function getTypeReferenceId(type: TypeReference, typeParameters: Type[], depth = 0) {
    let result = '' + type.target.id;
    for (const t of getTypeArguments(type)) {
      if (isUnconstrainedTypeParameter(t)) {
        let index = typeParameters.indexOf(t);
        if (index < 0) {
          index = typeParameters.length;
          typeParameters.push(t);
        }
        result += '=' + index;
      } else if (depth < 4 && isTypeReferenceWithGenericArguments(t)) {
        result += '<' + getTypeReferenceId(t as TypeReference, typeParameters, depth + 1) + '>';
      } else {
        result += '-' + t.id;
      }
    }
    return result;
  }
  function getRelationKey(source: Type, target: Type, intersectionState: IntersectionState, relation: qb.QMap<RelationComparisonResult>) {
    if (relation === identityRelation && source.id > target.id) {
      const temp = source;
      source = target;
      target = temp;
    }
    const postFix = intersectionState ? ':' + intersectionState : '';
    if (isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target)) {
      const typeParameters: Type[] = [];
      return getTypeReferenceId(<TypeReference>source, typeParameters) + ',' + getTypeReferenceId(<TypeReference>target, typeParameters) + postFix;
    }
    return source.id + ',' + target.id + postFix;
  }
  function forEachProperty<T>(prop: Symbol, callback: (p: Symbol) => T): T | undefined {
    if (getCheckFlags(prop) & CheckFlags.Synthetic) {
      for (const t of (<TransientSymbol>prop).containingType!.types) {
        const p = getPropertyOfType(t, prop.escName);
        const result = p && forEachProperty(p, callback);
        if (result) return result;
      }
      return;
    }
    return callback(prop);
  }
  function getDeclaringClass(prop: Symbol) {
    return prop.parent && prop.parent.flags & SymbolFlags.Class ? <InterfaceType>getDeclaredTypeOfSymbol(getParentOfSymbol(prop)!) : undefined;
  }
  function getTypeOfPropertyInBaseClass(property: Symbol) {
    const classType = getDeclaringClass(property);
    const baseClassType = classType && getBaseTypes(classType)[0];
    return baseClassType && getTypeOfPropertyOfType(baseClassType, property.escName);
  }
  function isPropertyInClassDerivedFrom(prop: Symbol, baseClass: Type | undefined) {
    return forEachProperty(prop, (sp) => {
      const sourceClass = getDeclaringClass(sp);
      return sourceClass ? hasBaseType(sourceClass, baseClass) : false;
    });
  }
  function isValidOverrideOf(sourceProp: Symbol, targetProp: Symbol) {
    return !forEachProperty(targetProp, (tp) => (getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlags.Protected ? !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false));
  }
  function isClassDerivedFromDeclaringClasses(checkClass: Type, prop: Symbol) {
    return forEachProperty(prop, (p) => (getDeclarationModifierFlagsFromSymbol(p) & ModifierFlags.Protected ? !hasBaseType(checkClass, getDeclaringClass(p)) : false)) ? undefined : checkClass;
  }
  function isDeeplyNestedType(type: Type, stack: Type[], depth: number): boolean {
    if (depth >= 5 && type.flags & TypeFlags.Object && !isObjectOrArrayLiteralType(type)) {
      const symbol = type.symbol;
      if (symbol) {
        let count = 0;
        for (let i = 0; i < depth; i++) {
          const t = stack[i];
          if (t.flags & TypeFlags.Object && t.symbol === symbol) {
            count++;
            if (count >= 5) return true;
          }
        }
      }
    }
    if (depth >= 5 && type.flags & TypeFlags.IndexedAccess) {
      const root = getRootObjectTypeFromIndexedAccessChain(type);
      let count = 0;
      for (let i = 0; i < depth; i++) {
        const t = stack[i];
        if (getRootObjectTypeFromIndexedAccessChain(t) === root) {
          count++;
          if (count >= 5) return true;
        }
      }
    }
    return false;
  }
  function getRootObjectTypeFromIndexedAccessChain(type: Type) {
    let t = type;
    while (t.flags & TypeFlags.IndexedAccess) {
      t = (t as IndexedAccessType).objectType;
    }
    return t;
  }
  function isPropertyIdenticalTo(sourceProp: Symbol, targetProp: Symbol): boolean {
    return compareProperties(sourceProp, targetProp, compareTypesIdentical) !== Ternary.False;
  }
  function compareProperties(sourceProp: Symbol, targetProp: Symbol, compareTypes: (source: Type, target: Type) => Ternary): Ternary {
    if (sourceProp === targetProp) return Ternary.True;
    const sourcePropAccessibility = getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlags.NonPublicAccessibilityModifier;
    const targetPropAccessibility = getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlags.NonPublicAccessibilityModifier;
    if (sourcePropAccessibility !== targetPropAccessibility) return Ternary.False;
    if (sourcePropAccessibility) {
      if (getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp)) return Ternary.False;
    } else {
      if ((sourceProp.flags & SymbolFlags.Optional) !== (targetProp.flags & SymbolFlags.Optional)) return Ternary.False;
    }
    if (isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp)) return Ternary.False;
    return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
  }
  function isMatchingSignature(source: Signature, target: Signature, partialMatch: boolean) {
    const sourceParameterCount = getParameterCount(source);
    const targetParameterCount = getParameterCount(target);
    const sourceMinArgumentCount = getMinArgumentCount(source);
    const targetMinArgumentCount = getMinArgumentCount(target);
    const sourceHasRestParameter = hasEffectiveRestParameter(source);
    const targetHasRestParameter = hasEffectiveRestParameter(target);
    if (sourceParameterCount === targetParameterCount && sourceMinArgumentCount === targetMinArgumentCount && sourceHasRestParameter === targetHasRestParameter) return true;
    if (partialMatch && sourceMinArgumentCount <= targetMinArgumentCount) return true;
    return false;
  }
  function compareSignaturesIdentical(
    source: Signature,
    target: Signature,
    partialMatch: boolean,
    ignoreThisTypes: boolean,
    ignoreReturnTypes: boolean,
    compareTypes: (s: Type, t: Type) => Ternary
  ): Ternary {
    if (source === target) return Ternary.True;
    if (!isMatchingSignature(source, target, partialMatch)) return Ternary.False;
    if (length(source.typeParameters) !== length(target.typeParameters)) return Ternary.False;
    if (target.typeParameters) {
      const mapper = createTypeMapper(source.typeParameters!, target.typeParameters);
      for (let i = 0; i < target.typeParameters.length; i++) {
        const s = source.typeParameters![i];
        const t = target.typeParameters[i];
        if (
          !(
            s === t ||
            (compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) &&
              compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType))
          )
        ) {
          return Ternary.False;
        }
      }
      source = instantiateSignature(source, mapper, true);
    }
    let result = Ternary.True;
    if (!ignoreThisTypes) {
      const sourceThisType = getThisTypeOfSignature(source);
      if (sourceThisType) {
        const targetThisType = getThisTypeOfSignature(target);
        if (targetThisType) {
          const related = compareTypes(sourceThisType, targetThisType);
          if (!related) return Ternary.False;
          result &= related;
        }
      }
    }
    const targetLen = getParameterCount(target);
    for (let i = 0; i < targetLen; i++) {
      const s = getTypeAtPosition(source, i);
      const t = getTypeAtPosition(target, i);
      const related = compareTypes(t, s);
      if (!related) return Ternary.False;
      result &= related;
    }
    if (!ignoreReturnTypes) {
      const sourceTypePredicate = getTypePredicateOfSignature(source);
      const targetTypePredicate = getTypePredicateOfSignature(target);
      result &=
        sourceTypePredicate || targetTypePredicate
          ? compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes)
          : compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
    }
    return result;
  }
  function compareTypePredicatesIdentical(source: TypePredicate | undefined, target: TypePredicate | undefined, compareTypes: (s: Type, t: Type) => Ternary): Ternary {
    return !(source && target && typePredicateKindsMatch(source, target))
      ? Ternary.False
      : source.type === target.type
      ? Ternary.True
      : source.type && target.type
      ? compareTypes(source.type, target.type)
      : Ternary.False;
  }
  function literalTypesWithSameBaseType(types: Type[]): boolean {
    let commonBaseType: Type | undefined;
    for (const t of types) {
      const baseType = getBaseTypeOfLiteralType(t);
      if (!commonBaseType) commonBaseType = baseType;
      if (baseType === t || baseType !== commonBaseType) return false;
    }
    return true;
  }
  function getSupertypeOrUnion(types: Type[]): Type {
    return literalTypesWithSameBaseType(types) ? getUnionType(types) : reduceLeft(types, (s, t) => (isTypeSubtypeOf(s, t) ? t : s))!;
  }
  function getCommonSupertype(types: Type[]): Type {
    if (!strictNullChecks) return getSupertypeOrUnion(types);
    const primaryTypes = filter(types, (t) => !(t.flags & TypeFlags.Nullable));
    return primaryTypes.length ? getNullableType(getSupertypeOrUnion(primaryTypes), getFalsyFlagsOfTypes(types) & TypeFlags.Nullable) : getUnionType(types, UnionReduction.Subtype);
  }
  function getCommonSubtype(types: Type[]) {
    return reduceLeft(types, (s, t) => (isTypeSubtypeOf(t, s) ? t : s))!;
  }
  function isArrayType(type: Type): boolean {
    return !!(getObjectFlags(type) & ObjectFlags.Reference) && ((<TypeReference>type).target === globalArrayType || (<TypeReference>type).target === globalReadonlyArrayType);
  }
  function isReadonlyArrayType(type: Type): boolean {
    return !!(getObjectFlags(type) & ObjectFlags.Reference) && (<TypeReference>type).target === globalReadonlyArrayType;
  }
  function isMutableArrayOrTuple(type: Type): boolean {
    return (isArrayType(type) && !isReadonlyArrayType(type)) || (isTupleType(type) && !type.target.readonly);
  }
  function getElementTypeOfArrayType(type: Type): Type | undefined {
    return isArrayType(type) ? getTypeArguments(type as TypeReference)[0] : undefined;
  }
  function isArrayLikeType(type: Type): boolean {
    return isArrayType(type) || (!(type.flags & TypeFlags.Nullable) && isTypeAssignableTo(type, anyReadonlyArrayType));
  }
  function isEmptyArrayLiteralType(type: Type): boolean {
    const elementType = isArrayType(type) ? getTypeArguments(<TypeReference>type)[0] : undefined;
    return elementType === undefinedWideningType || elementType === implicitNeverType;
  }
  function isTupleLikeType(type: Type): boolean {
    return isTupleType(type) || !!getPropertyOfType(type, '0' as __String);
  }
  function isArrayOrTupleLikeType(type: Type): boolean {
    return isArrayLikeType(type) || isTupleLikeType(type);
  }
  function getTupleElementType(type: Type, index: number) {
    const propType = getTypeOfPropertyOfType(type, ('' + index) as __String);
    if (propType) return propType;
    if (everyType(type, isTupleType)) return mapType(type, (t) => getRestTypeOfTupleType(<TupleTypeReference>t) || undefinedType);
    return;
  }
  function isNeitherUnitTypeNorNever(type: Type): boolean {
    return !(type.flags & (TypeFlags.Unit | TypeFlags.Never));
  }
  function isUnitType(type: Type): boolean {
    return !!(type.flags & TypeFlags.Unit);
  }
  function isLiteralType(type: Type): boolean {
    return type.flags & TypeFlags.Boolean ? true : type.flags & TypeFlags.Union ? (type.flags & TypeFlags.EnumLiteral ? true : every((<UnionType>type).types, isUnitType)) : isUnitType(type);
  }
  function getBaseTypeOfLiteralType(type: Type): Type {
    return type.flags & TypeFlags.EnumLiteral
      ? getBaseTypeOfEnumLiteralType(<LiteralType>type)
      : type.flags & TypeFlags.StringLiteral
      ? stringType
      : type.flags & TypeFlags.NumberLiteral
      ? numberType
      : type.flags & TypeFlags.BigIntLiteral
      ? bigintType
      : type.flags & TypeFlags.BooleanLiteral
      ? booleanType
      : type.flags & TypeFlags.Union
      ? getUnionType(sameMap((<UnionType>type).types, getBaseTypeOfLiteralType))
      : type;
  }
  function getWidenedLiteralType(type: Type): Type {
    return type.flags & TypeFlags.EnumLiteral && isFreshLiteralType(type)
      ? getBaseTypeOfEnumLiteralType(<LiteralType>type)
      : type.flags & TypeFlags.StringLiteral && isFreshLiteralType(type)
      ? stringType
      : type.flags & TypeFlags.NumberLiteral && isFreshLiteralType(type)
      ? numberType
      : type.flags & TypeFlags.BigIntLiteral && isFreshLiteralType(type)
      ? bigintType
      : type.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(type)
      ? booleanType
      : type.flags & TypeFlags.Union
      ? getUnionType(sameMap((<UnionType>type).types, getWidenedLiteralType))
      : type;
  }
  function getWidenedUniqueESSymbolType(type: Type): Type {
    return type.flags & TypeFlags.UniqueESSymbol ? esSymbolType : type.flags & TypeFlags.Union ? getUnionType(sameMap((<UnionType>type).types, getWidenedUniqueESSymbolType)) : type;
  }
  function getWidenedLiteralLikeTypeForContextualType(type: Type, contextualType: Type | undefined) {
    if (!isLiteralOfContextualType(type, contextualType)) type = getWidenedUniqueESSymbolType(getWidenedLiteralType(type));
    return type;
  }
  function getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(type: Type | undefined, contextualSignatureReturnType: Type | undefined, isAsync: boolean) {
    if (type && isUnitType(type)) {
      const contextualType = !contextualSignatureReturnType ? undefined : isAsync ? getPromisedTypeOfPromise(contextualSignatureReturnType) : contextualSignatureReturnType;
      type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
    }
    return type;
  }
  function getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(type: Type | undefined, contextualSignatureReturnType: Type | undefined, kind: IterationTypeKind, isAsyncGenerator: boolean) {
    if (type && isUnitType(type)) {
      const contextualType = !contextualSignatureReturnType ? undefined : getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator);
      type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
    }
    return type;
  }
  function isTupleType(type: Type): type is TupleTypeReference {
    return !!(getObjectFlags(type) & ObjectFlags.Reference && (<TypeReference>type).target.objectFlags & ObjectFlags.Tuple);
  }
  function getRestTypeOfTupleType(type: TupleTypeReference) {
    return type.target.hasRestElement ? getTypeArguments(type)[type.target.typeParameters!.length - 1] : undefined;
  }
  function getRestArrayTypeOfTupleType(type: TupleTypeReference) {
    const restType = getRestTypeOfTupleType(type);
    return restType && createArrayType(restType);
  }
  function getLengthOfTupleType(type: TupleTypeReference) {
    return getTypeReferenceArity(type) - (type.target.hasRestElement ? 1 : 0);
  }
  function isZeroBigInt({ value }: BigIntLiteralType) {
    return value.base10Value === '0';
  }
  function getFalsyFlagsOfTypes(types: Type[]): TypeFlags {
    let result: TypeFlags = 0;
    for (const t of types) {
      result |= getFalsyFlags(t);
    }
    return result;
  }
  function getFalsyFlags(type: Type): TypeFlags {
    return type.flags & TypeFlags.Union
      ? getFalsyFlagsOfTypes((<UnionType>type).types)
      : type.flags & TypeFlags.StringLiteral
      ? (<StringLiteralType>type).value === ''
        ? TypeFlags.StringLiteral
        : 0
      : type.flags & TypeFlags.NumberLiteral
      ? (<NumberLiteralType>type).value === 0
        ? TypeFlags.NumberLiteral
        : 0
      : type.flags & TypeFlags.BigIntLiteral
      ? isZeroBigInt(<BigIntLiteralType>type)
        ? TypeFlags.BigIntLiteral
        : 0
      : type.flags & TypeFlags.BooleanLiteral
      ? type === falseType || type === regularFalseType
        ? TypeFlags.BooleanLiteral
        : 0
      : type.flags & TypeFlags.PossiblyFalsy;
  }
  function removeDefinitelyFalsyTypes(type: Type): Type {
    return getFalsyFlags(type) & TypeFlags.DefinitelyFalsy ? filterType(type, (t) => !(getFalsyFlags(t) & TypeFlags.DefinitelyFalsy)) : type;
  }
  function extractDefinitelyFalsyTypes(type: Type): Type {
    return mapType(type, getDefinitelyFalsyPartOfType);
  }
  function getDefinitelyFalsyPartOfType(type: Type): Type {
    return type.flags & TypeFlags.String
      ? emptyStringType
      : type.flags & TypeFlags.Number
      ? zeroType
      : type.flags & TypeFlags.BigInt
      ? zeroBigIntType
      : type === regularFalseType ||
        type === falseType ||
        type.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null) ||
        (type.flags & TypeFlags.StringLiteral && (<StringLiteralType>type).value === '') ||
        (type.flags & TypeFlags.NumberLiteral && (<NumberLiteralType>type).value === 0) ||
        (type.flags & TypeFlags.BigIntLiteral && isZeroBigInt(<BigIntLiteralType>type))
      ? type
      : neverType;
  }
  function getNullableType(type: Type, flags: TypeFlags): Type {
    const missing = flags & ~type.flags & (TypeFlags.Undefined | TypeFlags.Null);
    return missing === 0
      ? type
      : missing === TypeFlags.Undefined
      ? getUnionType([type, undefinedType])
      : missing === TypeFlags.Null
      ? getUnionType([type, nullType])
      : getUnionType([type, undefinedType, nullType]);
  }
  function getOptionalType(type: Type): Type {
    assert(strictNullChecks);
    return type.flags & TypeFlags.Undefined ? type : getUnionType([type, undefinedType]);
  }
  function getGlobalNonNullableTypeInstantiation(type: Type) {
    if (!deferredGlobalNonNullableTypeAlias) deferredGlobalNonNullableTypeAlias = getGlobalSymbol('NonNullable' as __String, SymbolFlags.TypeAlias, undefined) || unknownSymbol;
    if (deferredGlobalNonNullableTypeAlias !== unknownSymbol) return getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, [type]);
    return getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
  }
  function getNonNullableType(type: Type): Type {
    return strictNullChecks ? getGlobalNonNullableTypeInstantiation(type) : type;
  }
  function addOptionalTypeMarker(type: Type) {
    return strictNullChecks ? getUnionType([type, optionalType]) : type;
  }
  function isNotOptionalTypeMarker(type: Type) {
    return type !== optionalType;
  }
  function removeOptionalTypeMarker(type: Type): Type {
    return strictNullChecks ? filterType(type, isNotOptionalTypeMarker) : type;
  }
  function propagateOptionalTypeMarker(type: Type, node: OptionalChain, wasOptional: boolean) {
    return wasOptional ? (isOutermostOptionalChain(node) ? getOptionalType(type) : addOptionalTypeMarker(type)) : type;
  }
  function getOptionalExpressionType(exprType: Type, expression: Expression) {
    return qc.is.expressionOfOptionalChainRoot(expression) ? getNonNullableType(exprType) : qc.is.optionalChain(expression) ? removeOptionalTypeMarker(exprType) : exprType;
  }
  function isCoercibleUnderDoubleEquals(source: Type, target: Type): boolean {
    return (source.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.BooleanLiteral)) !== 0 && (target.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.Boolean)) !== 0;
  }
  function isObjectTypeWithInferableIndex(type: Type): boolean {
    return type.flags & TypeFlags.Intersection
      ? every((<IntersectionType>type).types, isObjectTypeWithInferableIndex)
      : !!(type.symbol && (type.symbol.flags & (SymbolFlags.ObjectLiteral | SymbolFlags.TypeLiteral | SymbolFlags.Enum | SymbolFlags.ValueModule)) !== 0 && !typeHasCallOrConstructSignatures(type)) ||
          !!(getObjectFlags(type) & ObjectFlags.ReverseMapped && isObjectTypeWithInferableIndex((type as ReverseMappedType).source));
  }
  function createSymbolWithType(source: Symbol, type: Type | undefined) {
    const symbol = new QSymbol(source.flags, source.escName, getCheckFlags(source) & CheckFlags.Readonly);
    symbol.declarations = source.declarations;
    symbol.parent = source.parent;
    symbol.type = type;
    symbol.target = source;
    if (source.valueDeclaration) symbol.valueDeclaration = source.valueDeclaration;
    const nameType = s.getLinks(source).nameType;
    if (nameType) symbol.nameType = nameType;
    return symbol;
  }
  function transformTypeOfMembers(type: Type, f: (propertyType: Type) => Type) {
    const members = new SymbolTable();
    for (const property of getPropertiesOfObjectType(type)) {
      const original = getTypeOfSymbol(property);
      const updated = f(original);
      members.set(property.escName, updated === original ? property : createSymbolWithType(property, updated));
    }
    return members;
  }
  function getRegularTypeOfObjectLiteral(type: Type): Type {
    if (!(isObjectLiteralType(type) && getObjectFlags(type) & ObjectFlags.FreshLiteral)) return type;
    const regularType = (<FreshObjectLiteralType>type).regularType;
    if (regularType) return regularType;
    const resolved = <ResolvedType>type;
    const members = transformTypeOfMembers(type, getRegularTypeOfObjectLiteral);
    const regularNew = createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.stringIndexInfo, resolved.numberIndexInfo);
    regularNew.flags = resolved.flags;
    regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlags.FreshLiteral;
    (<FreshObjectLiteralType>type).regularType = regularNew;
    return regularNew;
  }
  function createWideningContext(parent: WideningContext | undefined, propertyName: __String | undefined, siblings: Type[] | undefined): WideningContext {
    return { parent, propertyName, siblings, resolvedProperties: undefined };
  }
  function getSiblingsOfContext(context: WideningContext): Type[] {
    if (!context.siblings) {
      const siblings: Type[] = [];
      for (const type of getSiblingsOfContext(context.parent!)) {
        if (isObjectLiteralType(type)) {
          const prop = getPropertyOfObjectType(type, context.propertyName!);
          if (prop) {
            forEachType(getTypeOfSymbol(prop), (t) => {
              siblings.push(t);
            });
          }
        }
      }
      context.siblings = siblings;
    }
    return context.siblings;
  }
  function getPropertiesOfContext(context: WideningContext): Symbol[] {
    if (!context.resolvedProperties) {
      const names = new qb.QMap<Symbol>() as UnderscoreEscapedMap<Symbol>;
      for (const t of getSiblingsOfContext(context)) {
        if (isObjectLiteralType(t) && !(getObjectFlags(t) & ObjectFlags.ContainsSpread)) {
          for (const prop of getPropertiesOfType(t)) {
            names.set(prop.escName, prop);
          }
        }
      }
      context.resolvedProperties = arrayFrom(names.values());
    }
    return context.resolvedProperties;
  }
  function getWidenedProperty(prop: Symbol, context: WideningContext | undefined): Symbol {
    if (!(prop.flags & SymbolFlags.Property)) return prop;
    const original = getTypeOfSymbol(prop);
    const propContext = context && createWideningContext(context, prop.escName, undefined);
    const widened = getWidenedTypeWithContext(original, propContext);
    return widened === original ? prop : createSymbolWithType(prop, widened);
  }
  function getUndefinedProperty(prop: Symbol) {
    const cached = undefinedProperties.get(prop.escName);
    if (cached) return cached;
    const result = createSymbolWithType(prop, undefinedType);
    result.flags |= SymbolFlags.Optional;
    undefinedProperties.set(prop.escName, result);
    return result;
  }
  function getWidenedTypeOfObjectLiteral(type: Type, context: WideningContext | undefined): Type {
    const members = new SymbolTable();
    for (const prop of getPropertiesOfObjectType(type)) {
      members.set(prop.escName, getWidenedProperty(prop, context));
    }
    if (context) {
      for (const prop of getPropertiesOfContext(context)) {
        if (!members.has(prop.escName)) members.set(prop.escName, getUndefinedProperty(prop));
      }
    }
    const stringIndexInfo = getIndexInfoOfType(type, IndexKind.String);
    const numberIndexInfo = getIndexInfoOfType(type, IndexKind.Number);
    const result = createAnonymousType(
      type.symbol,
      members,
      empty,
      empty,
      stringIndexInfo && createIndexInfo(getWidenedType(stringIndexInfo.type), stringIndexInfo.isReadonly),
      numberIndexInfo && createIndexInfo(getWidenedType(numberIndexInfo.type), numberIndexInfo.isReadonly)
    );
    result.objectFlags |= getObjectFlags(type) & (ObjectFlags.JSLiteral | ObjectFlags.NonInferrableType);
    return result;
  }
  function getWidenedType(type: Type) {
    return getWidenedTypeWithContext(type, undefined);
  }
  function getWidenedTypeWithContext(type: Type, context: WideningContext | undefined): Type {
    if (getObjectFlags(type) & ObjectFlags.RequiresWidening) {
      if (context === undefined && type.widened) return type.widened;
      let result: Type | undefined;
      if (type.flags & (TypeFlags.Any | TypeFlags.Nullable)) result = anyType;
      else if (isObjectLiteralType(type)) {
        result = getWidenedTypeOfObjectLiteral(type, context);
      } else if (type.flags & TypeFlags.Union) {
        const unionContext = context || createWideningContext(undefined, (<UnionType>type).types);
        const widenedTypes = sameMap((<UnionType>type).types, (t) => (t.flags & TypeFlags.Nullable ? t : getWidenedTypeWithContext(t, unionContext)));
        result = getUnionType(widenedTypes, some(widenedTypes, isEmptyObjectType) ? UnionReduction.Subtype : UnionReduction.Literal);
      } else if (type.flags & TypeFlags.Intersection) {
        result = getIntersectionType(sameMap((<IntersectionType>type).types, getWidenedType));
      } else if (isArrayType(type) || isTupleType(type)) {
        result = createTypeReference((<TypeReference>type).target, sameMap(getTypeArguments(<TypeReference>type), getWidenedType));
      }
      if (result && context === undefined) type.widened = result;
      return result || type;
    }
    return type;
  }
  function reportWideningErrorsInType(type: Type): boolean {
    let errorReported = false;
    if (getObjectFlags(type) & ObjectFlags.ContainsWideningType) {
      if (type.flags & TypeFlags.Union) {
        if (some((<UnionType>type).types, isEmptyObjectType)) errorReported = true;
        else {
          for (const t of (<UnionType>type).types) {
            if (reportWideningErrorsInType(t)) errorReported = true;
          }
        }
      }
      if (isArrayType(type) || isTupleType(type)) {
        for (const t of getTypeArguments(<TypeReference>type)) {
          if (reportWideningErrorsInType(t)) errorReported = true;
        }
      }
      if (isObjectLiteralType(type)) {
        for (const p of getPropertiesOfObjectType(type)) {
          const t = getTypeOfSymbol(p);
          if (getObjectFlags(t) & ObjectFlags.ContainsWideningType) {
            if (!reportWideningErrorsInType(t)) error(p.valueDeclaration, qd.Object_literal_s_property_0_implicitly_has_an_1_type, p.symbolToString(), typeToString(getWidenedType(t)));
            errorReported = true;
          }
        }
      }
    }
    return errorReported;
  }
  function reportImplicitAny(declaration: Declaration, type: Type, wideningKind?: WideningKind) {
    const typeAsString = typeToString(getWidenedType(type));
    if (isInJSFile(declaration) && !isCheckJsEnabledForFile(qc.get.sourceFileOf(declaration), compilerOptions)) return;
    let diagnostic: DiagnosticMessage;
    switch (declaration.kind) {
      case Syntax.BinaryExpression:
      case Syntax.PropertyDeclaration:
      case Syntax.PropertySignature:
        diagnostic = noImplicitAny ? qd.Member_0_implicitly_has_an_1_type : qd.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
        break;
      case Syntax.Parameter:
        const param = declaration as ParameterDeclaration;
        if (
          qc.is.kind(Identifier, param.name) &&
          (qc.is.kind(CallSignatureDeclaration, param.parent) || qc.is.kind(MethodSignature, param.parent) || qc.is.kind(FunctionTypeNode, param.parent)) &&
          param.parent.parameters.indexOf(param) > -1 &&
          (resolveName(param, param.name.escapedText, SymbolFlags.Type, undefined, param.name.escapedText, true) ||
            (param.name.originalKeywordKind && syntax.is.typeNode(param.name.originalKeywordKind)))
        ) {
          const newName = 'arg' + param.parent.parameters.indexOf(param);
          errorOrSuggestion(noImplicitAny, declaration, qd.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, declarationNameToString(param.name));
          return;
        }
        diagnostic = (<ParameterDeclaration>declaration).dot3Token
          ? noImplicitAny
            ? qd.Rest_parameter_0_implicitly_has_an_any_type
            : qd.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage
          : noImplicitAny
          ? qd.Parameter_0_implicitly_has_an_1_type
          : qd.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
        break;
      case Syntax.BindingElement:
        diagnostic = qd.Binding_element_0_implicitly_has_an_1_type;
        if (!noImplicitAny) return;
        break;
      case Syntax.JSDocFunctionType:
        error(declaration, qd.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
        return;
      case Syntax.FunctionDeclaration:
      case Syntax.MethodDeclaration:
      case Syntax.MethodSignature:
      case Syntax.GetAccessor:
      case Syntax.SetAccessor:
      case Syntax.FunctionExpression:
      case Syntax.ArrowFunction:
        if (noImplicitAny && !(declaration as NamedDeclaration).name) {
          if (wideningKind === WideningKind.GeneratorYield)
            error(declaration, qd.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString);
          else {
            error(declaration, qd.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
          }
          return;
        }
        diagnostic = !noImplicitAny
          ? qd._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage
          : wideningKind === WideningKind.GeneratorYield
          ? qd._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type
          : qd._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;
        break;
      case Syntax.MappedType:
        if (noImplicitAny) error(declaration, qd.Mapped_object_type_implicitly_has_an_any_template_type);
        return;
      default:
        diagnostic = noImplicitAny ? qd.Variable_0_implicitly_has_an_1_type : qd.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
    }
    errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString);
  }
  function reportErrorsFromWidening(declaration: Declaration, type: Type, wideningKind?: WideningKind) {
    if (
      produceDiagnostics &&
      noImplicitAny &&
      getObjectFlags(type) & ObjectFlags.ContainsWideningType &&
      (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration as FunctionLikeDeclaration))
    ) {
      if (!reportWideningErrorsInType(type)) reportImplicitAny(declaration, type, wideningKind);
    }
  }
  function applyToParameterTypes(source: Signature, target: Signature, callback: (s: Type, t: Type) => void) {
    const sourceCount = getParameterCount(source);
    const targetCount = getParameterCount(target);
    const sourceRestType = getEffectiveRestType(source);
    const targetRestType = getEffectiveRestType(target);
    const targetNonRestCount = targetRestType ? targetCount - 1 : targetCount;
    const paramCount = sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount);
    const sourceThisType = getThisTypeOfSignature(source);
    if (sourceThisType) {
      const targetThisType = getThisTypeOfSignature(target);
      if (targetThisType) callback(sourceThisType, targetThisType);
    }
    for (let i = 0; i < paramCount; i++) {
      callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));
    }
    if (targetRestType) callback(getRestTypeAtPosition(source, paramCount), targetRestType);
  }
  function applyToReturnTypes(source: Signature, target: Signature, callback: (s: Type, t: Type) => void) {
    const sourceTypePredicate = getTypePredicateOfSignature(source);
    const targetTypePredicate = getTypePredicateOfSignature(target);
    if (sourceTypePredicate && targetTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type && targetTypePredicate.type)
      callback(sourceTypePredicate.type, targetTypePredicate.type);
    else {
      callback(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
    }
  }
  function createInferenceContext(typeParameters: readonly TypeParameter[], signature: Signature | undefined, flags: InferenceFlags, compareTypes?: TypeComparer): InferenceContext {
    return createInferenceContextWorker(typeParameters.map(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable);
  }
  function cloneInferenceContext<T extends InferenceContext | undefined>(context: T, extraFlags: InferenceFlags = 0): InferenceContext | (T & undefined) {
    return context && createInferenceContextWorker(map(context.inferences, cloneInferenceInfo), context.signature, context.flags | extraFlags, context.compareTypes);
  }
  function createInferenceContextWorker(inferences: InferenceInfo[], signature: Signature | undefined, flags: InferenceFlags, compareTypes: TypeComparer): InferenceContext {
    const context: InferenceContext = {
      inferences,
      signature,
      flags,
      compareTypes,
      mapper: makeFunctionTypeMapper((t) => mapToInferredType(context, t, true)),
      nonFixingMapper: makeFunctionTypeMapper((t) => mapToInferredType(context, t, false)),
    };
    return context;
  }
  function mapToInferredType(context: InferenceContext, t: Type, fix: boolean): Type {
    const inferences = context.inferences;
    for (let i = 0; i < inferences.length; i++) {
      const inference = inferences[i];
      if (t === inference.typeParameter) {
        if (fix && !inference.isFixed) {
          clearCachedInferences(inferences);
          inference.isFixed = true;
        }
        return getInferredType(context, i);
      }
    }
    return t;
  }
  function clearCachedInferences(inferences: InferenceInfo[]) {
    for (const inference of inferences) {
      if (!inference.isFixed) inference.inferredType = undefined;
    }
  }
  function createInferenceInfo(typeParameter: TypeParameter): InferenceInfo {
    return {
      typeParameter,
      candidates: undefined,
      contraCandidates: undefined,
      inferredType: undefined,
      priority: undefined,
      topLevel: true,
      isFixed: false,
    };
  }
  function cloneInferenceInfo(inference: InferenceInfo): InferenceInfo {
    return {
      typeParameter: inference.typeParameter,
      candidates: inference.candidates && inference.candidates.slice(),
      contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(),
      inferredType: inference.inferredType,
      priority: inference.priority,
      topLevel: inference.topLevel,
      isFixed: inference.isFixed,
    };
  }
  function cloneInferredPartOfContext(context: InferenceContext): InferenceContext | undefined {
    const inferences = filter(context.inferences, hasInferenceCandidates);
    return inferences.length ? createInferenceContextWorker(map(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes) : undefined;
  }
  function getMapperFromContext<T extends InferenceContext | undefined>(context: T): TypeMapper | (T & undefined) {
    return context && context.mapper;
  }
  function couldContainTypeVariables(type: Type): boolean {
    const objectFlags = getObjectFlags(type);
    if (objectFlags & ObjectFlags.CouldContainTypeVariablesComputed) return !!(objectFlags & ObjectFlags.CouldContainTypeVariables);
    const result = !!(
      type.flags & TypeFlags.Instantiable ||
      (type.flags & TypeFlags.Object &&
        !isNonGenericTopLevelType(type) &&
        ((objectFlags & ObjectFlags.Reference && ((<TypeReference>type).node || forEach(getTypeArguments(<TypeReference>type), couldContainTypeVariables))) ||
          (objectFlags & ObjectFlags.Anonymous &&
            type.symbol &&
            type.symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral) &&
            type.symbol.declarations) ||
          objectFlags & (ObjectFlags.Mapped | ObjectFlags.ObjectRestType))) ||
      (type.flags & TypeFlags.UnionOrIntersection && !(type.flags & TypeFlags.EnumLiteral) && !isNonGenericTopLevelType(type) && some((<UnionOrIntersectionType>type).types, couldContainTypeVariables))
    );
    if (type.flags & TypeFlags.ObjectFlagsType) (<ObjectFlagsType>type).objectFlags |= ObjectFlags.CouldContainTypeVariablesComputed | (result ? ObjectFlags.CouldContainTypeVariables : 0);
    return result;
  }
  function isNonGenericTopLevelType(type: Type) {
    if (type.aliasSymbol && !type.aliasTypeArguments) {
      const declaration = getDeclarationOfKind(type.aliasSymbol, Syntax.TypeAliasDeclaration);
      return !!(declaration && Node.findAncestor(declaration.parent, (n) => (n.kind === Syntax.SourceFile ? true : n.kind === Syntax.ModuleDeclaration ? false : 'quit')));
    }
    return false;
  }
  function isTypeParameterAtTopLevel(type: Type, typeParameter: TypeParameter): boolean {
    return !!(
      type === typeParameter ||
      (type.flags & TypeFlags.UnionOrIntersection && some((<UnionOrIntersectionType>type).types, (t) => isTypeParameterAtTopLevel(t, typeParameter))) ||
      (type.flags & TypeFlags.Conditional &&
        (isTypeParameterAtTopLevel(getTrueTypeFromConditionalType(<ConditionalType>type), typeParameter) ||
          isTypeParameterAtTopLevel(getFalseTypeFromConditionalType(<ConditionalType>type), typeParameter)))
    );
  }
  function createEmptyObjectTypeFromStringLiteral(type: Type) {
    const members = new SymbolTable();
    forEachType(type, (t) => {
      if (!(t.flags & TypeFlags.StringLiteral)) return;
      const name = syntax.get.escUnderscores((t as StringLiteralType).value);
      const literalProp = new QSymbol(SymbolFlags.Property, name);
      literalProp.type = anyType;
      if (t.symbol) {
        literalProp.declarations = t.symbol.declarations;
        literalProp.valueDeclaration = t.symbol.valueDeclaration;
      }
      members.set(name, literalProp);
    });
    const indexInfo = type.flags & TypeFlags.String ? createIndexInfo(emptyObjectType, false) : undefined;
    return createAnonymousType(undefined, members, empty, empty, indexInfo, undefined);
  }
  function inferTypeForHomomorphicMappedType(source: Type, target: MappedType, constraint: IndexType): Type | undefined {
    if (inInferTypeForHomomorphicMappedType) return;
    const key = source.id + ',' + target.id + ',' + constraint.id;
    if (reverseMappedCache.has(key)) return reverseMappedCache.get(key);
    inInferTypeForHomomorphicMappedType = true;
    const type = createReverseMappedType(source, target, constraint);
    inInferTypeForHomomorphicMappedType = false;
    reverseMappedCache.set(key, type);
    return type;
  }
  function isPartiallyInferableType(type: Type): boolean {
    return !(getObjectFlags(type) & ObjectFlags.NonInferrableType) || (isObjectLiteralType(type) && some(getPropertiesOfType(type), (prop) => isPartiallyInferableType(getTypeOfSymbol(prop))));
  }
  function createReverseMappedType(source: Type, target: MappedType, constraint: IndexType) {
    if (!(getIndexInfoOfType(source, IndexKind.String) || (getPropertiesOfType(source).length !== 0 && isPartiallyInferableType(source)))) return;
    if (isArrayType(source)) return createArrayType(inferReverseMappedType(getTypeArguments(<TypeReference>source)[0], target, constraint), isReadonlyArrayType(source));
    if (isTupleType(source)) {
      const elementTypes = map(getTypeArguments(source), (t) => inferReverseMappedType(t, target, constraint));
      const minLength = getMappedTypeModifiers(target) & MappedTypeModifiers.IncludeOptional ? getTypeReferenceArity(source) - (source.target.hasRestElement ? 1 : 0) : source.target.minLength;
      return createTupleType(elementTypes, minLength, source.target.hasRestElement, source.target.readonly, source.target.labeledElementDeclarations);
    }
    const reversed = createObjectType(ObjectFlags.ReverseMapped | ObjectFlags.Anonymous, undefined) as ReverseMappedType;
    reversed.source = source;
    reversed.mappedType = target;
    reversed.constraintType = constraint;
    return reversed;
  }
  function getTypeOfReverseMappedSymbol(symbol: ReverseMappedSymbol) {
    return inferReverseMappedType(symbol.propertyType, symbol.mappedType, symbol.constraintType);
  }
  function inferReverseMappedType(sourceType: Type, target: MappedType, constraint: IndexType): Type {
    const typeParameter = <TypeParameter>getIndexedAccessType(constraint.type, getTypeParameterFromMappedType(target));
    const templateType = getTemplateTypeFromMappedType(target);
    const inference = createInferenceInfo(typeParameter);
    inferTypes([inference], sourceType, templateType);
    return getTypeFromInference(inference) || unknownType;
  }
  function* getUnmatchedProperties(source: Type, target: Type, requireOptionalProperties: boolean, matchDiscriminantProperties: boolean): IterableIterator<Symbol> {
    const properties = getPropertiesOfType(target);
    for (const targetProp of properties) {
      if (isStaticPrivateIdentifierProperty(targetProp)) continue;
      if (requireOptionalProperties || !(targetProp.flags & SymbolFlags.Optional || getCheckFlags(targetProp) & CheckFlags.Partial)) {
        const sourceProp = getPropertyOfType(source, targetProp.escName);
        if (!sourceProp) yield targetProp;
        else if (matchDiscriminantProperties) {
          const targetType = getTypeOfSymbol(targetProp);
          if (targetType.flags & TypeFlags.Unit) {
            const sourceType = getTypeOfSymbol(sourceProp);
            if (!(sourceType.flags & TypeFlags.Any || getRegularTypeOfLiteralType(sourceType) === getRegularTypeOfLiteralType(targetType))) yield targetProp;
          }
        }
      }
    }
  }
  function getUnmatchedProperty(source: Type, target: Type, requireOptionalProperties: boolean, matchDiscriminantProperties: boolean): Symbol | undefined {
    const result = getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties).next();
    if (!result.done) return result.value;
  }
  function tupleTypesDefinitelyUnrelated(source: TupleTypeReference, target: TupleTypeReference) {
    return target.target.minLength > source.target.minLength || (!getRestTypeOfTupleType(target) && (!!getRestTypeOfTupleType(source) || getLengthOfTupleType(target) < getLengthOfTupleType(source)));
  }
  function typesDefinitelyUnrelated(source: Type, target: Type) {
    return (
      (isTupleType(source) && isTupleType(target) && tupleTypesDefinitelyUnrelated(source, target)) || (!!getUnmatchedProperty(source, target, true) && !!getUnmatchedProperty(target, source, true))
    );
  }
  function getTypeFromInference(inference: InferenceInfo) {
    return inference.candidates ? getUnionType(inference.candidates, UnionReduction.Subtype) : inference.contraCandidates ? getIntersectionType(inference.contraCandidates) : undefined;
  }
  function hasSkipDirectInferenceFlag(node: Node) {
    return !!getNodeLinks(node).skipDirectInference;
  }
  function isFromInferenceBlockedSource(type: Type) {
    return !!(type.symbol && some(type.symbol.declarations, hasSkipDirectInferenceFlag));
  }
  function inferTypes(inferences: InferenceInfo[], originalSource: Type, originalTarget: Type, priority: InferencePriority = 0, contravariant = false) {
    let symbolOrTypeStack: (Symbol | Type)[];
    let visited: qb.QMap<number>;
    let bivariant = false;
    let propagationType: Type;
    let inferencePriority = InferencePriority.MaxValue;
    let allowComplexConstraintInference = true;
    inferFromTypes(originalSource, originalTarget);
    function inferFromTypes(source: Type, target: Type): void {
      if (!couldContainTypeVariables(target)) return;
      if (source === wildcardType) {
        const savePropagationType = propagationType;
        propagationType = source;
        inferFromTypes(target, target);
        propagationType = savePropagationType;
        return;
      }
      if (source.aliasSymbol && source.aliasTypeArguments && source.aliasSymbol === target.aliasSymbol) {
        inferFromTypeArguments(source.aliasTypeArguments, target.aliasTypeArguments!, getAliasVariances(source.aliasSymbol));
        return;
      }
      if (source === target && source.flags & TypeFlags.UnionOrIntersection) {
        for (const t of (<UnionOrIntersectionType>source).types) {
          inferFromTypes(t, t);
        }
        return;
      }
      if (target.flags & TypeFlags.Union) {
        const [tempSources, tempTargets] = inferFromMatchingTypes(source.flags & TypeFlags.Union ? (<UnionType>source).types : [source], (<UnionType>target).types, isTypeOrBaseIdenticalTo);
        const [sources, targets] = inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy);
        if (targets.length === 0) return;
        target = getUnionType(targets);
        if (sources.length === 0) {
          inferWithPriority(source, target, InferencePriority.NakedTypeVariable);
          return;
        }
        source = getUnionType(sources);
      } else if (
        target.flags & TypeFlags.Intersection &&
        some((<IntersectionType>target).types, (t) => !!getInferenceInfoForType(t) || (isGenericMappedType(t) && !!getInferenceInfoForType(getHomomorphicTypeVariable(t) || neverType)))
      ) {
        if (!(source.flags & TypeFlags.Union)) {
          const [sources, targets] = inferFromMatchingTypes(source.flags & TypeFlags.Intersection ? (<IntersectionType>source).types : [source], (<IntersectionType>target).types, isTypeIdenticalTo);
          if (sources.length === 0 || targets.length === 0) return;
          source = getIntersectionType(sources);
          target = getIntersectionType(targets);
        }
      } else if (target.flags & (TypeFlags.IndexedAccess | TypeFlags.Substitution)) {
        target = getActualTypeVariable(target);
      }
      if (target.flags & TypeFlags.TypeVariable) {
        if (
          getObjectFlags(source) & ObjectFlags.NonInferrableType ||
          source === nonInferrableAnyType ||
          source === silentNeverType ||
          (priority & InferencePriority.ReturnType && (source === autoType || source === autoArrayType)) ||
          isFromInferenceBlockedSource(source)
        ) {
          return;
        }
        const inference = getInferenceInfoForType(target);
        if (inference) {
          if (!inference.isFixed) {
            if (inference.priority === undefined || priority < inference.priority) {
              inference.candidates = undefined;
              inference.contraCandidates = undefined;
              inference.topLevel = true;
              inference.priority = priority;
            }
            if (priority === inference.priority) {
              const candidate = propagationType || source;
              if (contravariant && !bivariant) {
                if (!contains(inference.contraCandidates, candidate)) {
                  inference.contraCandidates = append(inference.contraCandidates, candidate);
                  clearCachedInferences(inferences);
                }
              } else if (!contains(inference.candidates, candidate)) {
                inference.candidates = append(inference.candidates, candidate);
                clearCachedInferences(inferences);
              }
            }
            if (!(priority & InferencePriority.ReturnType) && target.flags & TypeFlags.TypeParameter && inference.topLevel && !isTypeParameterAtTopLevel(originalTarget, <TypeParameter>target)) {
              inference.topLevel = false;
              clearCachedInferences(inferences);
            }
          }
          inferencePriority = Math.min(inferencePriority, priority);
          return;
        } else {
          const simplified = getSimplifiedType(target, false);
          if (simplified !== target) invokeOnce(source, simplified, inferFromTypes);
          else if (target.flags & TypeFlags.IndexedAccess) {
            const indexType = getSimplifiedType((target as IndexedAccessType).indexType, false);
            if (indexType.flags & TypeFlags.Instantiable) {
              const simplified = distributeIndexOverObjectType(getSimplifiedType((target as IndexedAccessType).objectType, false), indexType, false);
              if (simplified && simplified !== target) invokeOnce(source, simplified, inferFromTypes);
            }
          }
        }
      }
      if (
        getObjectFlags(source) & ObjectFlags.Reference &&
        getObjectFlags(target) & ObjectFlags.Reference &&
        ((<TypeReference>source).target === (<TypeReference>target).target || (isArrayType(source) && isArrayType(target))) &&
        !((<TypeReference>source).node && (<TypeReference>target).node)
      ) {
        inferFromTypeArguments(getTypeArguments(<TypeReference>source), getTypeArguments(<TypeReference>target), getVariances((<TypeReference>source).target));
      } else if (source.flags & TypeFlags.Index && target.flags & TypeFlags.Index) {
        contravariant = !contravariant;
        inferFromTypes((<IndexType>source).type, (<IndexType>target).type);
        contravariant = !contravariant;
      } else if ((isLiteralType(source) || source.flags & TypeFlags.String) && target.flags & TypeFlags.Index) {
        const empty = createEmptyObjectTypeFromStringLiteral(source);
        contravariant = !contravariant;
        inferWithPriority(empty, (target as IndexType).type, InferencePriority.LiteralKeyof);
        contravariant = !contravariant;
      } else if (source.flags & TypeFlags.IndexedAccess && target.flags & TypeFlags.IndexedAccess) {
        inferFromTypes((<IndexedAccessType>source).objectType, (<IndexedAccessType>target).objectType);
        inferFromTypes((<IndexedAccessType>source).indexType, (<IndexedAccessType>target).indexType);
      } else if (source.flags & TypeFlags.Conditional && target.flags & TypeFlags.Conditional) {
        inferFromTypes((<ConditionalType>source).checkType, (<ConditionalType>target).checkType);
        inferFromTypes((<ConditionalType>source).extendsType, (<ConditionalType>target).extendsType);
        inferFromTypes(getTrueTypeFromConditionalType(<ConditionalType>source), getTrueTypeFromConditionalType(<ConditionalType>target));
        inferFromTypes(getFalseTypeFromConditionalType(<ConditionalType>source), getFalseTypeFromConditionalType(<ConditionalType>target));
      } else if (target.flags & TypeFlags.Conditional) {
        const savePriority = priority;
        priority |= contravariant ? InferencePriority.ContravariantConditional : 0;
        const targetTypes = [getTrueTypeFromConditionalType(<ConditionalType>target), getFalseTypeFromConditionalType(<ConditionalType>target)];
        inferToMultipleTypes(source, targetTypes, target.flags);
        priority = savePriority;
      } else if (target.flags & TypeFlags.UnionOrIntersection) {
        inferToMultipleTypes(source, (<UnionOrIntersectionType>target).types, target.flags);
      } else if (source.flags & TypeFlags.Union) {
        const sourceTypes = (<UnionOrIntersectionType>source).types;
        for (const sourceType of sourceTypes) {
          inferFromTypes(sourceType, target);
        }
      } else {
        source = getReducedType(source);
        if (!(priority & InferencePriority.NoConstraints && source.flags & (TypeFlags.Intersection | TypeFlags.Instantiable))) {
          const apparentSource = getApparentType(source);
          if (apparentSource !== source && allowComplexConstraintInference && !(apparentSource.flags & (TypeFlags.Object | TypeFlags.Intersection))) {
            allowComplexConstraintInference = false;
            return inferFromTypes(apparentSource, target);
          }
          source = apparentSource;
        }
        if (source.flags & (TypeFlags.Object | TypeFlags.Intersection)) invokeOnce(source, target, inferFromObjectTypes);
      }
      if (source.flags & TypeFlags.Simplifiable) {
        const simplified = getSimplifiedType(source, contravariant);
        if (simplified !== source) inferFromTypes(simplified, target);
      }
    }
    function inferWithPriority(source: Type, target: Type, newPriority: InferencePriority) {
      const savePriority = priority;
      priority |= newPriority;
      inferFromTypes(source, target);
      priority = savePriority;
    }
    function invokeOnce(source: Type, target: Type, action: (source: Type, target: Type) => void) {
      const key = source.id + ',' + target.id;
      const status = visited && visited.get(key);
      if (status !== undefined) {
        inferencePriority = Math.min(inferencePriority, status);
        return;
      }
      (visited || (visited = new qb.QMap<number>())).set(key, InferencePriority.Circularity);
      const saveInferencePriority = inferencePriority;
      inferencePriority = InferencePriority.MaxValue;
      action(source, target);
      visited.set(key, inferencePriority);
      inferencePriority = Math.min(inferencePriority, saveInferencePriority);
    }
    function inferFromMatchingTypes(sources: Type[], targets: Type[], matches: (s: Type, t: Type) => boolean): [Type[], Type[]] {
      let matchedSources: Type[] | undefined;
      let matchedTargets: Type[] | undefined;
      for (const t of targets) {
        for (const s of sources) {
          if (matches(s, t)) {
            inferFromTypes(s, t);
            matchedSources = appendIfUnique(matchedSources, s);
            matchedTargets = appendIfUnique(matchedTargets, t);
          }
        }
      }
      return [matchedSources ? filter(sources, (t) => !contains(matchedSources, t)) : sources, matchedTargets ? filter(targets, (t) => !contains(matchedTargets, t)) : targets];
    }
    function inferFromTypeArguments(sourceTypes: readonly Type[], targetTypes: readonly Type[], variances: readonly VarianceFlags[]) {
      const count = sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length;
      for (let i = 0; i < count; i++) {
        if (i < variances.length && (variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Contravariant) inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);
        else {
          inferFromTypes(sourceTypes[i], targetTypes[i]);
        }
      }
    }
    function inferFromContravariantTypes(source: Type, target: Type) {
      if (strictFunctionTypes || priority & InferencePriority.AlwaysStrict) {
        contravariant = !contravariant;
        inferFromTypes(source, target);
        contravariant = !contravariant;
      } else {
        inferFromTypes(source, target);
      }
    }
    function getInferenceInfoForType(type: Type) {
      if (type.flags & TypeFlags.TypeVariable) {
        for (const inference of inferences) {
          if (type === inference.typeParameter) return inference;
        }
      }
      return;
    }
    function getSingleTypeVariableFromIntersectionTypes(types: Type[]) {
      let typeVariable: Type | undefined;
      for (const type of types) {
        const t = type.flags & TypeFlags.Intersection && find((<IntersectionType>type).types, (t) => !!getInferenceInfoForType(t));
        if (!t || (typeVariable && t !== typeVariable)) return;
        typeVariable = t;
      }
      return typeVariable;
    }
    function inferToMultipleTypes(source: Type, targets: Type[], targetFlags: TypeFlags) {
      let typeVariableCount = 0;
      if (targetFlags & TypeFlags.Union) {
        let nakedTypeVariable: Type | undefined;
        const sources = source.flags & TypeFlags.Union ? (<UnionType>source).types : [source];
        const matched = new Array<boolean>(sources.length);
        let inferenceCircularity = false;
        for (const t of targets) {
          if (getInferenceInfoForType(t)) {
            nakedTypeVariable = t;
            typeVariableCount++;
          } else {
            for (let i = 0; i < sources.length; i++) {
              const saveInferencePriority = inferencePriority;
              inferencePriority = InferencePriority.MaxValue;
              inferFromTypes(sources[i], t);
              if (inferencePriority === priority) matched[i] = true;
              inferenceCircularity = inferenceCircularity || inferencePriority === InferencePriority.Circularity;
              inferencePriority = Math.min(inferencePriority, saveInferencePriority);
            }
          }
        }
        if (typeVariableCount === 0) {
          const intersectionTypeVariable = getSingleTypeVariableFromIntersectionTypes(targets);
          if (intersectionTypeVariable) inferWithPriority(source, intersectionTypeVariable, InferencePriority.NakedTypeVariable);
          return;
        }
        if (typeVariableCount === 1 && !inferenceCircularity) {
          const unmatched = flatMap(sources, (s, i) => (matched[i] ? undefined : s));
          if (unmatched.length) {
            inferFromTypes(getUnionType(unmatched), nakedTypeVariable!);
            return;
          }
        }
      } else {
        for (const t of targets) {
          if (getInferenceInfoForType(t)) typeVariableCount++;
          else {
            inferFromTypes(source, t);
          }
        }
      }
      if (targetFlags & TypeFlags.Intersection ? typeVariableCount === 1 : typeVariableCount > 0) {
        for (const t of targets) {
          if (getInferenceInfoForType(t)) inferWithPriority(source, t, InferencePriority.NakedTypeVariable);
        }
      }
    }
    function inferToMappedType(source: Type, target: MappedType, constraintType: Type): boolean {
      if (constraintType.flags & TypeFlags.Union) {
        let result = false;
        for (const type of (constraintType as UnionType).types) {
          result = inferToMappedType(source, target, type) || result;
        }
        return result;
      }
      if (constraintType.flags & TypeFlags.Index) {
        const inference = getInferenceInfoForType((<IndexType>constraintType).type);
        if (inference && !inference.isFixed && !isFromInferenceBlockedSource(source)) {
          const inferredType = inferTypeForHomomorphicMappedType(source, target, <IndexType>constraintType);
          if (inferredType) {
            inferWithPriority(
              inferredType,
              inference.typeParameter,
              getObjectFlags(source) & ObjectFlags.NonInferrableType ? InferencePriority.PartialHomomorphicMappedType : InferencePriority.HomomorphicMappedType
            );
          }
        }
        return true;
      }
      if (constraintType.flags & TypeFlags.TypeParameter) {
        inferWithPriority(getIndexType(source), constraintType, InferencePriority.MappedTypeConstraint);
        const extendedConstraint = getConstraintOfType(constraintType);
        if (extendedConstraint && inferToMappedType(source, target, extendedConstraint)) return true;
        const propTypes = map(getPropertiesOfType(source), getTypeOfSymbol);
        const stringIndexType = getIndexTypeOfType(source, IndexKind.String);
        const numberIndexInfo = getNonEnumNumberIndexInfo(source);
        const numberIndexType = numberIndexInfo && numberIndexInfo.type;
        inferFromTypes(getUnionType(append(append(propTypes, stringIndexType), numberIndexType)), getTemplateTypeFromMappedType(target));
        return true;
      }
      return false;
    }
    function inferFromObjectTypes(source: Type, target: Type) {
      const isNonConstructorObject = target.flags & TypeFlags.Object && !(getObjectFlags(target) & ObjectFlags.Anonymous && target.symbol && target.symbol.flags & SymbolFlags.Class);
      const symbolOrType = isNonConstructorObject ? (isTupleType(target) ? target.target : target.symbol) : undefined;
      if (symbolOrType) {
        if (contains(symbolOrTypeStack, symbolOrType)) {
          inferencePriority = InferencePriority.Circularity;
          return;
        }
        (symbolOrTypeStack || (symbolOrTypeStack = [])).push(symbolOrType);
        inferFromObjectTypesWorker(source, target);
        symbolOrTypeStack.pop();
      } else {
        inferFromObjectTypesWorker(source, target);
      }
    }
    function inferFromObjectTypesWorker(source: Type, target: Type) {
      if (
        getObjectFlags(source) & ObjectFlags.Reference &&
        getObjectFlags(target) & ObjectFlags.Reference &&
        ((<TypeReference>source).target === (<TypeReference>target).target || (isArrayType(source) && isArrayType(target)))
      ) {
        inferFromTypeArguments(getTypeArguments(<TypeReference>source), getTypeArguments(<TypeReference>target), getVariances((<TypeReference>source).target));
        return;
      }
      if (isGenericMappedType(source) && isGenericMappedType(target)) {
        inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target));
        inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target));
      }
      if (getObjectFlags(target) & ObjectFlags.Mapped) {
        const constraintType = getConstraintTypeFromMappedType(<MappedType>target);
        if (inferToMappedType(source, <MappedType>target, constraintType)) return;
      }
      if (!typesDefinitelyUnrelated(source, target)) {
        if (isArrayType(source) || isTupleType(source)) {
          if (isTupleType(target)) {
            const sourceLength = isTupleType(source) ? getLengthOfTupleType(source) : 0;
            const targetLength = getLengthOfTupleType(target);
            const sourceRestType = isTupleType(source) ? getRestTypeOfTupleType(source) : getElementTypeOfArrayType(source);
            const targetRestType = getRestTypeOfTupleType(target);
            const fixedLength = targetLength < sourceLength || sourceRestType ? targetLength : sourceLength;
            for (let i = 0; i < fixedLength; i++) {
              inferFromTypes(i < sourceLength ? getTypeArguments(<TypeReference>source)[i] : sourceRestType!, getTypeArguments(target)[i]);
            }
            if (targetRestType) {
              const types = fixedLength < sourceLength ? getTypeArguments(<TypeReference>source).slice(fixedLength, sourceLength) : [];
              if (sourceRestType) types.push(sourceRestType);
              if (types.length) inferFromTypes(getUnionType(types), targetRestType);
            }
            return;
          }
          if (isArrayType(target)) {
            inferFromIndexTypes(source, target);
            return;
          }
        }
        inferFromProperties(source, target);
        inferFromSignatures(source, target, SignatureKind.Call);
        inferFromSignatures(source, target, SignatureKind.Construct);
        inferFromIndexTypes(source, target);
      }
    }
    function inferFromProperties(source: Type, target: Type) {
      const properties = getPropertiesOfObjectType(target);
      for (const targetProp of properties) {
        const sourceProp = getPropertyOfType(source, targetProp.escName);
        if (sourceProp) inferFromTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
      }
    }
    function inferFromSignatures(source: Type, target: Type, kind: SignatureKind) {
      const sourceSignatures = getSignaturesOfType(source, kind);
      const targetSignatures = getSignaturesOfType(target, kind);
      const sourceLen = sourceSignatures.length;
      const targetLen = targetSignatures.length;
      const len = sourceLen < targetLen ? sourceLen : targetLen;
      const skipParameters = !!(getObjectFlags(source) & ObjectFlags.NonInferrableType);
      for (let i = 0; i < len; i++) {
        inferFromSignature(getBaseSignature(sourceSignatures[sourceLen - len + i]), getErasedSignature(targetSignatures[targetLen - len + i]), skipParameters);
      }
    }
    function inferFromSignature(source: Signature, target: Signature, skipParameters: boolean) {
      if (!skipParameters) {
        const saveBivariant = bivariant;
        const kind = target.declaration ? target.declaration.kind : Syntax.Unknown;
        bivariant = bivariant || kind === Syntax.MethodDeclaration || kind === Syntax.MethodSignature || kind === Syntax.Constructor;
        applyToParameterTypes(source, target, inferFromContravariantTypes);
        bivariant = saveBivariant;
      }
      applyToReturnTypes(source, target, inferFromTypes);
    }
    function inferFromIndexTypes(source: Type, target: Type) {
      const targetStringIndexType = getIndexTypeOfType(target, IndexKind.String);
      if (targetStringIndexType) {
        const sourceIndexType = getIndexTypeOfType(source, IndexKind.String) || getImplicitIndexTypeOfType(source, IndexKind.String);
        if (sourceIndexType) inferFromTypes(sourceIndexType, targetStringIndexType);
      }
      const targetNumberIndexType = getIndexTypeOfType(target, IndexKind.Number);
      if (targetNumberIndexType) {
        const sourceIndexType = getIndexTypeOfType(source, IndexKind.Number) || getIndexTypeOfType(source, IndexKind.String) || getImplicitIndexTypeOfType(source, IndexKind.Number);
        if (sourceIndexType) inferFromTypes(sourceIndexType, targetNumberIndexType);
      }
    }
  }
  function isTypeOrBaseIdenticalTo(s: Type, t: Type) {
    return isTypeIdenticalTo(s, t) || !!((t.flags & TypeFlags.String && s.flags & TypeFlags.StringLiteral) || (t.flags & TypeFlags.Number && s.flags & TypeFlags.NumberLiteral));
  }
  function isTypeCloselyMatchedBy(s: Type, t: Type) {
    return !!((s.flags & TypeFlags.Object && t.flags & TypeFlags.Object && s.symbol && s.symbol === t.symbol) || (s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol === t.aliasSymbol));
  }
  function hasPrimitiveConstraint(type: TypeParameter): boolean {
    const constraint = getConstraintOfTypeParameter(type);
    return (
      !!constraint &&
      maybeTypeOfKind(constraint.flags & TypeFlags.Conditional ? getDefaultConstraintOfConditionalType(constraint as ConditionalType) : constraint, TypeFlags.Primitive | TypeFlags.Index)
    );
  }
  function isObjectLiteralType(type: Type) {
    return !!(getObjectFlags(type) & ObjectFlags.ObjectLiteral);
  }
  function isObjectOrArrayLiteralType(type: Type) {
    return !!(getObjectFlags(type) & (ObjectFlags.ObjectLiteral | ObjectFlags.ArrayLiteral));
  }
  function unionObjectAndArrayLiteralCandidates(candidates: Type[]): Type[] {
    if (candidates.length > 1) {
      const objectLiterals = filter(candidates, isObjectOrArrayLiteralType);
      if (objectLiterals.length) {
        const literalsType = getUnionType(objectLiterals, UnionReduction.Subtype);
        return concatenate(
          filter(candidates, (t) => !isObjectOrArrayLiteralType(t)),
          [literalsType]
        );
      }
    }
    return candidates;
  }
  function getContravariantInference(inference: InferenceInfo) {
    return inference.priority! & InferencePriority.PriorityImpliesCombination ? getIntersectionType(inference.contraCandidates!) : getCommonSubtype(inference.contraCandidates!);
  }
  function getCovariantInference(inference: InferenceInfo, signature: Signature) {
    const candidates = unionObjectAndArrayLiteralCandidates(inference.candidates!);
    const primitiveConstraint = hasPrimitiveConstraint(inference.typeParameter);
    const widenLiteralTypes = !primitiveConstraint && inference.topLevel && (inference.isFixed || !isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), inference.typeParameter));
    const baseCandidates = primitiveConstraint ? sameMap(candidates, getRegularTypeOfLiteralType) : widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) : candidates;
    const unwidenedType = inference.priority! & InferencePriority.PriorityImpliesCombination ? getUnionType(baseCandidates, UnionReduction.Subtype) : getCommonSupertype(baseCandidates);
    return getWidenedType(unwidenedType);
  }
  function getInferredType(context: InferenceContext, index: number): Type {
    const inference = context.inferences[index];
    if (!inference.inferredType) {
      let inferredType: Type | undefined;
      const signature = context.signature;
      if (signature) {
        const inferredCovariantType = inference.candidates ? getCovariantInference(inference, signature) : undefined;
        if (inference.contraCandidates) {
          const inferredContravariantType = getContravariantInference(inference);
          inferredType =
            inferredCovariantType && !(inferredCovariantType.flags & TypeFlags.Never) && isTypeSubtypeOf(inferredCovariantType, inferredContravariantType)
              ? inferredCovariantType
              : inferredContravariantType;
        } else if (inferredCovariantType) {
          inferredType = inferredCovariantType;
        } else if (context.flags & InferenceFlags.NoDefault) {
          inferredType = silentNeverType;
        } else {
          const defaultType = getDefaultFromTypeParameter(inference.typeParameter);
          if (defaultType) inferredType = instantiateType(defaultType, mergeTypeMappers(createBackreferenceMapper(context, index), context.nonFixingMapper));
        }
      } else {
        inferredType = getTypeFromInference(inference);
      }
      inference.inferredType = inferredType || getDefaultTypeArgumentType(!!(context.flags & InferenceFlags.AnyDefault));
      const constraint = getConstraintOfTypeParameter(inference.typeParameter);
      if (constraint) {
        const instantiatedConstraint = instantiateType(constraint, context.nonFixingMapper);
        if (!inferredType || !context.compareTypes(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType))) inference.inferredType = inferredType = instantiatedConstraint;
      }
    }
    return inference.inferredType;
  }
  function getDefaultTypeArgumentType(isInJavaScriptFile: boolean): Type {
    return isInJavaScriptFile ? anyType : unknownType;
  }
  function getInferredTypes(context: InferenceContext): Type[] {
    const result: Type[] = [];
    for (let i = 0; i < context.inferences.length; i++) {
      result.push(getInferredType(context, i));
    }
    return result;
  }
  function getCannotFindNameDiagnosticForName(node: Identifier): DiagnosticMessage {
    switch (node.escapedText) {
      case 'document':
      case 'console':
        return qd.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom;
      case '$':
        return compilerOptions.types
          ? qd.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig
          : qd.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_types_Slashjquery;
      case 'describe':
      case 'suite':
      case 'it':
      case 'test':
        return compilerOptions.types
          ? qd.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_types_Slashjest_or_npm_i_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig
          : qd.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_types_Slashjest_or_npm_i_types_Slashmocha;
      case 'process':
      case 'require':
      case 'Buffer':
      case 'module':
        return compilerOptions.types
          ? qd.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig
          : qd.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_types_Slashnode;
      case 'Map':
      case 'Set':
      case 'Promise':
      case 'Symbol':
      case 'WeakMap':
      case 'WeakSet':
      case 'Iterator':
      case 'AsyncIterator':
        return qd.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later;
      default:
        if (node.parent.kind === Syntax.ShorthandPropertyAssignment) return qd.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer;
        return qd.Cannot_find_name_0;
    }
  }
  function getResolvedSymbol(node: Identifier): Symbol {
    const links = getNodeLinks(node);
    if (!links.resolvedSymbol) {
      links.resolvedSymbol =
        (!qc.is.missing(node) &&
          resolveName(
            node,
            node.escapedText,
            SymbolFlags.Value | SymbolFlags.ExportValue,
            getCannotFindNameDiagnosticForName(node),
            node,
            !isWriteOnlyAccess(node),
            false,
            qd.Cannot_find_name_0_Did_you_mean_1
          )) ||
        unknownSymbol;
    }
    return links.resolvedSymbol;
  }
  function isInTypeQuery(node: Node): boolean {
    return !!Node.findAncestor(node, (n) => (n.kind === Syntax.TypeQuery ? true : n.kind === Syntax.Identifier || n.kind === Syntax.QualifiedName ? false : 'quit'));
  }
  function getFlowCacheKey(node: Node, declaredType: Type, initialType: Type, flowContainer: Node | undefined): string | undefined {
    switch (node.kind) {
      case Syntax.Identifier:
        const symbol = getResolvedSymbol(<Identifier>node);
        return symbol !== unknownSymbol
          ? `${flowContainer ? getNodeId(flowContainer) : '-1'}|${getTypeId(declaredType)}|${getTypeId(initialType)}|${isConstraintPosition(node) ? '@' : ''}${symbol.getId()}`
          : undefined;
      case Syntax.ThisKeyword:
        return '0';
      case Syntax.NonNullExpression:
      case Syntax.ParenthesizedExpression:
        return getFlowCacheKey((<NonNullExpression | ParenthesizedExpression>node).expression, declaredType, initialType, flowContainer);
      case Syntax.PropertyAccessExpression:
      case Syntax.ElementAccessExpression:
        const propName = getAccessedPropertyName(<AccessExpression>node);
        if (propName !== undefined) {
          const key = getFlowCacheKey((<AccessExpression>node).expression, declaredType, initialType, flowContainer);
          return key && key + '.' + propName;
        }
    }
    return;
  }
  function isMatchingReference(source: Node, target: Node): boolean {
    switch (target.kind) {
      case Syntax.ParenthesizedExpression:
      case Syntax.NonNullExpression:
        return isMatchingReference(source, (target as NonNullExpression | ParenthesizedExpression).expression);
    }
    switch (source.kind) {
      case Syntax.Identifier:
        return (
          (target.kind === Syntax.Identifier && getResolvedSymbol(<Identifier>source) === getResolvedSymbol(<Identifier>target)) ||
          ((target.kind === Syntax.VariableDeclaration || target.kind === Syntax.BindingElement) &&
            getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(<Identifier>source)) === getSymbolOfNode(target))
        );
      case Syntax.ThisKeyword:
        return target.kind === Syntax.ThisKeyword;
      case Syntax.SuperKeyword:
        return target.kind === Syntax.SuperKeyword;
      case Syntax.NonNullExpression:
      case Syntax.ParenthesizedExpression:
        return isMatchingReference((source as NonNullExpression | ParenthesizedExpression).expression, target);
      case Syntax.PropertyAccessExpression:
      case Syntax.ElementAccessExpression:
        return (
          isAccessExpression(target) &&
          getAccessedPropertyName(<AccessExpression>source) === getAccessedPropertyName(target) &&
          isMatchingReference((<AccessExpression>source).expression, target.expression)
        );
    }
    return false;
  }
  function containsTruthyCheck(source: Node, target: Node): boolean {
    return (
      isMatchingReference(source, target) ||
      (target.kind === Syntax.BinaryExpression &&
        (<BinaryExpression>target).operatorToken.kind === Syntax.Ampersand2Token &&
        (containsTruthyCheck(source, (<BinaryExpression>target).left) || containsTruthyCheck(source, (<BinaryExpression>target).right)))
    );
  }
  function getAccessedPropertyName(access: AccessExpression): __String | undefined {
    return access.kind === Syntax.PropertyAccessExpression
      ? access.name.escapedText
      : StringLiteral.orNumericLiteralLike(access.argumentExpression)
      ? syntax.get.escUnderscores(access.argumentExpression.text)
      : undefined;
  }
  function containsMatchingReference(source: Node, target: Node) {
    while (isAccessExpression(source)) {
      source = source.expression;
      if (isMatchingReference(source, target)) return true;
    }
    return false;
  }
  function optionalChainContainsReference(source: Node, target: Node) {
    while (qc.is.optionalChain(source)) {
      source = source.expression;
      if (isMatchingReference(source, target)) return true;
    }
    return false;
  }
  function isDiscriminantProperty(type: Type | undefined, name: __String) {
    if (type && type.flags & TypeFlags.Union) {
      const prop = getUnionOrIntersectionProperty(<UnionType>type, name);
      if (prop && getCheckFlags(prop) & CheckFlags.SyntheticProperty) {
        if ((<TransientSymbol>prop).isDiscriminantProperty === undefined) {
          (<TransientSymbol>prop).isDiscriminantProperty =
            ((<TransientSymbol>prop).checkFlags & CheckFlags.Discriminant) === CheckFlags.Discriminant && !maybeTypeOfKind(getTypeOfSymbol(prop), TypeFlags.Instantiable);
        }
        return !!(<TransientSymbol>prop).isDiscriminantProperty;
      }
    }
    return false;
  }
  function findDiscriminantProperties(sourceProperties: Symbol[], target: Type): Symbol[] | undefined {
    let result: Symbol[] | undefined;
    for (const sourceProperty of sourceProperties) {
      if (isDiscriminantProperty(target, sourceProperty.escName)) {
        if (result) {
          result.push(sourceProperty);
          continue;
        }
        result = [sourceProperty];
      }
    }
    return result;
  }
  function isOrContainsMatchingReference(source: Node, target: Node) {
    return isMatchingReference(source, target) || containsMatchingReference(source, target);
  }
  function hasMatchingArgument(callExpression: CallExpression, reference: Node) {
    if (callExpression.arguments) {
      for (const argument of callExpression.arguments) {
        if (isOrContainsMatchingReference(reference, argument)) return true;
      }
    }
    if (callExpression.expression.kind === Syntax.PropertyAccessExpression && isOrContainsMatchingReference(reference, (<PropertyAccessExpression>callExpression.expression).expression)) return true;
    return false;
  }
  function getFlowNodeId(flow: FlowNode): number {
    if (!flow.id || flow.id < 0) {
      flow.id = nextFlowId;
      nextFlowId++;
    }
    return flow.id;
  }
  function typeMaybeAssignableTo(source: Type, target: Type) {
    if (!(source.flags & TypeFlags.Union)) return isTypeAssignableTo(source, target);
    for (const t of (<UnionType>source).types) {
      if (isTypeAssignableTo(t, target)) return true;
    }
    return false;
  }
  function getAssignmentReducedType(declaredType: UnionType, assignedType: Type) {
    if (declaredType !== assignedType) {
      if (assignedType.flags & TypeFlags.Never) return assignedType;
      let reducedType = filterType(declaredType, (t) => typeMaybeAssignableTo(assignedType, t));
      if (assignedType.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(assignedType)) reducedType = mapType(reducedType, getFreshTypeOfLiteralType);
      if (isTypeAssignableTo(assignedType, reducedType)) return reducedType;
    }
    return declaredType;
  }
  function getTypeFactsOfTypes(types: Type[]): TypeFacts {
    let result: TypeFacts = TypeFacts.None;
    for (const t of types) {
      result |= getTypeFacts(t);
    }
    return result;
  }
  function isFunctionObjectType(type: ObjectType): boolean {
    const resolved = resolveStructuredTypeMembers(type);
    return !!(resolved.callSignatures.length || resolved.constructSignatures.length || (resolved.members.get('bind' as __String) && isTypeSubtypeOf(type, globalFunctionType)));
  }
  function getTypeFacts(type: Type): TypeFacts {
    const flags = type.flags;
    if (flags & TypeFlags.String) return strictNullChecks ? TypeFacts.StringStrictFacts : TypeFacts.StringFacts;
    if (flags & TypeFlags.StringLiteral) {
      const isEmpty = (<StringLiteralType>type).value === '';
      return strictNullChecks ? (isEmpty ? TypeFacts.EmptyStringStrictFacts : TypeFacts.NonEmptyStringStrictFacts) : isEmpty ? TypeFacts.EmptyStringFacts : TypeFacts.NonEmptyStringFacts;
    }
    if (flags & (TypeFlags.Number | TypeFlags.Enum)) return strictNullChecks ? TypeFacts.NumberStrictFacts : TypeFacts.NumberFacts;
    if (flags & TypeFlags.NumberLiteral) {
      const isZero = (<NumberLiteralType>type).value === 0;
      return strictNullChecks ? (isZero ? TypeFacts.ZeroNumberStrictFacts : TypeFacts.NonZeroNumberStrictFacts) : isZero ? TypeFacts.ZeroNumberFacts : TypeFacts.NonZeroNumberFacts;
    }
    if (flags & TypeFlags.BigInt) return strictNullChecks ? TypeFacts.BigIntStrictFacts : TypeFacts.BigIntFacts;
    if (flags & TypeFlags.BigIntLiteral) {
      const isZero = isZeroBigInt(<BigIntLiteralType>type);
      return strictNullChecks ? (isZero ? TypeFacts.ZeroBigIntStrictFacts : TypeFacts.NonZeroBigIntStrictFacts) : isZero ? TypeFacts.ZeroBigIntFacts : TypeFacts.NonZeroBigIntFacts;
    }
    if (flags & TypeFlags.Boolean) return strictNullChecks ? TypeFacts.BooleanStrictFacts : TypeFacts.BooleanFacts;
    if (flags & TypeFlags.BooleanLike) {
      return strictNullChecks
        ? type === falseType || type === regularFalseType
          ? TypeFacts.FalseStrictFacts
          : TypeFacts.TrueStrictFacts
        : type === falseType || type === regularFalseType
        ? TypeFacts.FalseFacts
        : TypeFacts.TrueFacts;
    }
    if (flags & TypeFlags.Object) {
      return getObjectFlags(type) & ObjectFlags.Anonymous && isEmptyObjectType(<ObjectType>type)
        ? strictNullChecks
          ? TypeFacts.EmptyObjectStrictFacts
          : TypeFacts.EmptyObjectFacts
        : isFunctionObjectType(<ObjectType>type)
        ? strictNullChecks
          ? TypeFacts.FunctionStrictFacts
          : TypeFacts.FunctionFacts
        : strictNullChecks
        ? TypeFacts.ObjectStrictFacts
        : TypeFacts.ObjectFacts;
    }
    if (flags & (TypeFlags.Void | TypeFlags.Undefined)) return TypeFacts.UndefinedFacts;
    if (flags & TypeFlags.Null) return TypeFacts.NullFacts;
    if (flags & TypeFlags.ESSymbolLike) return strictNullChecks ? TypeFacts.SymbolStrictFacts : TypeFacts.SymbolFacts;
    if (flags & TypeFlags.NonPrimitive) return strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts;
    if (flags & TypeFlags.Never) return TypeFacts.None;
    if (flags & TypeFlags.Instantiable) return getTypeFacts(getBaseConstraintOfType(type) || unknownType);
    if (flags & TypeFlags.UnionOrIntersection) return getTypeFactsOfTypes((<UnionOrIntersectionType>type).types);
    return TypeFacts.All;
  }
  function getTypeWithFacts(type: Type, include: TypeFacts) {
    return filterType(type, (t) => (getTypeFacts(t) & include) !== 0);
  }
  function getTypeWithDefault(type: Type, defaultExpression: Expression) {
    if (defaultExpression) {
      const defaultType = getTypeOfExpression(defaultExpression);
      return getUnionType([getTypeWithFacts(type, TypeFacts.NEUndefined), defaultType]);
    }
    return type;
  }
  function getTypeOfDestructuredProperty(type: Type, name: PropertyName) {
    const nameType = getLiteralTypeFromPropertyName(name);
    if (!isTypeUsableAsPropertyName(nameType)) return errorType;
    const text = getPropertyNameFromType(nameType);
    return (
      getConstraintForLocation(getTypeOfPropertyOfType(type, text), name) ||
      (NumericLiteral.name(text) && getIndexTypeOfType(type, IndexKind.Number)) ||
      getIndexTypeOfType(type, IndexKind.String) ||
      errorType
    );
  }
  function getTypeOfDestructuredArrayElement(type: Type, index: number) {
    return (everyType(type, isTupleLikeType) && getTupleElementType(type, index)) || checkIteratedTypeOrElementType(IterationUse.Destructuring, type, undefinedType, undefined) || errorType;
  }
  function getTypeOfDestructuredSpreadExpression(type: Type) {
    return createArrayType(checkIteratedTypeOrElementType(IterationUse.Destructuring, type, undefinedType, undefined) || errorType);
  }
  function getAssignedTypeOfBinaryExpression(node: BinaryExpression): Type {
    const isDestructuringDefaultAssignment =
      (node.parent.kind === Syntax.ArrayLiteralExpression && isDestructuringAssignmentTarget(node.parent)) ||
      (node.parent.kind === Syntax.PropertyAssignment && isDestructuringAssignmentTarget(node.parent.parent));
    return isDestructuringDefaultAssignment ? getTypeWithDefault(getAssignedType(node), node.right) : getTypeOfExpression(node.right);
  }
  function isDestructuringAssignmentTarget(parent: Node) {
    return (
      (parent.parent.kind === Syntax.BinaryExpression && (parent.parent as BinaryExpression).left === parent) ||
      (parent.parent.kind === Syntax.ForOfStatement && (parent.parent as ForOfStatement).initializer === parent)
    );
  }
  function getAssignedTypeOfArrayLiteralElement(node: ArrayLiteralExpression, element: Expression): Type {
    return getTypeOfDestructuredArrayElement(getAssignedType(node), node.elements.indexOf(element));
  }
  function getAssignedTypeOfSpreadExpression(node: SpreadElement): Type {
    return getTypeOfDestructuredSpreadExpression(getAssignedType(<ArrayLiteralExpression>node.parent));
  }
  function getAssignedTypeOfPropertyAssignment(node: PropertyAssignment | ShorthandPropertyAssignment): Type {
    return getTypeOfDestructuredProperty(getAssignedType(node.parent), node.name);
  }
  function getAssignedTypeOfShorthandPropertyAssignment(node: ShorthandPropertyAssignment): Type {
    return getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node), node.objectAssignmentInitializer!);
  }
  function getAssignedType(node: Expression): Type {
    const { parent } = node;
    switch (parent.kind) {
      case Syntax.ForInStatement:
        return stringType;
      case Syntax.ForOfStatement:
        return checkRightHandSideOfForOf(<ForOfStatement>parent) || errorType;
      case Syntax.BinaryExpression:
        return getAssignedTypeOfBinaryExpression(<BinaryExpression>parent);
      case Syntax.DeleteExpression:
        return undefinedType;
      case Syntax.ArrayLiteralExpression:
        return getAssignedTypeOfArrayLiteralElement(<ArrayLiteralExpression>parent, node);
      case Syntax.SpreadElement:
        return getAssignedTypeOfSpreadExpression(<SpreadElement>parent);
      case Syntax.PropertyAssignment:
        return getAssignedTypeOfPropertyAssignment(<PropertyAssignment>parent);
      case Syntax.ShorthandPropertyAssignment:
        return getAssignedTypeOfShorthandPropertyAssignment(<ShorthandPropertyAssignment>parent);
    }
    return errorType;
  }
  function getInitialTypeOfBindingElement(node: BindingElement): Type {
    const pattern = node.parent;
    const parentType = getInitialType(<VariableDeclaration | BindingElement>pattern.parent);
    const type =
      pattern.kind === Syntax.ObjectBindingPattern
        ? getTypeOfDestructuredProperty(parentType, node.propertyName || <Identifier>node.name)
        : !node.dot3Token
        ? getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node))
        : getTypeOfDestructuredSpreadExpression(parentType);
    return getTypeWithDefault(type, node.initializer!);
  }
  function getTypeOfInitializer(node: Expression) {
    const links = getNodeLinks(node);
    return links.resolvedType || getTypeOfExpression(node);
  }
  function getInitialTypeOfVariableDeclaration(node: VariableDeclaration) {
    if (node.initializer) return getTypeOfInitializer(node.initializer);
    if (node.parent.parent.kind === Syntax.ForInStatement) return stringType;
    if (node.parent.parent.kind === Syntax.ForOfStatement) return checkRightHandSideOfForOf(node.parent.parent) || errorType;
    return errorType;
  }
  function getInitialType(node: VariableDeclaration | BindingElement) {
    return node.kind === Syntax.VariableDeclaration ? getInitialTypeOfVariableDeclaration(node) : getInitialTypeOfBindingElement(node);
  }
  function isEmptyArrayAssignment(node: VariableDeclaration | BindingElement | Expression) {
    return (
      (node.kind === Syntax.VariableDeclaration && (<VariableDeclaration>node).initializer && isEmptyArrayLiteral((<VariableDeclaration>node).initializer!)) ||
      (node.kind !== Syntax.BindingElement && node.parent.kind === Syntax.BinaryExpression && isEmptyArrayLiteral((<BinaryExpression>node.parent).right))
    );
  }
  function getReferenceCandidate(node: Expression): Expression {
    switch (node.kind) {
      case Syntax.ParenthesizedExpression:
        return getReferenceCandidate((<ParenthesizedExpression>node).expression);
      case Syntax.BinaryExpression:
        switch ((<BinaryExpression>node).operatorToken.kind) {
          case Syntax.EqualsToken:
            return getReferenceCandidate((<BinaryExpression>node).left);
          case Syntax.CommaToken:
            return getReferenceCandidate((<BinaryExpression>node).right);
        }
    }
    return node;
  }
  function getReferenceRoot(node: Node): Node {
    const { parent } = node;
    return parent.kind === Syntax.ParenthesizedExpression ||
      (parent.kind === Syntax.BinaryExpression && (<BinaryExpression>parent).operatorToken.kind === Syntax.EqualsToken && (<BinaryExpression>parent).left === node) ||
      (parent.kind === Syntax.BinaryExpression && (<BinaryExpression>parent).operatorToken.kind === Syntax.CommaToken && (<BinaryExpression>parent).right === node)
      ? getReferenceRoot(parent)
      : node;
  }
  function getTypeOfSwitchClause(clause: CaseClause | DefaultClause) {
    if (clause.kind === Syntax.CaseClause) return getRegularTypeOfLiteralType(getTypeOfExpression(clause.expression));
    return neverType;
  }
  function getSwitchClauseTypes(switchStatement: SwitchStatement): Type[] {
    const links = getNodeLinks(switchStatement);
    if (!links.switchTypes) {
      links.switchTypes = [];
      for (const clause of switchStatement.caseBlock.clauses) {
        links.switchTypes.push(getTypeOfSwitchClause(clause));
      }
    }
    return links.switchTypes;
  }
  function getSwitchClauseTypeOfWitnesses(switchStatement: SwitchStatement, retainDefault: false): string[];
  function getSwitchClauseTypeOfWitnesses(switchStatement: SwitchStatement, retainDefault: boolean): (string | undefined)[];
  function getSwitchClauseTypeOfWitnesses(switchStatement: SwitchStatement, retainDefault: boolean): (string | undefined)[] {
    const witnesses: (string | undefined)[] = [];
    for (const clause of switchStatement.caseBlock.clauses) {
      if (clause.kind === Syntax.CaseClause) {
        if (StringLiteral.like(clause.expression)) {
          witnesses.push(clause.expression.text);
          continue;
        }
        return empty;
      }
      if (retainDefault) witnesses.push(undefined);
    }
    return witnesses;
  }
  function eachTypeContainedIn(source: Type, types: Type[]) {
    return source.flags & TypeFlags.Union ? !forEach((<UnionType>source).types, (t) => !contains(types, t)) : contains(types, source);
  }
  function isTypeSubsetOf(source: Type, target: Type) {
    return source === target || (target.flags & TypeFlags.Union && isTypeSubsetOfUnion(source, <UnionType>target));
  }
  function isTypeSubsetOfUnion(source: Type, target: UnionType) {
    if (source.flags & TypeFlags.Union) {
      for (const t of (<UnionType>source).types) {
        if (!containsType(target.types, t)) return false;
      }
      return true;
    }
    if (source.flags & TypeFlags.EnumLiteral && getBaseTypeOfEnumLiteralType(<LiteralType>source) === target) return true;
    return containsType(target.types, source);
  }
  function forEachType<T>(type: Type, f: (t: Type) => T | undefined): T | undefined {
    return type.flags & TypeFlags.Union ? forEach((<UnionType>type).types, f) : f(type);
  }
  function everyType(type: Type, f: (t: Type) => boolean): boolean {
    return type.flags & TypeFlags.Union ? every((<UnionType>type).types, f) : f(type);
  }
  function filterType(type: Type, f: (t: Type) => boolean): Type {
    if (type.flags & TypeFlags.Union) {
      const types = (<UnionType>type).types;
      const filtered = filter(types, f);
      return filtered === types ? type : getUnionTypeFromSortedList(filtered, (<UnionType>type).objectFlags);
    }
    return type.flags & TypeFlags.Never || f(type) ? type : neverType;
  }
  function countTypes(type: Type) {
    return type.flags & TypeFlags.Union ? (type as UnionType).types.length : 1;
  }
  function mapType(type: Type, mapper: (t: Type) => Type, noReductions?: boolean): Type;
  function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined;
  function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined {
    if (type.flags & TypeFlags.Never) return type;
    if (!(type.flags & TypeFlags.Union)) return mapper(type);
    let mappedTypes: Type[] | undefined;
    for (const t of (<UnionType>type).types) {
      const mapped = mapper(t);
      if (mapped) {
        if (!mappedTypes) mappedTypes = [mapped];
        else {
          mappedTypes.push(mapped);
        }
      }
    }
    return mappedTypes && getUnionType(mappedTypes, noReductions ? UnionReduction.None : UnionReduction.Literal);
  }
  function extractTypesOfKind(type: Type, kind: TypeFlags) {
    return filterType(type, (t) => (t.flags & kind) !== 0);
  }
  function replacePrimitivesWithLiterals(typeWithPrimitives: Type, typeWithLiterals: Type) {
    if (
      (isTypeSubsetOf(stringType, typeWithPrimitives) && maybeTypeOfKind(typeWithLiterals, TypeFlags.StringLiteral)) ||
      (isTypeSubsetOf(numberType, typeWithPrimitives) && maybeTypeOfKind(typeWithLiterals, TypeFlags.NumberLiteral)) ||
      (isTypeSubsetOf(bigintType, typeWithPrimitives) && maybeTypeOfKind(typeWithLiterals, TypeFlags.BigIntLiteral))
    ) {
      return mapType(typeWithPrimitives, (t) =>
        t.flags & TypeFlags.String
          ? extractTypesOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.StringLiteral)
          : t.flags & TypeFlags.Number
          ? extractTypesOfKind(typeWithLiterals, TypeFlags.Number | TypeFlags.NumberLiteral)
          : t.flags & TypeFlags.BigInt
          ? extractTypesOfKind(typeWithLiterals, TypeFlags.BigInt | TypeFlags.BigIntLiteral)
          : t
      );
    }
    return typeWithPrimitives;
  }
  function isIncomplete(flowType: FlowType) {
    return flowType.flags === 0;
  }
  function getTypeFromFlowType(flowType: FlowType) {
    return flowType.flags === 0 ? (<IncompleteType>flowType).type : <Type>flowType;
  }
  function createFlowType(type: Type, incomplete: boolean): FlowType {
    return incomplete ? { flags: 0, type } : type;
  }
  function createEvolvingArrayType(elementType: Type): EvolvingArrayType {
    const result = <EvolvingArrayType>createObjectType(ObjectFlags.EvolvingArray);
    result.elementType = elementType;
    return result;
  }
  function getEvolvingArrayType(elementType: Type): EvolvingArrayType {
    return evolvingArrayTypes[elementType.id] || (evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType));
  }
  function addEvolvingArrayElementType(evolvingArrayType: EvolvingArrayType, node: Expression): EvolvingArrayType {
    const elementType = getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node));
    return isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(getUnionType([evolvingArrayType.elementType, elementType]));
  }
  function createFinalArrayType(elementType: Type) {
    return elementType.flags & TypeFlags.Never
      ? autoArrayType
      : createArrayType(elementType.flags & TypeFlags.Union ? getUnionType((<UnionType>elementType).types, UnionReduction.Subtype) : elementType);
  }
  function getFinalArrayType(evolvingArrayType: EvolvingArrayType): Type {
    return evolvingArrayType.finalArrayType || (evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType));
  }
  function finalizeEvolvingArrayType(type: Type): Type {
    return getObjectFlags(type) & ObjectFlags.EvolvingArray ? getFinalArrayType(<EvolvingArrayType>type) : type;
  }
  function getElementTypeOfEvolvingArrayType(type: Type) {
    return getObjectFlags(type) & ObjectFlags.EvolvingArray ? (<EvolvingArrayType>type).elementType : neverType;
  }
  function isEvolvingArrayTypeList(types: Type[]) {
    let hasEvolvingArrayType = false;
    for (const t of types) {
      if (!(t.flags & TypeFlags.Never)) {
        if (!(getObjectFlags(t) & ObjectFlags.EvolvingArray)) return false;
        hasEvolvingArrayType = true;
      }
    }
    return hasEvolvingArrayType;
  }
  function getUnionOrEvolvingArrayType(types: Type[], subtypeReduction: UnionReduction) {
    return isEvolvingArrayTypeList(types)
      ? getEvolvingArrayType(getUnionType(map(types, getElementTypeOfEvolvingArrayType)))
      : getUnionType(sameMap(types, finalizeEvolvingArrayType), subtypeReduction);
  }
  function isEvolvingArrayOperationTarget(node: Node) {
    const root = getReferenceRoot(node);
    const parent = root.parent;
    const isLengthPushOrUnshift =
      qc.is.kind(PropertyAccessExpression, parent) &&
      (parent.name.escapedText === 'length' || (parent.parent.kind === Syntax.CallExpression && qc.is.kind(Identifier, parent.name) && isPushOrUnshiftIdentifier(parent.name)));
    const isElementAssignment =
      parent.kind === Syntax.ElementAccessExpression &&
      (<ElementAccessExpression>parent).expression === root &&
      parent.parent.kind === Syntax.BinaryExpression &&
      (<BinaryExpression>parent.parent).operatorToken.kind === Syntax.EqualsToken &&
      (<BinaryExpression>parent.parent).left === parent &&
      !isAssignmentTarget(parent.parent) &&
      isTypeAssignableToKind(getTypeOfExpression((<ElementAccessExpression>parent).argumentExpression), TypeFlags.NumberLike);
    return isLengthPushOrUnshift || isElementAssignment;
  }
  function isDeclarationWithExplicitTypeAnnotation(declaration: Declaration) {
    return (
      (declaration.kind === Syntax.VariableDeclaration || declaration.kind === Syntax.Parameter || declaration.kind === Syntax.PropertyDeclaration || declaration.kind === Syntax.PropertySignature) &&
      !!getEffectiveTypeAnnotationNode(declaration as VariableDeclaration | ParameterDeclaration | PropertyDeclaration | PropertySignature)
    );
  }
  function getExplicitTypeOfSymbol(symbol: Symbol, diagnostic?: Diagnostic) {
    if (symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.ValueModule)) return this.getTypeOfSymbol();
    if (symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property)) {
      const declaration = symbol.valueDeclaration;
      if (declaration) {
        if (isDeclarationWithExplicitTypeAnnotation(declaration)) return this.getTypeOfSymbol();
        if (qc.is.kind(VariableDeclaration, declaration) && declaration.parent.parent.kind === Syntax.ForOfStatement) {
          const statement = declaration.parent.parent;
          const expressionType = getTypeOfDottedName(statement.expression, undefined);
          if (expressionType) {
            const use = statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf;
            return checkIteratedTypeOrElementType(use, expressionType, undefinedType, undefined);
          }
        }
        if (diagnostic) addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, qd._0_needs_an_explicit_type_annotation, symbol.symbolToString()));
      }
    }
  }
  function getTypeOfDottedName(node: Expression, diagnostic: Diagnostic | undefined): Type | undefined {
    if (!(node.flags & NodeFlags.InWithStatement)) {
      switch (node.kind) {
        case Syntax.Identifier:
          const symbol = getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(<Identifier>node));
          return getExplicitTypeOfSymbol(symbol.flags & SymbolFlags.Alias ? this.resolveAlias() : symbol, diagnostic);
        case Syntax.ThisKeyword:
          return getExplicitThisType(node);
        case Syntax.SuperKeyword:
          return checkSuperExpression(node);
        case Syntax.PropertyAccessExpression:
          const type = getTypeOfDottedName((<PropertyAccessExpression>node).expression, diagnostic);
          const prop = type && getPropertyOfType(type, (<PropertyAccessExpression>node).name.escapedText);
          return prop && getExplicitTypeOfSymbol(prop, diagnostic);
        case Syntax.ParenthesizedExpression:
          return getTypeOfDottedName((<ParenthesizedExpression>node).expression, diagnostic);
      }
    }
  }
  function getEffectsSignature(node: CallExpression) {
    const links = getNodeLinks(node);
    let signature = links.effectsSignature;
    if (signature === undefined) {
      let funcType: Type | undefined;
      if (node.parent.kind === Syntax.ExpressionStatement) funcType = getTypeOfDottedName(node.expression, undefined);
      else if (node.expression.kind !== Syntax.SuperKeyword) {
        if (qc.is.optionalChain(node)) funcType = checkNonNullType(getOptionalExpressionType(checkExpression(node.expression), node.expression), node.expression);
        else {
          funcType = checkNonNullExpression(node.expression);
        }
      }
      const signatures = getSignaturesOfType((funcType && getApparentType(funcType)) || unknownType, SignatureKind.Call);
      const candidate = signatures.length === 1 && !signatures[0].typeParameters ? signatures[0] : some(signatures, hasTypePredicateOrNeverReturnType) ? getResolvedSignature(node) : undefined;
      signature = links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature;
    }
    return signature === unknownSignature ? undefined : signature;
  }
  function hasTypePredicateOrNeverReturnType(signature: Signature) {
    return !!(getTypePredicateOfSignature(signature) || (signature.declaration && (getReturnTypeFromAnnotation(signature.declaration) || unknownType).flags & TypeFlags.Never));
  }
  function getTypePredicateArgument(predicate: TypePredicate, callExpression: CallExpression) {
    if (predicate.kind === TypePredicateKind.Identifier || predicate.kind === TypePredicateKind.AssertsIdentifier) return callExpression.arguments[predicate.parameterIndex];
    const invokedExpression = skipParentheses(callExpression.expression);
    return isAccessExpression(invokedExpression) ? skipParentheses(invokedExpression.expression) : undefined;
  }
  function reportFlowControlError(node: Node) {
    const block = <Block | ModuleBlock | SourceFile>Node.findAncestor(node, isFunctionOrModuleBlock);
    const sourceFile = qc.get.sourceFileOf(node);
    const span = getSpanOfTokenAtPosition(sourceFile, block.statements.pos);
    diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, qd.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis));
  }
  function isReachableFlowNode(flow: FlowNode) {
    const result = isReachableFlowNodeWorker(flow, false);
    lastFlowNode = flow;
    lastFlowNodeReachable = result;
    return result;
  }
  function isFalseExpression(expr: Expression): boolean {
    const node = skipParentheses(expr);
    return (
      node.kind === Syntax.FalseKeyword ||
      (node.kind === Syntax.BinaryExpression &&
        (((<BinaryExpression>node).operatorToken.kind === Syntax.Ampersand2Token && (isFalseExpression((<BinaryExpression>node).left) || isFalseExpression((<BinaryExpression>node).right))) ||
          ((<BinaryExpression>node).operatorToken.kind === Syntax.Bar2Token && isFalseExpression((<BinaryExpression>node).left) && isFalseExpression((<BinaryExpression>node).right))))
    );
  }
  function isReachableFlowNodeWorker(flow: FlowNode, noCacheCheck: boolean): boolean {
    while (true) {
      if (flow === lastFlowNode) return lastFlowNodeReachable;
      const flags = flow.flags;
      if (flags & FlowFlags.Shared) {
        if (!noCacheCheck) {
          const id = getFlowNodeId(flow);
          const reachable = flowNodeReachable[id];
          return reachable !== undefined ? reachable : (flowNodeReachable[id] = isReachableFlowNodeWorker(flow, true));
        }
        noCacheCheck = false;
      }
      if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation)) flow = (<FlowAssignment | FlowCondition | FlowArrayMutation>flow).antecedent;
      else if (flags & FlowFlags.Call) {
        const signature = getEffectsSignature((<FlowCall>flow).node);
        if (signature) {
          const predicate = getTypePredicateOfSignature(signature);
          if (predicate && predicate.kind === TypePredicateKind.AssertsIdentifier) {
            const predicateArgument = (<FlowCall>flow).node.arguments[predicate.parameterIndex];
            if (predicateArgument && isFalseExpression(predicateArgument)) return false;
          }
          if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) return false;
        }
        flow = (<FlowCall>flow).antecedent;
      } else if (flags & FlowFlags.BranchLabel) {
        return some((<FlowLabel>flow).antecedents, (f) => isReachableFlowNodeWorker(f, false));
      } else if (flags & FlowFlags.LoopLabel) {
        flow = (<FlowLabel>flow).antecedents![0];
      } else if (flags & FlowFlags.SwitchClause) {
        if ((<FlowSwitchClause>flow).clauseStart === (<FlowSwitchClause>flow).clauseEnd && isExhaustiveSwitchStatement((<FlowSwitchClause>flow).switchStatement)) return false;
        flow = (<FlowSwitchClause>flow).antecedent;
      } else if (flags & FlowFlags.ReduceLabel) {
        lastFlowNode = undefined;
        const target = (<FlowReduceLabel>flow).target;
        const saveAntecedents = target.antecedents;
        target.antecedents = (<FlowReduceLabel>flow).antecedents;
        const result = isReachableFlowNodeWorker((<FlowReduceLabel>flow).antecedent, false);
        target.antecedents = saveAntecedents;
        return result;
      }
      return !(flags & FlowFlags.Unreachable);
    }
  }
  function isPostSuperFlowNode(flow: FlowNode, noCacheCheck: boolean): boolean {
    while (true) {
      const flags = flow.flags;
      if (flags & FlowFlags.Shared) {
        if (!noCacheCheck) {
          const id = getFlowNodeId(flow);
          const postSuper = flowNodePostSuper[id];
          return postSuper !== undefined ? postSuper : (flowNodePostSuper[id] = isPostSuperFlowNode(flow, true));
        }
        noCacheCheck = false;
      }
      if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation | FlowFlags.SwitchClause))
        flow = (<FlowAssignment | FlowCondition | FlowArrayMutation | FlowSwitchClause>flow).antecedent;
      else if (flags & FlowFlags.Call) {
        if ((<FlowCall>flow).node.expression.kind === Syntax.SuperKeyword) return true;
        flow = (<FlowCall>flow).antecedent;
      } else if (flags & FlowFlags.BranchLabel) {
        return every((<FlowLabel>flow).antecedents, (f) => isPostSuperFlowNode(f, false));
      } else if (flags & FlowFlags.LoopLabel) {
        flow = (<FlowLabel>flow).antecedents![0];
      } else if (flags & FlowFlags.ReduceLabel) {
        const target = (<FlowReduceLabel>flow).target;
        const saveAntecedents = target.antecedents;
        target.antecedents = (<FlowReduceLabel>flow).antecedents;
        const result = isPostSuperFlowNode((<FlowReduceLabel>flow).antecedent, false);
        target.antecedents = saveAntecedents;
        return result;
      }
      return !!(flags & FlowFlags.Unreachable);
    }
  }
  function getFlowTypeOfReference(reference: Node, declaredType: Type, initialType = declaredType, flowContainer?: Node, couldBeUninitialized?: boolean) {
    let key: string | undefined;
    let keySet = false;
    let flowDepth = 0;
    if (flowAnalysisDisabled) return errorType;
    if (!reference.flowNode || (!couldBeUninitialized && !(declaredType.flags & TypeFlags.Narrowable))) return declaredType;
    flowInvocationCount++;
    const sharedFlowStart = sharedFlowCount;
    const evolvedType = getTypeFromFlowType(getTypeAtFlowNode(reference.flowNode));
    sharedFlowCount = sharedFlowStart;
    const resultType = getObjectFlags(evolvedType) & ObjectFlags.EvolvingArray && isEvolvingArrayOperationTarget(reference) ? autoArrayType : finalizeEvolvingArrayType(evolvedType);
    if (
      resultType === unreachableNeverType ||
      (reference.parent && reference.parent.kind === Syntax.NonNullExpression && getTypeWithFacts(resultType, TypeFacts.NEUndefinedOrNull).flags & TypeFlags.Never)
    ) {
      return declaredType;
    }
    return resultType;
    function getOrSetCacheKey() {
      if (keySet) return key;
      keySet = true;
      return (key = getFlowCacheKey(reference, declaredType, initialType, flowContainer));
    }
    function getTypeAtFlowNode(flow: FlowNode): FlowType {
      if (flowDepth === 2000) {
        flowAnalysisDisabled = true;
        reportFlowControlError(reference);
        return errorType;
      }
      flowDepth++;
      while (true) {
        const flags = flow.flags;
        if (flags & FlowFlags.Shared) {
          for (let i = sharedFlowStart; i < sharedFlowCount; i++) {
            if (sharedFlowNodes[i] === flow) {
              flowDepth--;
              return sharedFlowTypes[i];
            }
          }
        }
        let type: FlowType | undefined;
        if (flags & FlowFlags.Assignment) {
          type = getTypeAtFlowAssignment(<FlowAssignment>flow);
          if (!type) {
            flow = (<FlowAssignment>flow).antecedent;
            continue;
          }
        } else if (flags & FlowFlags.Call) {
          type = getTypeAtFlowCall(<FlowCall>flow);
          if (!type) {
            flow = (<FlowCall>flow).antecedent;
            continue;
          }
        } else if (flags & FlowFlags.Condition) {
          type = getTypeAtFlowCondition(<FlowCondition>flow);
        } else if (flags & FlowFlags.SwitchClause) {
          type = getTypeAtSwitchClause(<FlowSwitchClause>flow);
        } else if (flags & FlowFlags.Label) {
          if ((<FlowLabel>flow).antecedents!.length === 1) {
            flow = (<FlowLabel>flow).antecedents![0];
            continue;
          }
          type = flags & FlowFlags.BranchLabel ? getTypeAtFlowBranchLabel(<FlowLabel>flow) : getTypeAtFlowLoopLabel(<FlowLabel>flow);
        } else if (flags & FlowFlags.ArrayMutation) {
          type = getTypeAtFlowArrayMutation(<FlowArrayMutation>flow);
          if (!type) {
            flow = (<FlowArrayMutation>flow).antecedent;
            continue;
          }
        } else if (flags & FlowFlags.ReduceLabel) {
          const target = (<FlowReduceLabel>flow).target;
          const saveAntecedents = target.antecedents;
          target.antecedents = (<FlowReduceLabel>flow).antecedents;
          type = getTypeAtFlowNode((<FlowReduceLabel>flow).antecedent);
          target.antecedents = saveAntecedents;
        } else if (flags & FlowFlags.Start) {
          const container = (<FlowStart>flow).node;
          if (
            container &&
            container !== flowContainer &&
            reference.kind !== Syntax.PropertyAccessExpression &&
            reference.kind !== Syntax.ElementAccessExpression &&
            reference.kind !== Syntax.ThisKeyword
          ) {
            flow = container.flowNode!;
            continue;
          }
          type = initialType;
        } else {
          type = convertAutoToAny(declaredType);
        }
        if (flags & FlowFlags.Shared) {
          sharedFlowNodes[sharedFlowCount] = flow;
          sharedFlowTypes[sharedFlowCount] = type;
          sharedFlowCount++;
        }
        flowDepth--;
        return type;
      }
    }
    function getInitialOrAssignedType(flow: FlowAssignment) {
      const node = flow.node;
      return getConstraintForLocation(
        node.kind === Syntax.VariableDeclaration || node.kind === Syntax.BindingElement ? getInitialType(<VariableDeclaration | BindingElement>node) : getAssignedType(node),
        reference
      );
    }
    function getTypeAtFlowAssignment(flow: FlowAssignment) {
      const node = flow.node;
      if (isMatchingReference(reference, node)) {
        if (!isReachableFlowNode(flow)) return unreachableNeverType;
        if (getAssignmentTargetKind(node) === AssignmentKind.Compound) {
          const flowType = getTypeAtFlowNode(flow.antecedent);
          return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType));
        }
        if (declaredType === autoType || declaredType === autoArrayType) {
          if (isEmptyArrayAssignment(node)) return getEvolvingArrayType(neverType);
          const assignedType = getWidenedLiteralType(getInitialOrAssignedType(flow));
          return isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType;
        }
        if (declaredType.flags & TypeFlags.Union) return getAssignmentReducedType(<UnionType>declaredType, getInitialOrAssignedType(flow));
        return declaredType;
      }
      if (containsMatchingReference(reference, node)) {
        if (!isReachableFlowNode(flow)) return unreachableNeverType;
        if (qc.is.kind(VariableDeclaration, node) && (isInJSFile(node) || isVarConst(node))) {
          const init = getDeclaredExpandoInitializer(node);
          if (init && (init.kind === Syntax.FunctionExpression || init.kind === Syntax.ArrowFunction)) return getTypeAtFlowNode(flow.antecedent);
        }
        return declaredType;
      }
      if (qc.is.kind(VariableDeclaration, node) && node.parent.parent.kind === Syntax.ForInStatement && isMatchingReference(reference, node.parent.parent.expression))
        return getNonNullableTypeIfNeeded(getTypeFromFlowType(getTypeAtFlowNode(flow.antecedent)));
      return;
    }
    function narrowTypeByAssertion(type: Type, expr: Expression): Type {
      const node = skipParentheses(expr);
      if (node.kind === Syntax.FalseKeyword) return unreachableNeverType;
      if (node.kind === Syntax.BinaryExpression) {
        if ((<BinaryExpression>node).operatorToken.kind === Syntax.Ampersand2Token)
          return narrowTypeByAssertion(narrowTypeByAssertion(type, (<BinaryExpression>node).left), (<BinaryExpression>node).right);
        if ((<BinaryExpression>node).operatorToken.kind === Syntax.Bar2Token)
          return getUnionType([narrowTypeByAssertion(type, (<BinaryExpression>node).left), narrowTypeByAssertion(type, (<BinaryExpression>node).right)]);
      }
      return narrowType(type, node, true);
    }
    function getTypeAtFlowCall(flow: FlowCall): FlowType | undefined {
      const signature = getEffectsSignature(flow.node);
      if (signature) {
        const predicate = getTypePredicateOfSignature(signature);
        if (predicate && (predicate.kind === TypePredicateKind.AssertsThis || predicate.kind === TypePredicateKind.AssertsIdentifier)) {
          const flowType = getTypeAtFlowNode(flow.antecedent);
          const type = finalizeEvolvingArrayType(getTypeFromFlowType(flowType));
          const narrowedType = predicate.type
            ? narrowTypeByTypePredicate(type, predicate, flow.node, true)
            : predicate.kind === TypePredicateKind.AssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length
            ? narrowTypeByAssertion(type, flow.node.arguments[predicate.parameterIndex])
            : type;
          return narrowedType === type ? flowType : createFlowType(narrowedType, isIncomplete(flowType));
        }
        if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) return unreachableNeverType;
      }
      return;
    }
    function getTypeAtFlowArrayMutation(flow: FlowArrayMutation): FlowType | undefined {
      if (declaredType === autoType || declaredType === autoArrayType) {
        const node = flow.node;
        const expr = node.kind === Syntax.CallExpression ? (<PropertyAccessExpression>node.expression).expression : (<ElementAccessExpression>node.left).expression;
        if (isMatchingReference(reference, getReferenceCandidate(expr))) {
          const flowType = getTypeAtFlowNode(flow.antecedent);
          const type = getTypeFromFlowType(flowType);
          if (getObjectFlags(type) & ObjectFlags.EvolvingArray) {
            let evolvedType = <EvolvingArrayType>type;
            if (node.kind === Syntax.CallExpression) {
              for (const arg of node.arguments) {
                evolvedType = addEvolvingArrayElementType(evolvedType, arg);
              }
            } else {
              const indexType = getContextFreeTypeOfExpression((<ElementAccessExpression>node.left).argumentExpression);
              if (isTypeAssignableToKind(indexType, TypeFlags.NumberLike)) evolvedType = addEvolvingArrayElementType(evolvedType, node.right);
            }
            return evolvedType === type ? flowType : createFlowType(evolvedType, isIncomplete(flowType));
          }
          return flowType;
        }
      }
      return;
    }
    function getTypeAtFlowCondition(flow: FlowCondition): FlowType {
      const flowType = getTypeAtFlowNode(flow.antecedent);
      const type = getTypeFromFlowType(flowType);
      if (type.flags & TypeFlags.Never) return flowType;
      const assumeTrue = (flow.flags & FlowFlags.TrueCondition) !== 0;
      const nonEvolvingType = finalizeEvolvingArrayType(type);
      const narrowedType = narrowType(nonEvolvingType, flow.node, assumeTrue);
      if (narrowedType === nonEvolvingType) return flowType;
      const incomplete = isIncomplete(flowType);
      const resultType = incomplete && narrowedType.flags & TypeFlags.Never ? silentNeverType : narrowedType;
      return createFlowType(resultType, incomplete);
    }
    function getTypeAtSwitchClause(flow: FlowSwitchClause): FlowType {
      const expr = flow.switchStatement.expression;
      const flowType = getTypeAtFlowNode(flow.antecedent);
      let type = getTypeFromFlowType(flowType);
      if (isMatchingReference(reference, expr)) type = narrowTypeBySwitchOnDiscriminant(type, flow.switchStatement, flow.clauseStart, flow.clauseEnd);
      else if (expr.kind === Syntax.TypeOfExpression && isMatchingReference(reference, (expr as TypeOfExpression).expression)) {
        type = narrowBySwitchOnTypeOf(type, flow.switchStatement, flow.clauseStart, flow.clauseEnd);
      } else {
        if (strictNullChecks) {
          if (optionalChainContainsReference(expr, reference))
            type = narrowTypeBySwitchOptionalChainContainment(type, flow.switchStatement, flow.clauseStart, flow.clauseEnd, (t) => !(t.flags & (TypeFlags.Undefined | TypeFlags.Never)));
          else if (expr.kind === Syntax.TypeOfExpression && optionalChainContainsReference((expr as TypeOfExpression).expression, reference)) {
            type = narrowTypeBySwitchOptionalChainContainment(
              type,
              flow.switchStatement,
              flow.clauseStart,
              flow.clauseEnd,
              (t) => !(t.flags & TypeFlags.Never || (t.flags & TypeFlags.StringLiteral && (<StringLiteralType>t).value === 'undefined'))
            );
          }
        }
        if (isMatchingReferenceDiscriminant(expr, type))
          type = narrowTypeByDiscriminant(type, expr as AccessExpression, (t) => narrowTypeBySwitchOnDiscriminant(t, flow.switchStatement, flow.clauseStart, flow.clauseEnd));
      }
      return createFlowType(type, isIncomplete(flowType));
    }
    function getTypeAtFlowBranchLabel(flow: FlowLabel): FlowType {
      const antecedentTypes: Type[] = [];
      let subtypeReduction = false;
      let seenIncomplete = false;
      let bypassFlow: FlowSwitchClause | undefined;
      for (const antecedent of flow.antecedents!) {
        if (!bypassFlow && antecedent.flags & FlowFlags.SwitchClause && (<FlowSwitchClause>antecedent).clauseStart === (<FlowSwitchClause>antecedent).clauseEnd) {
          bypassFlow = <FlowSwitchClause>antecedent;
          continue;
        }
        const flowType = getTypeAtFlowNode(antecedent);
        const type = getTypeFromFlowType(flowType);
        if (type === declaredType && declaredType === initialType) return type;
        pushIfUnique(antecedentTypes, type);
        if (!isTypeSubsetOf(type, declaredType)) subtypeReduction = true;
        if (isIncomplete(flowType)) seenIncomplete = true;
      }
      if (bypassFlow) {
        const flowType = getTypeAtFlowNode(bypassFlow);
        const type = getTypeFromFlowType(flowType);
        if (!contains(antecedentTypes, type) && !isExhaustiveSwitchStatement(bypassFlow.switchStatement)) {
          if (type === declaredType && declaredType === initialType) return type;
          antecedentTypes.push(type);
          if (!isTypeSubsetOf(type, declaredType)) subtypeReduction = true;
          if (isIncomplete(flowType)) seenIncomplete = true;
        }
      }
      return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal), seenIncomplete);
    }
    function getTypeAtFlowLoopLabel(flow: FlowLabel): FlowType {
      const id = getFlowNodeId(flow);
      const cache = flowLoopCaches[id] || (flowLoopCaches[id] = new qb.QMap<Type>());
      const key = getOrSetCacheKey();
      if (!key) return declaredType;
      const cached = cache.get(key);
      if (cached) return cached;
      for (let i = flowLoopStart; i < flowLoopCount; i++) {
        if (flowLoopNodes[i] === flow && flowLoopKeys[i] === key && flowLoopTypes[i].length) return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], UnionReduction.Literal), true);
      }
      const antecedentTypes: Type[] = [];
      let subtypeReduction = false;
      let firstAntecedentType: FlowType | undefined;
      for (const antecedent of flow.antecedents!) {
        let flowType;
        if (!firstAntecedentType) flowType = firstAntecedentType = getTypeAtFlowNode(antecedent);
        else {
          flowLoopNodes[flowLoopCount] = flow;
          flowLoopKeys[flowLoopCount] = key;
          flowLoopTypes[flowLoopCount] = antecedentTypes;
          flowLoopCount++;
          const saveFlowTypeCache = flowTypeCache;
          flowTypeCache = undefined;
          flowType = getTypeAtFlowNode(antecedent);
          flowTypeCache = saveFlowTypeCache;
          flowLoopCount--;
          const cached = cache.get(key);
          if (cached) return cached;
        }
        const type = getTypeFromFlowType(flowType);
        pushIfUnique(antecedentTypes, type);
        if (!isTypeSubsetOf(type, declaredType)) subtypeReduction = true;
        if (type === declaredType) break;
      }
      const result = getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal);
      if (isIncomplete(firstAntecedentType!)) return createFlowType(result, true);
      cache.set(key, result);
      return result;
    }
    function isMatchingReferenceDiscriminant(expr: Expression, computedType: Type) {
      const type = declaredType.flags & TypeFlags.Union ? declaredType : computedType;
      if (!(type.flags & TypeFlags.Union) || !isAccessExpression(expr)) return false;
      const name = getAccessedPropertyName(expr);
      if (name === undefined) return false;
      return isMatchingReference(reference, expr.expression) && isDiscriminantProperty(type, name);
    }
    function narrowTypeByDiscriminant(type: Type, access: AccessExpression, narrowType: (t: Type) => Type): Type {
      const propName = getAccessedPropertyName(access);
      if (propName === undefined) return type;
      const propType = getTypeOfPropertyOfType(type, propName);
      if (!propType) return type;
      const narrowedPropType = narrowType(propType);
      return filterType(type, (t) => {
        const discriminantType = getTypeOfPropertyOrIndexSignature(t, propName);
        return !(discriminantType.flags & TypeFlags.Never) && isTypeComparableTo(discriminantType, narrowedPropType);
      });
    }
    function narrowTypeByTruthiness(type: Type, expr: Expression, assumeTrue: boolean): Type {
      if (isMatchingReference(reference, expr)) return getTypeWithFacts(type, assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy);
      if (strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference)) type = getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
      if (isMatchingReferenceDiscriminant(expr, type)) return narrowTypeByDiscriminant(type, <AccessExpression>expr, (t) => getTypeWithFacts(t, assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy));
      return type;
    }
    function isTypePresencePossible(type: Type, propName: __String, assumeTrue: boolean) {
      if (getIndexInfoOfType(type, IndexKind.String)) return true;
      const prop = getPropertyOfType(type, propName);
      if (prop) return prop.flags & SymbolFlags.Optional ? true : assumeTrue;
      return !assumeTrue;
    }
    function narrowByInKeyword(type: Type, literal: LiteralExpression, assumeTrue: boolean) {
      if (type.flags & (TypeFlags.Union | TypeFlags.Object) || isThisTypeParameter(type)) {
        const propName = syntax.get.escUnderscores(literal.text);
        return filterType(type, (t) => isTypePresencePossible(t, propName, assumeTrue));
      }
      return type;
    }
    function narrowTypeByBinaryExpression(type: Type, expr: BinaryExpression, assumeTrue: boolean): Type {
      switch (expr.operatorToken.kind) {
        case Syntax.EqualsToken:
          return narrowTypeByTruthiness(narrowType(type, expr.right, assumeTrue), expr.left, assumeTrue);
        case Syntax.Equals2Token:
        case Syntax.ExclamationEqualsToken:
        case Syntax.Equals3Token:
        case Syntax.ExclamationEquals2Token:
          const operator = expr.operatorToken.kind;
          const left = getReferenceCandidate(expr.left);
          const right = getReferenceCandidate(expr.right);
          if (left.kind === Syntax.TypeOfExpression && StringLiteral.like(right)) return narrowTypeByTypeof(type, <TypeOfExpression>left, operator, right, assumeTrue);
          if (right.kind === Syntax.TypeOfExpression && StringLiteral.like(left)) return narrowTypeByTypeof(type, <TypeOfExpression>right, operator, left, assumeTrue);
          if (isMatchingReference(reference, left)) return narrowTypeByEquality(type, operator, right, assumeTrue);
          if (isMatchingReference(reference, right)) return narrowTypeByEquality(type, operator, left, assumeTrue);
          if (strictNullChecks) {
            if (optionalChainContainsReference(left, reference)) type = narrowTypeByOptionalChainContainment(type, operator, right, assumeTrue);
            else if (optionalChainContainsReference(right, reference)) {
              type = narrowTypeByOptionalChainContainment(type, operator, left, assumeTrue);
            }
          }
          if (isMatchingReferenceDiscriminant(left, type)) return narrowTypeByDiscriminant(type, <AccessExpression>left, (t) => narrowTypeByEquality(t, operator, right, assumeTrue));
          if (isMatchingReferenceDiscriminant(right, type)) return narrowTypeByDiscriminant(type, <AccessExpression>right, (t) => narrowTypeByEquality(t, operator, left, assumeTrue));
          if (isMatchingConstructorReference(left)) return narrowTypeByConstructor(type, operator, right, assumeTrue);
          if (isMatchingConstructorReference(right)) return narrowTypeByConstructor(type, operator, left, assumeTrue);
          break;
        case Syntax.InstanceOfKeyword:
          return narrowTypeByInstanceof(type, expr, assumeTrue);
        case Syntax.InKeyword:
          const target = getReferenceCandidate(expr.right);
          if (StringLiteral.like(expr.left) && isMatchingReference(reference, target)) return narrowByInKeyword(type, expr.left, assumeTrue);
          break;
        case Syntax.CommaToken:
          return narrowType(type, expr.right, assumeTrue);
      }
      return type;
    }
    function narrowTypeByOptionalChainContainment(type: Type, operator: Syntax, value: Expression, assumeTrue: boolean): Type {
      const equalsOperator = operator === Syntax.Equals2Token || operator === Syntax.Equals3Token;
      const nullableFlags = operator === Syntax.Equals2Token || operator === Syntax.ExclamationEqualsToken ? TypeFlags.Nullable : TypeFlags.Undefined;
      const valueType = getTypeOfExpression(value);
      const removeNullable =
        (equalsOperator !== assumeTrue && everyType(valueType, (t) => !!(t.flags & nullableFlags))) ||
        (equalsOperator === assumeTrue && everyType(valueType, (t) => !(t.flags & (TypeFlags.AnyOrUnknown | nullableFlags))));
      return removeNullable ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type;
    }
    function narrowTypeByEquality(type: Type, operator: Syntax, value: Expression, assumeTrue: boolean): Type {
      if (type.flags & TypeFlags.Any) return type;
      if (operator === Syntax.ExclamationEqualsToken || operator === Syntax.ExclamationEquals2Token) assumeTrue = !assumeTrue;
      const valueType = getTypeOfExpression(value);
      if (type.flags & TypeFlags.Unknown && assumeTrue && (operator === Syntax.Equals3Token || operator === Syntax.ExclamationEquals2Token)) {
        if (valueType.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) return valueType;
        if (valueType.flags & TypeFlags.Object) return nonPrimitiveType;
        return type;
      }
      if (valueType.flags & TypeFlags.Nullable) {
        if (!strictNullChecks) return type;
        const doubleEquals = operator === Syntax.Equals2Token || operator === Syntax.ExclamationEqualsToken;
        const facts = doubleEquals
          ? assumeTrue
            ? TypeFacts.EQUndefinedOrNull
            : TypeFacts.NEUndefinedOrNull
          : valueType.flags & TypeFlags.Null
          ? assumeTrue
            ? TypeFacts.EQNull
            : TypeFacts.NENull
          : assumeTrue
          ? TypeFacts.EQUndefined
          : TypeFacts.NEUndefined;
        return getTypeWithFacts(type, facts);
      }
      if (type.flags & TypeFlags.NotUnionOrUnit) return type;
      if (assumeTrue) {
        const filterFn: (t: Type) => boolean =
          operator === Syntax.Equals2Token ? (t) => areTypesComparable(t, valueType) || isCoercibleUnderDoubleEquals(t, valueType) : (t) => areTypesComparable(t, valueType);
        const narrowedType = filterType(type, filterFn);
        return narrowedType.flags & TypeFlags.Never ? type : replacePrimitivesWithLiterals(narrowedType, valueType);
      }
      if (isUnitType(valueType)) {
        const regularType = getRegularTypeOfLiteralType(valueType);
        return filterType(type, (t) => (isUnitType(t) ? !areTypesComparable(t, valueType) : getRegularTypeOfLiteralType(t) !== regularType));
      }
      return type;
    }
    function narrowTypeByTypeof(type: Type, typeOfExpr: TypeOfExpression, operator: Syntax, literal: LiteralExpression, assumeTrue: boolean): Type {
      if (operator === Syntax.ExclamationEqualsToken || operator === Syntax.ExclamationEquals2Token) assumeTrue = !assumeTrue;
      const target = getReferenceCandidate(typeOfExpr.expression);
      if (!isMatchingReference(reference, target)) {
        if (strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue === (literal.text !== 'undefined')) return getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
        return type;
      }
      if (type.flags & TypeFlags.Any && literal.text === 'function') return type;
      if (assumeTrue && type.flags & TypeFlags.Unknown && literal.text === 'object') {
        if (typeOfExpr.parent.parent.kind === Syntax.BinaryExpression) {
          const expr = <BinaryExpression>typeOfExpr.parent.parent;
          if (expr.operatorToken.kind === Syntax.Ampersand2Token && expr.right === typeOfExpr.parent && containsTruthyCheck(reference, expr.left)) return nonPrimitiveType;
        }
        return getUnionType([nonPrimitiveType, nullType]);
      }
      const facts = assumeTrue ? typeofEQFacts.get(literal.text) || TypeFacts.TypeofEQHostObject : typeofNEFacts.get(literal.text) || TypeFacts.TypeofNEHostObject;
      const impliedType = getImpliedTypeFromTypeofGuard(type, literal.text);
      return getTypeWithFacts(assumeTrue && impliedType ? mapType(type, narrowUnionMemberByTypeof(impliedType)) : type, facts);
    }
    function narrowTypeBySwitchOptionalChainContainment(type: Type, switchStatement: SwitchStatement, clauseStart: number, clauseEnd: number, clauseCheck: (type: Type) => boolean) {
      const everyClauseChecks = clauseStart !== clauseEnd && every(getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck);
      return everyClauseChecks ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type;
    }
    function narrowTypeBySwitchOnDiscriminant(type: Type, switchStatement: SwitchStatement, clauseStart: number, clauseEnd: number) {
      const switchTypes = getSwitchClauseTypes(switchStatement);
      if (!switchTypes.length) return type;
      const clauseTypes = switchTypes.slice(clauseStart, clauseEnd);
      const hasDefaultClause = clauseStart === clauseEnd || contains(clauseTypes, neverType);
      if (type.flags & TypeFlags.Unknown && !hasDefaultClause) {
        let groundClauseTypes: Type[] | undefined;
        for (let i = 0; i < clauseTypes.length; i += 1) {
          const t = clauseTypes[i];
          if (t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) {
            if (groundClauseTypes !== undefined) groundClauseTypes.push(t);
          } else if (t.flags & TypeFlags.Object) {
            if (groundClauseTypes === undefined) groundClauseTypes = clauseTypes.slice(0, i);
            groundClauseTypes.push(nonPrimitiveType);
          }
          return type;
        }
        return getUnionType(groundClauseTypes === undefined ? clauseTypes : groundClauseTypes);
      }
      const discriminantType = getUnionType(clauseTypes);
      const caseType =
        discriminantType.flags & TypeFlags.Never
          ? neverType
          : replacePrimitivesWithLiterals(
              filterType(type, (t) => areTypesComparable(discriminantType, t)),
              discriminantType
            );
      if (!hasDefaultClause) return caseType;
      const defaultType = filterType(type, (t) => !(isUnitType(t) && contains(switchTypes, getRegularTypeOfLiteralType(t))));
      return caseType.flags & TypeFlags.Never ? defaultType : getUnionType([caseType, defaultType]);
    }
    function getImpliedTypeFromTypeofGuard(type: Type, text: string) {
      switch (text) {
        case 'function':
          return type.flags & TypeFlags.Any ? type : globalFunctionType;
        case 'object':
          return type.flags & TypeFlags.Unknown ? getUnionType([nonPrimitiveType, nullType]) : type;
        default:
          return typeofTypesByName.get(text);
      }
    }
    function narrowUnionMemberByTypeof(candidate: Type) {
      return (type: Type) => {
        if (isTypeSubtypeOf(type, candidate)) return type;
        if (isTypeSubtypeOf(candidate, type)) return candidate;
        if (type.flags & TypeFlags.Instantiable) {
          const constraint = getBaseConstraintOfType(type) || anyType;
          if (isTypeSubtypeOf(candidate, constraint)) return getIntersectionType([type, candidate]);
        }
        return type;
      };
    }
    function narrowBySwitchOnTypeOf(type: Type, switchStatement: SwitchStatement, clauseStart: number, clauseEnd: number): Type {
      const switchWitnesses = getSwitchClauseTypeOfWitnesses(switchStatement, true);
      if (!switchWitnesses.length) return type;
      const defaultCaseLocation = findIndex(switchWitnesses, (elem) => elem === undefined);
      const hasDefaultClause = clauseStart === clauseEnd || (defaultCaseLocation >= clauseStart && defaultCaseLocation < clauseEnd);
      let clauseWitnesses: string[];
      let switchFacts: TypeFacts;
      if (defaultCaseLocation > -1) {
        const witnesses = <string[]>switchWitnesses.filter((witness) => witness !== undefined);
        const fixedClauseStart = defaultCaseLocation < clauseStart ? clauseStart - 1 : clauseStart;
        const fixedClauseEnd = defaultCaseLocation < clauseEnd ? clauseEnd - 1 : clauseEnd;
        clauseWitnesses = witnesses.slice(fixedClauseStart, fixedClauseEnd);
        switchFacts = getFactsFromTypeofSwitch(fixedClauseStart, fixedClauseEnd, witnesses, hasDefaultClause);
      } else {
        clauseWitnesses = <string[]>switchWitnesses.slice(clauseStart, clauseEnd);
        switchFacts = getFactsFromTypeofSwitch(clauseStart, clauseEnd, <string[]>switchWitnesses, hasDefaultClause);
      }
      if (hasDefaultClause) return filterType(type, (t) => (getTypeFacts(t) & switchFacts) === switchFacts);
      const impliedType = getTypeWithFacts(getUnionType(clauseWitnesses.map((text) => getImpliedTypeFromTypeofGuard(type, text) || type)), switchFacts);
      return getTypeWithFacts(mapType(type, narrowUnionMemberByTypeof(impliedType)), switchFacts);
    }
    function isMatchingConstructorReference(expr: Expression) {
      return (
        ((qc.is.kind(PropertyAccessExpression, expr) && idText(expr.name) === 'constructor') ||
          (qc.is.kind(ElementAccessExpression, expr) && StringLiteral.like(expr.argumentExpression) && expr.argumentExpression.text === 'constructor')) &&
        isMatchingReference(reference, expr.expression)
      );
    }
    function narrowTypeByConstructor(type: Type, operator: Syntax, identifier: Expression, assumeTrue: boolean): Type {
      if (assumeTrue ? operator !== Syntax.Equals2Token && operator !== Syntax.Equals3Token : operator !== Syntax.ExclamationEqualsToken && operator !== Syntax.ExclamationEquals2Token) return type;
      const identifierType = getTypeOfExpression(identifier);
      if (!isFunctionType(identifierType) && !isConstructorType(identifierType)) return type;
      const prototypeProperty = getPropertyOfType(identifierType, 'prototype' as __String);
      if (!prototypeProperty) return type;
      const prototypeType = getTypeOfSymbol(prototypeProperty);
      const candidate = !isTypeAny(prototypeType) ? prototypeType : undefined;
      if (!candidate || candidate === globalObjectType || candidate === globalFunctionType) return type;
      if (isTypeAny(type)) return candidate;
      return filterType(type, (t) => isConstructedBy(t, candidate));
      function isConstructedBy(source: Type, target: Type) {
        if ((source.flags & TypeFlags.Object && getObjectFlags(source) & ObjectFlags.Class) || (target.flags & TypeFlags.Object && getObjectFlags(target) & ObjectFlags.Class))
          return source.symbol === target.symbol;
        return isTypeSubtypeOf(source, target);
      }
    }
    function narrowTypeByInstanceof(type: Type, expr: BinaryExpression, assumeTrue: boolean): Type {
      const left = getReferenceCandidate(expr.left);
      if (!isMatchingReference(reference, left)) {
        if (assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference)) return getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
        return type;
      }
      const rightType = getTypeOfExpression(expr.right);
      if (!isTypeDerivedFrom(rightType, globalFunctionType)) return type;
      let targetType: Type | undefined;
      const prototypeProperty = getPropertyOfType(rightType, 'prototype' as __String);
      if (prototypeProperty) {
        const prototypePropertyType = getTypeOfSymbol(prototypeProperty);
        if (!isTypeAny(prototypePropertyType)) targetType = prototypePropertyType;
      }
      if (isTypeAny(type) && (targetType === globalObjectType || targetType === globalFunctionType)) return type;
      if (!targetType) {
        const constructSignatures = getSignaturesOfType(rightType, SignatureKind.Construct);
        targetType = constructSignatures.length ? getUnionType(map(constructSignatures, (signature) => getReturnTypeOfSignature(getErasedSignature(signature)))) : emptyObjectType;
      }
      return getNarrowedType(type, targetType, assumeTrue, isTypeDerivedFrom);
    }
    function getNarrowedType(type: Type, candidate: Type, assumeTrue: boolean, isRelated: (source: Type, target: Type) => boolean) {
      if (!assumeTrue) return filterType(type, (t) => !isRelated(t, candidate));
      if (type.flags & TypeFlags.Union) {
        const assignableType = filterType(type, (t) => isRelated(t, candidate));
        if (!(assignableType.flags & TypeFlags.Never)) return assignableType;
      }
      return isTypeSubtypeOf(candidate, type) ? candidate : isTypeAssignableTo(type, candidate) ? type : isTypeAssignableTo(candidate, type) ? candidate : getIntersectionType([type, candidate]);
    }
    function narrowTypeByCallExpression(type: Type, callExpression: CallExpression, assumeTrue: boolean): Type {
      if (hasMatchingArgument(callExpression, reference)) {
        const signature = assumeTrue || !qc.is.callChain(callExpression) ? getEffectsSignature(callExpression) : undefined;
        const predicate = signature && getTypePredicateOfSignature(signature);
        if (predicate && (predicate.kind === TypePredicateKind.This || predicate.kind === TypePredicateKind.Identifier)) return narrowTypeByTypePredicate(type, predicate, callExpression, assumeTrue);
      }
      return type;
    }
    function narrowTypeByTypePredicate(type: Type, predicate: TypePredicate, callExpression: CallExpression, assumeTrue: boolean): Type {
      if (predicate.type && !(isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType))) {
        const predicateArgument = getTypePredicateArgument(predicate, callExpression);
        if (predicateArgument) {
          if (isMatchingReference(reference, predicateArgument)) return getNarrowedType(type, predicate.type, assumeTrue, isTypeSubtypeOf);
          if (strictNullChecks && assumeTrue && optionalChainContainsReference(predicateArgument, reference) && !(getTypeFacts(predicate.type) & TypeFacts.EQUndefined))
            type = getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull);
          if (isMatchingReferenceDiscriminant(predicateArgument, type))
            return narrowTypeByDiscriminant(type, predicateArgument as AccessExpression, (t) => getNarrowedType(t, predicate.type!, assumeTrue, isTypeSubtypeOf));
        }
      }
      return type;
    }
    function narrowType(type: Type, expr: Expression, assumeTrue: boolean): Type {
      if (qc.is.expressionOfOptionalChainRoot(expr) || (qc.is.kind(BinaryExpression, expr.parent) && expr.parent.operatorToken.kind === Syntax.Question2Token && expr.parent.left === expr))
        return narrowTypeByOptionality(type, expr, assumeTrue);
      switch (expr.kind) {
        case Syntax.Identifier:
        case Syntax.ThisKeyword:
        case Syntax.SuperKeyword:
        case Syntax.PropertyAccessExpression:
        case Syntax.ElementAccessExpression:
          return narrowTypeByTruthiness(type, expr, assumeTrue);
        case Syntax.CallExpression:
          return narrowTypeByCallExpression(type, <CallExpression>expr, assumeTrue);
        case Syntax.ParenthesizedExpression:
          return narrowType(type, (<ParenthesizedExpression>expr).expression, assumeTrue);
        case Syntax.BinaryExpression:
          return narrowTypeByBinaryExpression(type, <BinaryExpression>expr, assumeTrue);
        case Syntax.PrefixUnaryExpression:
          if ((<PrefixUnaryExpression>expr).operator === Syntax.ExclamationToken) return narrowType(type, (<PrefixUnaryExpression>expr).operand, !assumeTrue);
          break;
      }
      return type;
    }
    function narrowTypeByOptionality(type: Type, expr: Expression, assumePresent: boolean): Type {
      if (isMatchingReference(reference, expr)) return getTypeWithFacts(type, assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull);
      if (isMatchingReferenceDiscriminant(expr, type))
        return narrowTypeByDiscriminant(type, <AccessExpression>expr, (t) => getTypeWithFacts(t, assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull));
      return type;
    }
  }
  function getTypeOfSymbolAtLocation(symbol: Symbol, location: Node) {
    symbol = symbol.exportSymbol || symbol;
    if (location.kind === Syntax.Identifier) {
      if (isRightSideOfQualifiedNameOrPropertyAccess(location)) location = location.parent;
      if (qc.is.expressionNode(location) && !isAssignmentTarget(location)) {
        const type = getTypeOfExpression(<Expression>location);
        if (getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) === symbol) return type;
      }
    }
    return this.getTypeOfSymbol();
  }
  function getControlFlowContainer(node: Node): Node {
    return Node.findAncestor(
      node.parent,
      (node) =>
        (qc.is.functionLike(node) && !qc.get.immediatelyInvokedFunctionExpression(node)) ||
        node.kind === Syntax.ModuleBlock ||
        node.kind === Syntax.SourceFile ||
        node.kind === Syntax.PropertyDeclaration
    )!;
  }
  function hasParentWithAssignmentsMarked(node: Node) {
    return !!Node.findAncestor(node.parent, (node) => qc.is.functionLike(node) && !!(getNodeLinks(node).flags & NodeCheckFlags.AssignmentsMarked));
  }
  function markParameterAssignments(node: Node) {
    if (node.kind === Syntax.Identifier) {
      if (isAssignmentTarget(node)) {
        const symbol = getResolvedSymbol(<Identifier>node);
        if (symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration).kind === Syntax.Parameter) symbol.isAssigned = true;
      }
    } else {
      qc.forEach.child(node, markParameterAssignments);
    }
  }
  function removeOptionalityFromDeclaredType(declaredType: Type, declaration: VariableLikeDeclaration): Type {
    if (pushTypeResolution(declaration.symbol, TypeSystemPropertyName.DeclaredType)) {
      const annotationIncludesUndefined =
        strictNullChecks &&
        declaration.kind === Syntax.Parameter &&
        declaration.initializer &&
        getFalsyFlags(declaredType) & TypeFlags.Undefined &&
        !(getFalsyFlags(checkExpression(declaration.initializer)) & TypeFlags.Undefined);
      popTypeResolution();
      return annotationIncludesUndefined ? getTypeWithFacts(declaredType, TypeFacts.NEUndefined) : declaredType;
    } else {
      reportCircularityError(declaration.symbol);
      return declaredType;
    }
  }
  function isConstraintPosition(node: Node) {
    const parent = node.parent;
    return (
      parent.kind === Syntax.PropertyAccessExpression ||
      (parent.kind === Syntax.CallExpression && (<CallExpression>parent).expression === node) ||
      (parent.kind === Syntax.ElementAccessExpression && (<ElementAccessExpression>parent).expression === node) ||
      (parent.kind === Syntax.BindingElement && (<BindingElement>parent).name === node && !!(<BindingElement>parent).initializer)
    );
  }
  function typeHasNullableConstraint(type: Type) {
    return type.flags & TypeFlags.InstantiableNonPrimitive && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, TypeFlags.Nullable);
  }
  function getConstraintForLocation(type: Type, node: Node): Type;
  function getConstraintForLocation(type: Type | undefined, node: Node): Type | undefined;
  function getConstraintForLocation(type: Type, node: Node): Type | undefined {
    if (type && isConstraintPosition(node) && forEachType(type, typeHasNullableConstraint)) return mapType(getWidenedType(type), getBaseConstraintOrType);
    return type;
  }
  function isExportOrExportExpression(location: Node) {
    return !!Node.findAncestor(location, (e) => e.parent && qc.is.kind(ExportAssignment, e.parent) && e.parent.expression === e && isEntityNameExpression(e));
  }
  function markAliasReferenced(symbol: Symbol, location: Node) {
    if (symbol.isNonLocalAlias(SymbolFlags.Value) && !isInTypeQuery(location) && !this.getTypeOnlyAliasDeclaration()) {
      if ((compilerOptions.preserveConstEnums && isExportOrExportExpression(location)) || !isConstEnumOrConstEnumOnlyModule(this.resolveAlias())) symbol.markAliasSymbolAsReferenced();
      else symbol.markConstEnumAliasAsReferenced();
    }
  }
  function checkIdentifier(node: Identifier): Type {
    const symbol = getResolvedSymbol(node);
    if (symbol === unknownSymbol) return errorType;
    if (symbol === argumentsSymbol) {
      const container = qc.get.containingFunction(node)!;
      getNodeLinks(container).flags |= NodeCheckFlags.CaptureArguments;
      return this.getTypeOfSymbol();
    }
    if (!(node.parent && qc.is.kind(PropertyAccessExpression, node.parent) && node.parent.expression === node)) markAliasReferenced(symbol, node);
    const localOrExportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
    let declaration: Declaration | undefined = localOrExportSymbol.valueDeclaration;
    if (localOrExportSymbol.flags & SymbolFlags.Class) {
      if (declaration.kind === Syntax.ClassDeclaration && nodeIsDecorated(declaration as ClassDeclaration)) {
        let container = qc.get.containingClass(node);
        while (container !== undefined) {
          if (container === declaration && container.name !== node) {
            getNodeLinks(declaration).flags |= NodeCheckFlags.ClassWithConstructorReference;
            getNodeLinks(node).flags |= NodeCheckFlags.ConstructorReferenceInClass;
            break;
          }
          container = qc.get.containingClass(container);
        }
      } else if (declaration.kind === Syntax.ClassExpression) {
        let container = qc.get.thisContainer(node, false);
        while (container.kind !== Syntax.SourceFile) {
          if (container.parent === declaration) {
            if (container.kind === Syntax.PropertyDeclaration && hasSyntacticModifier(container, ModifierFlags.Static)) {
              getNodeLinks(declaration).flags |= NodeCheckFlags.ClassWithConstructorReference;
              getNodeLinks(node).flags |= NodeCheckFlags.ConstructorReferenceInClass;
            }
            break;
          }
          container = qc.get.thisContainer(container, false);
        }
      }
    }
    checkNestedBlockScopedBinding(node, symbol);
    const type = getConstraintForLocation(getTypeOfSymbol(localOrExportSymbol), node);
    const assignmentKind = getAssignmentTargetKind(node);
    if (assignmentKind) {
      if (!(localOrExportSymbol.flags & SymbolFlags.Variable) && !(isInJSFile(node) && localOrExportSymbol.flags & SymbolFlags.ValueModule)) {
        error(node, qd.Cannot_assign_to_0_because_it_is_not_a_variable, symbol.symbolToString());
        return errorType;
      }
      if (isReadonlySymbol(localOrExportSymbol)) {
        if (localOrExportSymbol.flags & SymbolFlags.Variable) error(node, qd.Cannot_assign_to_0_because_it_is_a_constant, symbol.symbolToString());
        else {
          error(node, qd.Cannot_assign_to_0_because_it_is_a_read_only_property, symbol.symbolToString());
        }
        return errorType;
      }
    }
    const isAlias = localOrExportSymbol.flags & SymbolFlags.Alias;
    if (localOrExportSymbol.flags & SymbolFlags.Variable) {
      if (assignmentKind === AssignmentKind.Definite) return type;
    } else if (isAlias) {
      declaration = find<Declaration>(symbol.declarations, isSomeImportDeclaration);
    }
    return type;
    if (!declaration) return type;
    const isParameter = getRootDeclaration(declaration).kind === Syntax.Parameter;
    const declarationContainer = getControlFlowContainer(declaration);
    let flowContainer = getControlFlowContainer(node);
    const isOuterVariable = flowContainer !== declarationContainer;
    const isSpreadDestructuringAssignmentTarget = node.parent && node.parent.parent && qc.is.kind(SpreadAssignment, node.parent) && isDestructuringAssignmentTarget(node.parent.parent);
    const isModuleExports = symbol.flags & SymbolFlags.ModuleExports;
    while (
      flowContainer !== declarationContainer &&
      (flowContainer.kind === Syntax.FunctionExpression || flowContainer.kind === Syntax.ArrowFunction || qc.is.objectLiteralOrClassExpressionMethod(flowContainer)) &&
      (isConstVariable(localOrExportSymbol) || (isParameter && !isParameterAssigned(localOrExportSymbol)))
    ) {
      flowContainer = getControlFlowContainer(flowContainer);
    }
    const assumeInitialized =
      isParameter ||
      isAlias ||
      isOuterVariable ||
      isSpreadDestructuringAssignmentTarget ||
      isModuleExports ||
      qc.is.kind(BindingElement, declaration) ||
      (type !== autoType &&
        type !== autoArrayType &&
        (!strictNullChecks || (type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void)) !== 0 || isInTypeQuery(node) || node.parent.kind === Syntax.ExportSpecifier)) ||
      node.parent.kind === Syntax.NonNullExpression ||
      (declaration.kind === Syntax.VariableDeclaration && (<VariableDeclaration>declaration).exclamationToken) ||
      declaration.flags & NodeFlags.Ambient;
    const initialType = assumeInitialized
      ? isParameter
        ? removeOptionalityFromDeclaredType(type, declaration as VariableLikeDeclaration)
        : type
      : type === autoType || type === autoArrayType
      ? undefinedType
      : getOptionalType(type);
    const flowType = getFlowTypeOfReference(node, type, initialType, flowContainer, !assumeInitialized);
    if (!isEvolvingArrayOperationTarget(node) && (type === autoType || type === autoArrayType)) {
      if (flowType === autoType || flowType === autoArrayType) {
        if (noImplicitAny) {
          error(getNameOfDeclaration(declaration), qd.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbol.symbolToString(), typeToString(flowType));
          error(node, qd.Variable_0_implicitly_has_an_1_type, symbol.symbolToString(), typeToString(flowType));
        }
        return convertAutoToAny(flowType);
      }
    } else if (!assumeInitialized && !(getFalsyFlags(type) & TypeFlags.Undefined) && getFalsyFlags(flowType) & TypeFlags.Undefined) {
      error(node, qd.Variable_0_is_used_before_being_assigned, symbol.symbolToString());
      return type;
    }
    return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
  }
  function isInsideFunction(node: Node, threshold: Node): boolean {
    return !!Node.findAncestor(node, (n) => (n === threshold ? 'quit' : qc.is.functionLike(n)));
  }
  function getPartOfForStatementContainingNode(node: Node, container: ForStatement) {
    return Node.findAncestor(node, (n) => (n === container ? 'quit' : n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement));
  }
  function checkNestedBlockScopedBinding(node: Identifier, symbol: Symbol): void {
    return;
  }
  function isBindingCapturedByNode(node: Node, decl: VariableDeclaration | BindingElement) {
    const links = getNodeLinks(node);
    return !!links && contains(links.capturedBlockScopeBindings, getSymbolOfNode(decl));
  }
  function isAssignedInBodyOfForStatement(node: Identifier, container: ForStatement): boolean {
    let current: Node = node;
    while (current.parent.kind === Syntax.ParenthesizedExpression) {
      current = current.parent;
    }
    let isAssigned = false;
    if (isAssignmentTarget(current)) isAssigned = true;
    else if (current.parent.kind === Syntax.PrefixUnaryExpression || current.parent.kind === Syntax.PostfixUnaryExpression) {
      const expr = <PrefixUnaryExpression | PostfixUnaryExpression>current.parent;
      isAssigned = expr.operator === Syntax.Plus2Token || expr.operator === Syntax.Minus2Token;
    }
    if (!isAssigned) return false;
    return !!Node.findAncestor(current, (n) => (n === container ? 'quit' : n === container.statement));
  }
  function captureLexicalThis(node: Node, container: Node): void {
    getNodeLinks(node).flags |= NodeCheckFlags.LexicalThis;
    if (container.kind === Syntax.PropertyDeclaration || container.kind === Syntax.Constructor) {
      const classNode = container.parent;
      getNodeLinks(classNode).flags |= NodeCheckFlags.CaptureThis;
    } else {
      getNodeLinks(container).flags |= NodeCheckFlags.CaptureThis;
    }
  }
  function findFirstSuperCall(node: Node): SuperCall | undefined {
    return qc.is.superCall(node) ? node : qc.is.functionLike(node) ? undefined : qc.forEach.child(node, findFirstSuperCall);
  }
  function classDeclarationExtendsNull(classDecl: ClassDeclaration): boolean {
    const classSymbol = getSymbolOfNode(classDecl);
    const classInstanceType = <InterfaceType>getDeclaredTypeOfSymbol(classSymbol);
    const baseConstructorType = getBaseConstructorTypeOfClass(classInstanceType);
    return baseConstructorType === nullWideningType;
  }
  function checkThisBeforeSuper(node: Node, container: Node, diagnosticMessage: DiagnosticMessage) {
    const containingClassDecl = <ClassDeclaration>container.parent;
    const baseTypeNode = getClassExtendsHeritageElement(containingClassDecl);
    if (baseTypeNode && !classDeclarationExtendsNull(containingClassDecl)) {
      if (node.flowNode && !isPostSuperFlowNode(node.flowNode, false)) error(node, diagnosticMessage);
    }
  }
  function checkThisNodeIsExpression(node: Node): Type {
    let container = qc.get.thisContainer(node, true);
    let capturedByArrowFunction = false;
    if (container.kind === Syntax.Constructor) checkThisBeforeSuper(node, container, qd.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class);
    if (container.kind === Syntax.ArrowFunction) {
      container = qc.get.thisContainer(container, false);
      capturedByArrowFunction = true;
    }
    switch (container.kind) {
      case Syntax.ModuleDeclaration:
        error(node, qd.this_cannot_be_referenced_in_a_module_or_namespace_body);
        break;
      case Syntax.EnumDeclaration:
        error(node, qd.this_cannot_be_referenced_in_current_location);
        break;
      case Syntax.Constructor:
        if (isInConstructorArgumentInitializer(node, container)) error(node, qd.this_cannot_be_referenced_in_constructor_arguments);
        break;
      case Syntax.PropertyDeclaration:
      case Syntax.PropertySignature:
        if (hasSyntacticModifier(container, ModifierFlags.Static) && !(compilerOptions.target === ScriptTarget.ESNext && compilerOptions.useDefineForClassFields))
          error(node, qd.this_cannot_be_referenced_in_a_static_property_initializer);
        break;
      case Syntax.ComputedPropertyName:
        error(node, qd.this_cannot_be_referenced_in_a_computed_property_name);
        break;
    }
    const type = tryGetThisTypeAt(node, true, container);
    if (noImplicitThis) {
      const globalThisType = getTypeOfSymbol(globalThisSymbol);
      if (type === globalThisType && capturedByArrowFunction) error(node, qd.The_containing_arrow_function_captures_the_global_value_of_this);
      else if (!type) {
        const diag = error(node, qd.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation);
        if (!qc.is.kind(SourceFile, container)) {
          const outsideThis = tryGetThisTypeAt(container);
          if (outsideThis && outsideThis !== globalThisType) addRelatedInfo(diag, createDiagnosticForNode(container, qd.An_outer_value_of_this_is_shadowed_by_this_container));
        }
      }
    }
    return type || anyType;
  }
  function tryGetThisTypeAt(node: Node, includeGlobalThis = true, container = qc.get.thisContainer(node, false)): Type | undefined {
    const isInJS = isInJSFile(node);
    if (qc.is.functionLike(container) && (!isInParameterInitializerBeforeContainingFunction(node) || getThisNodeKind(ParameterDeclaration, container))) {
      const className = getClassNameFromPrototypeMethod(container);
      if (isInJS && className) {
        const classSymbol = checkExpression(className).symbol;
        if (classSymbol && classSymbol.members && classSymbol.flags & SymbolFlags.Function) {
          const classType = (getDeclaredTypeOfSymbol(classSymbol) as InterfaceType).thisType;
          if (classType) return getFlowTypeOfReference(node, classType);
        }
      } else if (isInJS && (container.kind === Syntax.FunctionExpression || container.kind === Syntax.FunctionDeclaration) && qc.getDoc.classTag(container)) {
        const classType = (getDeclaredTypeOfSymbol(getMergedSymbol(container.symbol)) as InterfaceType).thisType!;
        return getFlowTypeOfReference(node, classType);
      }
      const thisType = getThisTypeOfDeclaration(container) || getContextualThisParameterType(container);
      if (thisType) return getFlowTypeOfReference(node, thisType);
    }
    if (qc.is.classLike(container.parent)) {
      const symbol = getSymbolOfNode(container.parent);
      const type = hasSyntacticModifier(container, ModifierFlags.Static) ? this.getTypeOfSymbol() : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType!;
      return getFlowTypeOfReference(node, type);
    }
    if (isInJS) {
      const type = getTypeForThisExpressionFromJSDoc(container);
      if (type && type !== errorType) return getFlowTypeOfReference(node, type);
    }
    if (qc.is.kind(SourceFile, container)) {
      if (container.commonJsModuleIndicator) {
        const fileSymbol = getSymbolOfNode(container);
        return fileSymbol && getTypeOfSymbol(fileSymbol);
      } else if (container.externalModuleIndicator) {
        return undefinedType;
      } else if (includeGlobalThis) {
        return getTypeOfSymbol(globalThisSymbol);
      }
    }
  }
  function getExplicitThisType(node: Expression) {
    const container = qc.get.thisContainer(node, false);
    if (qc.is.functionLike(container)) {
      const signature = getSignatureFromDeclaration(container);
      if (signature.thisParameter) return getExplicitTypeOfSymbol(signature.thisParameter);
    }
    if (qc.is.classLike(container.parent)) {
      const symbol = getSymbolOfNode(container.parent);
      return hasSyntacticModifier(container, ModifierFlags.Static) ? this.getTypeOfSymbol() : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType!;
    }
  }
  function getClassNameFromPrototypeMethod(container: Node) {
    if (
      container.kind === Syntax.FunctionExpression &&
      qc.is.kind(BinaryExpression, container.parent) &&
      getAssignmentDeclarationKind(container.parent) === AssignmentDeclarationKind.PrototypeProperty
    ) {
      return ((container.parent.left as PropertyAccessExpression).expression as PropertyAccessExpression).expression;
    } else if (
      container.kind === Syntax.MethodDeclaration &&
      container.parent.kind === Syntax.ObjectLiteralExpression &&
      qc.is.kind(BinaryExpression, container.parent.parent) &&
      getAssignmentDeclarationKind(container.parent.parent) === AssignmentDeclarationKind.Prototype
    ) {
      return (container.parent.parent.left as PropertyAccessExpression).expression;
    } else if (
      container.kind === Syntax.FunctionExpression &&
      container.parent.kind === Syntax.PropertyAssignment &&
      container.parent.parent.kind === Syntax.ObjectLiteralExpression &&
      qc.is.kind(BinaryExpression, container.parent.parent.parent) &&
      getAssignmentDeclarationKind(container.parent.parent.parent) === AssignmentDeclarationKind.Prototype
    ) {
      return (container.parent.parent.parent.left as PropertyAccessExpression).expression;
    } else if (
      container.kind === Syntax.FunctionExpression &&
      qc.is.kind(PropertyAssignment, container.parent) &&
      qc.is.kind(Identifier, container.parent.name) &&
      (container.parent.name.escapedText === 'value' || container.parent.name.escapedText === 'get' || container.parent.name.escapedText === 'set') &&
      qc.is.kind(ObjectLiteralExpression, container.parent.parent) &&
      qc.is.kind(CallExpression, container.parent.parent.parent) &&
      container.parent.parent.parent.arguments[2] === container.parent.parent &&
      getAssignmentDeclarationKind(container.parent.parent.parent) === AssignmentDeclarationKind.ObjectDefinePrototypeProperty
    ) {
      return (container.parent.parent.parent.arguments[0] as PropertyAccessExpression).expression;
    } else if (
      qc.is.kind(MethodDeclaration, container) &&
      qc.is.kind(Identifier, container.name) &&
      (container.name.escapedText === 'value' || container.name.escapedText === 'get' || container.name.escapedText === 'set') &&
      qc.is.kind(ObjectLiteralExpression, container.parent) &&
      qc.is.kind(CallExpression, container.parent.parent) &&
      container.parent.parent.arguments[2] === container.parent &&
      getAssignmentDeclarationKind(container.parent.parent) === AssignmentDeclarationKind.ObjectDefinePrototypeProperty
    ) {
      return (container.parent.parent.arguments[0] as PropertyAccessExpression).expression;
    }
  }
  function getTypeForThisExpressionFromJSDoc(node: Node) {
    const jsdocType = qc.getDoc.type(node);
    if (jsdocType && jsdocType.kind === Syntax.JSDocFunctionType) {
      const jsDocFunctionType = <JSDocFunctionType>jsdocType;
      if (jsDocFunctionType.parameters.length > 0 && jsDocFunctionType.parameters[0].name && (jsDocFunctionType.parameters[0].name as Identifier).escapedText === InternalSymbolName.This)
        return getTypeFromTypeNode(jsDocFunctionType.parameters[0].type!);
    }
    const thisTag = qc.getDoc.thisTag(node);
    if (thisTag && thisTag.typeExpression) return getTypeFromTypeNode(thisTag.typeExpression);
  }
  function isInConstructorArgumentInitializer(node: Node, constructorDecl: Node): boolean {
    return !!Node.findAncestor(node, (n) => (qc.is.functionLikeDeclaration(n) ? 'quit' : n.kind === Syntax.Parameter && n.parent === constructorDecl));
  }
  function checkSuperExpression(node: Node): Type {
    const isCallExpression = node.parent.kind === Syntax.CallExpression && (<CallExpression>node.parent).expression === node;
    const immediateContainer = qc.get.superContainer(node, true);
    let container = immediateContainer;
    let needToCaptureLexicalThis = false;
    if (!isCallExpression) {
      while (container && container.kind === Syntax.ArrowFunction) {
        container = qc.get.superContainer(container, true);
        needToCaptureLexicalThis = false;
      }
    }
    const canUseSuperExpression = isLegalUsageOfSuperExpression(container);
    let nodeCheckFlag: NodeCheckFlags = 0;
    if (!canUseSuperExpression) {
      const current = Node.findAncestor(node, (n) => (n === container ? 'quit' : n.kind === Syntax.ComputedPropertyName));
      if (current && current.kind === Syntax.ComputedPropertyName) error(node, qd.super_cannot_be_referenced_in_a_computed_property_name);
      else if (isCallExpression) {
        error(node, qd.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
      } else if (!container || !container.parent || !(qc.is.classLike(container.parent) || container.parent.kind === Syntax.ObjectLiteralExpression)) {
        error(node, qd.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions);
      } else {
        error(node, qd.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
      }
      return errorType;
    }
    if (!isCallExpression && immediateContainer.kind === Syntax.Constructor)
      checkThisBeforeSuper(node, container, qd.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class);
    if (hasSyntacticModifier(container, ModifierFlags.Static) || isCallExpression) nodeCheckFlag = NodeCheckFlags.SuperStatic;
    else {
      nodeCheckFlag = NodeCheckFlags.SuperInstance;
    }
    getNodeLinks(node).flags |= nodeCheckFlag;
    if (container.kind === Syntax.MethodDeclaration && hasSyntacticModifier(container, ModifierFlags.Async)) {
      if (qc.is.superProperty(node.parent) && isAssignmentTarget(node.parent)) getNodeLinks(container).flags |= NodeCheckFlags.AsyncMethodWithSuperBinding;
      else {
        getNodeLinks(container).flags |= NodeCheckFlags.AsyncMethodWithSuper;
      }
    }
    if (needToCaptureLexicalThis) captureLexicalThis(node.parent, container);
    if (container.parent.kind === Syntax.ObjectLiteralExpression) return anyType;
    const classLikeDeclaration = <ClassLikeDeclaration>container.parent;
    if (!getClassExtendsHeritageElement(classLikeDeclaration)) {
      error(node, qd.super_can_only_be_referenced_in_a_derived_class);
      return errorType;
    }
    const classType = <InterfaceType>getDeclaredTypeOfSymbol(getSymbolOfNode(classLikeDeclaration));
    const baseClassType = classType && getBaseTypes(classType)[0];
    if (!baseClassType) return errorType;
    if (container.kind === Syntax.Constructor && isInConstructorArgumentInitializer(node, container)) {
      error(node, qd.super_cannot_be_referenced_in_constructor_arguments);
      return errorType;
    }
    return nodeCheckFlag === NodeCheckFlags.SuperStatic ? getBaseConstructorTypeOfClass(classType) : getTypeWithThisArgument(baseClassType, classType.thisType);
    function isLegalUsageOfSuperExpression(container: Node): boolean {
      if (!container) return false;
      if (isCallExpression) return container.kind === Syntax.Constructor;
      else {
        if (qc.is.classLike(container.parent) || container.parent.kind === Syntax.ObjectLiteralExpression) {
          if (hasSyntacticModifier(container, ModifierFlags.Static))
            return container.kind === Syntax.MethodDeclaration || container.kind === Syntax.MethodSignature || container.kind === Syntax.GetAccessor || container.kind === Syntax.SetAccessor;
          else {
            return (
              container.kind === Syntax.MethodDeclaration ||
              container.kind === Syntax.MethodSignature ||
              container.kind === Syntax.GetAccessor ||
              container.kind === Syntax.SetAccessor ||
              container.kind === Syntax.PropertyDeclaration ||
              container.kind === Syntax.PropertySignature ||
              container.kind === Syntax.Constructor
            );
          }
        }
      }
      return false;
    }
  }
  function getContainingObjectLiteral(func: SignatureDeclaration): ObjectLiteralExpression | undefined {
    return (func.kind === Syntax.MethodDeclaration || func.kind === Syntax.GetAccessor || func.kind === Syntax.SetAccessor) && func.parent.kind === Syntax.ObjectLiteralExpression
      ? func.parent
      : func.kind === Syntax.FunctionExpression && func.parent.kind === Syntax.PropertyAssignment
      ? <ObjectLiteralExpression>func.parent.parent
      : undefined;
  }
  function getThisTypeArgument(type: Type): Type | undefined {
    return getObjectFlags(type) & ObjectFlags.Reference && (<TypeReference>type).target === globalThisType ? getTypeArguments(<TypeReference>type)[0] : undefined;
  }
  function getThisTypeFromContextualType(type: Type): Type | undefined {
    return mapType(type, (t) => {
      return t.flags & TypeFlags.Intersection ? forEach((<IntersectionType>t).types, getThisTypeArgument) : getThisTypeArgument(t);
    });
  }
  function getContextualThisParameterType(func: SignatureDeclaration): Type | undefined {
    if (func.kind === Syntax.ArrowFunction) return;
    if (isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
      const contextualSignature = getContextualSignature(func);
      if (contextualSignature) {
        const thisParameter = contextualSignature.thisParameter;
        if (thisParameter) return getTypeOfSymbol(thisParameter);
      }
    }
    const inJs = isInJSFile(func);
    if (noImplicitThis || inJs) {
      const containingLiteral = getContainingObjectLiteral(func);
      if (containingLiteral) {
        const contextualType = getApparentTypeOfContextualType(containingLiteral);
        let literal = containingLiteral;
        let type = contextualType;
        while (type) {
          const thisType = getThisTypeFromContextualType(type);
          if (thisType) return instantiateType(thisType, getMapperFromContext(getInferenceContext(containingLiteral)));
          if (literal.parent.kind !== Syntax.PropertyAssignment) break;
          literal = <ObjectLiteralExpression>literal.parent.parent;
          type = getApparentTypeOfContextualType(literal);
        }
        return getWidenedType(contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral));
      }
      const parent = walkUpParenthesizedExpressions(func.parent);
      if (parent.kind === Syntax.BinaryExpression && (<BinaryExpression>parent).operatorToken.kind === Syntax.EqualsToken) {
        const target = (<BinaryExpression>parent).left;
        if (isAccessExpression(target)) {
          const { expression } = target;
          if (inJs && qc.is.kind(Identifier, expression)) {
            const sourceFile = qc.get.sourceFileOf(parent);
            if (sourceFile.commonJsModuleIndicator && getResolvedSymbol(expression) === sourceFile.symbol) return;
          }
          return getWidenedType(checkExpressionCached(expression));
        }
      }
    }
    return;
  }
  function getContextuallyTypedParameterType(parameter: ParameterDeclaration): Type | undefined {
    const func = parameter.parent;
    if (!isContextSensitiveFunctionOrObjectLiteralMethod(func)) return;
    const iife = qc.get.immediatelyInvokedFunctionExpression(func);
    if (iife && iife.arguments) {
      const args = getEffectiveCallArguments(iife);
      const indexOfParameter = func.parameters.indexOf(parameter);
      if (parameter.dot3Token) return getSpreadArgumentType(args, indexOfParameter, args.length, anyType, undefined);
      const links = getNodeLinks(iife);
      const cached = links.resolvedSignature;
      links.resolvedSignature = anySignature;
      const type = indexOfParameter < args.length ? getWidenedLiteralType(checkExpression(args[indexOfParameter])) : parameter.initializer ? undefined : undefinedWideningType;
      links.resolvedSignature = cached;
      return type;
    }
    const contextualSignature = getContextualSignature(func);
    if (contextualSignature) {
      const index = func.parameters.indexOf(parameter) - (getThisNodeKind(ParameterDeclaration, func) ? 1 : 0);
      return parameter.dot3Token && lastOrUndefined(func.parameters) === parameter ? getRestTypeAtPosition(contextualSignature, index) : tryGetTypeAtPosition(contextualSignature, index);
    }
  }
  function getContextualTypeForVariableLikeDeclaration(declaration: VariableLikeDeclaration): Type | undefined {
    const typeNode = getEffectiveTypeAnnotationNode(declaration);
    if (typeNode) return getTypeFromTypeNode(typeNode);
    switch (declaration.kind) {
      case Syntax.Parameter:
        return getContextuallyTypedParameterType(declaration);
      case Syntax.BindingElement:
        return getContextualTypeForBindingElement(declaration);
    }
  }
  function getContextualTypeForBindingElement(declaration: BindingElement): Type | undefined {
    const parent = declaration.parent.parent;
    const name = declaration.propertyName || declaration.name;
    const parentType = getContextualTypeForVariableLikeDeclaration(parent) || (parent.kind !== Syntax.BindingElement && parent.initializer && checkDeclarationInitializer(parent));
    if (parentType && !qc.is.kind(BindingPattern, name) && !isComputedNonLiteralName(name)) {
      const nameType = getLiteralTypeFromPropertyName(name);
      if (isTypeUsableAsPropertyName(nameType)) {
        const text = getPropertyNameFromType(nameType);
        return getTypeOfPropertyOfType(parentType, text);
      }
    }
  }
  function getContextualTypeForInitializerExpression(node: Expression): Type | undefined {
    const declaration = <VariableLikeDeclaration>node.parent;
    if (qc.is.withInitializer(declaration) && node === declaration.initializer) {
      const result = getContextualTypeForVariableLikeDeclaration(declaration);
      if (result) return result;
      if (qc.is.kind(BindingPattern, declaration.name)) return getTypeFromBindingPattern(declaration.name, true, false);
    }
    return;
  }
  function getContextualTypeForReturnExpression(node: Expression): Type | undefined {
    const func = qc.get.containingFunction(node);
    if (func) {
      const functionFlags = getFunctionFlags(func);
      if (functionFlags & FunctionFlags.Generator) return;
      const contextualReturnType = getContextualReturnType(func);
      if (contextualReturnType) {
        if (functionFlags & FunctionFlags.Async) {
          const contextualAwaitedType = mapType(contextualReturnType, getAwaitedTypeOfPromise);
          return contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]);
        }
        return contextualReturnType;
      }
    }
    return;
  }
  function getContextualTypeForAwaitOperand(node: AwaitExpression): Type | undefined {
    const contextualType = getContextualType(node);
    if (contextualType) {
      const contextualAwaitedType = getAwaitedType(contextualType);
      return contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]);
    }
    return;
  }
  function getContextualTypeForYieldOperand(node: YieldExpression): Type | undefined {
    const func = qc.get.containingFunction(node);
    if (func) {
      const functionFlags = getFunctionFlags(func);
      const contextualReturnType = getContextualReturnType(func);
      if (contextualReturnType)
        return node.asteriskToken ? contextualReturnType : getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Yield, contextualReturnType, (functionFlags & FunctionFlags.Async) !== 0);
    }
    return;
  }
  function isInParameterInitializerBeforeContainingFunction(node: Node) {
    let inBindingInitializer = false;
    while (node.parent && !qc.is.functionLike(node.parent)) {
      if (qc.is.kind(ParameterDeclaration, node.parent) && (inBindingInitializer || node.parent.initializer === node)) return true;
      if (qc.is.kind(BindingElement, node.parent) && node.parent.initializer === node) inBindingInitializer = true;
      node = node.parent;
    }
    return false;
  }
  function getContextualIterationType(kind: IterationTypeKind, functionDecl: SignatureDeclaration): Type | undefined {
    const isAsync = !!(getFunctionFlags(functionDecl) & FunctionFlags.Async);
    const contextualReturnType = getContextualReturnType(functionDecl);
    if (contextualReturnType) return getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync) || undefined;
    return;
  }
  function getContextualReturnType(functionDecl: SignatureDeclaration): Type | undefined {
    const returnType = getReturnTypeFromAnnotation(functionDecl);
    if (returnType) return returnType;
    const signature = getContextualSignatureForFunctionLikeDeclaration(<FunctionExpression>functionDecl);
    if (signature && !isResolvingReturnTypeOfSignature(signature)) return getReturnTypeOfSignature(signature);
    return;
  }
  function getContextualTypeForArgument(callTarget: CallLikeExpression, arg: Expression): Type | undefined {
    const args = getEffectiveCallArguments(callTarget);
    const argIndex = args.indexOf(arg);
    return argIndex === -1 ? undefined : getContextualTypeForArgumentAtIndex(callTarget, argIndex);
  }
  function getContextualTypeForArgumentAtIndex(callTarget: CallLikeExpression, argIndex: number): Type {
    const signature = getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget);
    if (qc.isJsx.openingLikeElement(callTarget) && argIndex === 0) return getEffectiveFirstArgumentForJsxSignature(signature, callTarget);
    return getTypeAtPosition(signature, argIndex);
  }
  function getContextualTypeForSubstitutionExpression(template: TemplateExpression, substitutionExpression: Expression) {
    if (template.parent.kind === Syntax.TaggedTemplateExpression) return getContextualTypeForArgument(<TaggedTemplateExpression>template.parent, substitutionExpression);
    return;
  }
  function getContextualTypeForBinaryOperand(node: Expression, contextFlags?: ContextFlags): Type | undefined {
    const binaryExpression = <BinaryExpression>node.parent;
    const { left, operatorToken, right } = binaryExpression;
    switch (operatorToken.kind) {
      case Syntax.EqualsToken:
        if (node !== right) return;
        const contextSensitive = getIsContextSensitiveAssignmentOrContextType(binaryExpression);
        if (!contextSensitive) return;
        return contextSensitive === true ? getTypeOfExpression(left) : contextSensitive;
      case Syntax.Bar2Token:
      case Syntax.Question2Token:
        const type = getContextualType(binaryExpression, contextFlags);
        return node === right && ((type && type.pattern) || (!type && !isDefaultedExpandoInitializer(binaryExpression))) ? getTypeOfExpression(left) : type;
      case Syntax.Ampersand2Token:
      case Syntax.CommaToken:
        return node === right ? getContextualType(binaryExpression, contextFlags) : undefined;
      default:
        return;
    }
  }
  function getIsContextSensitiveAssignmentOrContextType(binaryExpression: BinaryExpression): boolean | Type {
    const kind = getAssignmentDeclarationKind(binaryExpression);
    switch (kind) {
      case AssignmentDeclarationKind.None:
        return true;
      case AssignmentDeclarationKind.Property:
      case AssignmentDeclarationKind.ExportsProperty:
      case AssignmentDeclarationKind.Prototype:
      case AssignmentDeclarationKind.PrototypeProperty:
        if (!binaryExpression.left.symbol) return true;
        else {
          const decl = binaryExpression.left.symbol.valueDeclaration;
          if (!decl) return false;
          const lhs = cast(binaryExpression.left, isAccessExpression);
          const overallAnnotation = getEffectiveTypeAnnotationNode(decl);
          if (overallAnnotation) return getTypeFromTypeNode(overallAnnotation);
          else if (qc.is.kind(Identifier, lhs.expression)) {
            const id = lhs.expression;
            const parentSymbol = resolveName(id, id.escapedText, SymbolFlags.Value, undefined, id.escapedText, true);
            if (parentSymbol) {
              const annotated = getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration);
              if (annotated) {
                const nameStr = getElementOrPropertyAccessName(lhs);
                if (nameStr !== undefined) {
                  const type = getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated), nameStr);
                  return type || false;
                }
              }
              return false;
            }
          }
          return !isInJSFile(decl);
        }
      case AssignmentDeclarationKind.ModuleExports:
      case AssignmentDeclarationKind.ThisProperty:
        if (!binaryExpression.symbol) return true;
        if (binaryExpression.symbol.valueDeclaration) {
          const annotated = getEffectiveTypeAnnotationNode(binaryExpression.symbol.valueDeclaration);
          if (annotated) {
            const type = getTypeFromTypeNode(annotated);
            if (type) return type;
          }
        }
        if (kind === AssignmentDeclarationKind.ModuleExports) return false;
        const thisAccess = cast(binaryExpression.left, isAccessExpression);
        if (!qc.is.objectLiteralMethod(qc.get.thisContainer(thisAccess.expression, false))) return false;
        const thisType = checkThisNodeExpression(thisAccess.expression);
        const nameStr = getElementOrPropertyAccessName(thisAccess);
        return (nameStr !== undefined && thisType && getTypeOfPropertyOfContextualType(thisType, nameStr)) || false;
      case AssignmentDeclarationKind.ObjectDefinePropertyValue:
      case AssignmentDeclarationKind.ObjectDefinePropertyExports:
      case AssignmentDeclarationKind.ObjectDefinePrototypeProperty:
        return fail('Does not apply');
      default:
        return Debug.assertNever(kind);
    }
  }
  function getTypeOfPropertyOfContextualType(type: Type, name: __String) {
    return mapType(
      type,
      (t) => {
        if (isGenericMappedType(t)) {
          const constraint = getConstraintTypeFromMappedType(t);
          const constraintOfConstraint = getBaseConstraintOfType(constraint) || constraint;
          const propertyNameType = getLiteralType(syntax.get.unescUnderscores(name));
          if (isTypeAssignableTo(propertyNameType, constraintOfConstraint)) return substituteIndexedMappedType(t, propertyNameType);
        } else if (t.flags & TypeFlags.StructuredType) {
          const prop = getPropertyOfType(t, name);
          if (prop) return isCircularMappedProperty(prop) ? undefined : getTypeOfSymbol(prop);
          if (isTupleType(t)) {
            const restType = getRestTypeOfTupleType(t);
            if (restType && NumericLiteral.name(name) && +name >= 0) return restType;
          }
          return (NumericLiteral.name(name) && getIndexTypeOfContextualType(t, IndexKind.Number)) || getIndexTypeOfContextualType(t, IndexKind.String);
        }
        return;
      },
      true
    );
  }
  function getIndexTypeOfContextualType(type: Type, kind: IndexKind) {
    return mapType(type, (t) => getIndexTypeOfStructuredType(t, kind), true);
  }
  function getContextualTypeForObjectLiteralMethod(node: MethodDeclaration, contextFlags?: ContextFlags): Type | undefined {
    assert(qc.is.objectLiteralMethod(node));
    if (node.flags & NodeFlags.InWithStatement) return;
    return getContextualTypeForObjectLiteralElement(node, contextFlags);
  }
  function getContextualTypeForObjectLiteralElement(element: ObjectLiteralElementLike, contextFlags?: ContextFlags) {
    const objectLiteral = <ObjectLiteralExpression>element.parent;
    const type = getApparentTypeOfContextualType(objectLiteral, contextFlags);
    if (type) {
      if (!hasNonBindableDynamicName(element)) {
        const symbolName = getSymbolOfNode(element).escName;
        const propertyType = getTypeOfPropertyOfContextualType(type, symbolName);
        if (propertyType) return propertyType;
      }
      return (isNumericName(element.name!) && getIndexTypeOfContextualType(type, IndexKind.Number)) || getIndexTypeOfContextualType(type, IndexKind.String);
    }
    return;
  }
  function getContextualTypeForElementExpression(arrayContextualType: Type | undefined, index: number): Type | undefined {
    return (
      arrayContextualType &&
      (getTypeOfPropertyOfContextualType(arrayContextualType, ('' + index) as __String) || getIteratedTypeOrElementType(IterationUse.Element, arrayContextualType, undefinedType, undefined, false))
    );
  }
  function getContextualTypeForConditionalOperand(node: Expression, contextFlags?: ContextFlags): Type | undefined {
    const conditional = <ConditionalExpression>node.parent;
    return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional, contextFlags) : undefined;
  }
  function getContextualTypeForChildJsxExpression(node: JsxElement, child: JsxChild) {
    const attributesType = getApparentTypeOfContextualType(node.openingElement.tagName);
    const jsxChildrenPropertyName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
    if (!(attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName !== '')) return;
    const realChildren = getSemanticJsxChildren(node.children);
    const childIndex = realChildren.indexOf(child);
    const childFieldType = getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName);
    return (
      childFieldType &&
      (realChildren.length === 1
        ? childFieldType
        : mapType(
            childFieldType,
            (t) => {
              if (isArrayLikeType(t)) return getIndexedAccessType(t, getLiteralType(childIndex));
              return t;
            },
            true
          ))
    );
  }
  function getContextualTypeForJsxExpression(node: JsxExpression): Type | undefined {
    const exprParent = node.parent;
    return qc.isJsx.attributeLike(exprParent) ? getContextualType(node) : qc.is.kind(JsxElement, exprParent) ? getContextualTypeForChildJsxExpression(exprParent, node) : undefined;
  }
  function getContextualTypeForJsxAttribute(attribute: JsxAttribute | JsxSpreadAttribute): Type | undefined {
    if (qc.is.kind(JsxAttribute, attribute)) {
      const attributesType = getApparentTypeOfContextualType(attribute.parent);
      if (!attributesType || isTypeAny(attributesType)) return;
      return getTypeOfPropertyOfContextualType(attributesType, attribute.name.escapedText);
    }
    return getContextualType(attribute.parent);
  }
  function isPossiblyDiscriminantValue(node: Expression): boolean {
    switch (node.kind) {
      case Syntax.StringLiteral:
      case Syntax.NumericLiteral:
      case Syntax.BigIntLiteral:
      case Syntax.NoSubstitutionLiteral:
      case Syntax.TrueKeyword:
      case Syntax.FalseKeyword:
      case Syntax.NullKeyword:
      case Syntax.Identifier:
      case Syntax.UndefinedKeyword:
        return true;
      case Syntax.PropertyAccessExpression:
      case Syntax.ParenthesizedExpression:
        return isPossiblyDiscriminantValue((<PropertyAccessExpression | ParenthesizedExpression>node).expression);
      case Syntax.JsxExpression:
        return !(node as JsxExpression).expression || isPossiblyDiscriminantValue((node as JsxExpression).expression!);
    }
    return false;
  }
  function discriminateContextualTypeByObjectMembers(node: ObjectLiteralExpression, contextualType: UnionType) {
    return discriminateTypeByDiscriminableItems(
      contextualType,
      map(
        filter(node.properties, (p) => !!p.symbol && p.kind === Syntax.PropertyAssignment && isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escName)),
        (prop) => [() => checkExpression((prop as PropertyAssignment).initializer), prop.symbol.escName] as [() => Type, __String]
      ),
      isTypeAssignableTo,
      contextualType
    );
  }
  function discriminateContextualTypeByJSXAttributes(node: JsxAttributes, contextualType: UnionType) {
    return discriminateTypeByDiscriminableItems(
      contextualType,
      map(
        filter(
          node.properties,
          (p) => !!p.symbol && p.kind === Syntax.JsxAttribute && isDiscriminantProperty(contextualType, p.symbol.escName) && (!p.initializer || isPossiblyDiscriminantValue(p.initializer))
        ),
        (prop) => [!(prop as JsxAttribute).initializer ? () => trueType : () => checkExpression((prop as JsxAttribute).initializer!), prop.symbol.escName] as [() => Type, __String]
      ),
      isTypeAssignableTo,
      contextualType
    );
  }
  function getApparentTypeOfContextualType(node: Expression | MethodDeclaration, contextFlags?: ContextFlags): Type | undefined {
    const contextualType = qc.is.objectLiteralMethod(node) ? getContextualTypeForObjectLiteralMethod(node, contextFlags) : getContextualType(node, contextFlags);
    const instantiatedType = instantiateContextualType(contextualType, node, contextFlags);
    if (instantiatedType && !(contextFlags && contextFlags & ContextFlags.NoConstraints && instantiatedType.flags & TypeFlags.TypeVariable)) {
      const apparentType = mapType(instantiatedType, getApparentType, true);
      if (apparentType.flags & TypeFlags.Union) {
        if (qc.is.kind(ObjectLiteralExpression, node)) return discriminateContextualTypeByObjectMembers(node, apparentType as UnionType);
        else if (qc.is.kind(JsxAttributes, node)) return discriminateContextualTypeByJSXAttributes(node, apparentType as UnionType);
      }
      return apparentType;
    }
  }
  function instantiateContextualType(contextualType: Type | undefined, node: Node, contextFlags?: ContextFlags): Type | undefined {
    if (contextualType && maybeTypeOfKind(contextualType, TypeFlags.Instantiable)) {
      const inferenceContext = getInferenceContext(node);
      if (inferenceContext && some(inferenceContext.inferences, hasInferenceCandidates)) {
        if (contextFlags && contextFlags & ContextFlags.Signature) return instantiateInstantiableTypes(contextualType, inferenceContext.nonFixingMapper);
        if (inferenceContext.returnMapper) return instantiateInstantiableTypes(contextualType, inferenceContext.returnMapper);
      }
    }
    return contextualType;
  }
  function instantiateInstantiableTypes(type: Type, mapper: TypeMapper): Type {
    if (type.flags & TypeFlags.Instantiable) return instantiateType(type, mapper);
    if (type.flags & TypeFlags.Union) {
      return getUnionType(
        map((<UnionType>type).types, (t) => instantiateInstantiableTypes(t, mapper)),
        UnionReduction.None
      );
    }
    if (type.flags & TypeFlags.Intersection) return getIntersectionType(map((<IntersectionType>type).types, (t) => instantiateInstantiableTypes(t, mapper)));
    return type;
  }
  function getContextualType(node: Expression, contextFlags?: ContextFlags): Type | undefined {
    if (node.flags & NodeFlags.InWithStatement) return;
    if (node.contextualType) return node.contextualType;
    const { parent } = node;
    switch (parent.kind) {
      case Syntax.VariableDeclaration:
      case Syntax.Parameter:
      case Syntax.PropertyDeclaration:
      case Syntax.PropertySignature:
      case Syntax.BindingElement:
        return getContextualTypeForInitializerExpression(node);
      case Syntax.ArrowFunction:
      case Syntax.ReturnStatement:
        return getContextualTypeForReturnExpression(node);
      case Syntax.YieldExpression:
        return getContextualTypeForYieldOperand(<YieldExpression>parent);
      case Syntax.AwaitExpression:
        return getContextualTypeForAwaitOperand(<AwaitExpression>parent);
      case Syntax.CallExpression:
        if ((<CallExpression>parent).expression.kind === Syntax.ImportKeyword) return stringType;
      case Syntax.NewExpression:
        return getContextualTypeForArgument(<CallExpression | NewExpression>parent, node);
      case Syntax.TypeAssertionExpression:
      case Syntax.AsExpression:
        return qc.is.constTypeReference((<AssertionExpression>parent).type) ? undefined : getTypeFromTypeNode((<AssertionExpression>parent).type);
      case Syntax.BinaryExpression:
        return getContextualTypeForBinaryOperand(node, contextFlags);
      case Syntax.PropertyAssignment:
      case Syntax.ShorthandPropertyAssignment:
        return getContextualTypeForObjectLiteralElement(<PropertyAssignment | ShorthandPropertyAssignment>parent, contextFlags);
      case Syntax.SpreadAssignment:
        return getApparentTypeOfContextualType(parent.parent as ObjectLiteralExpression, contextFlags);
      case Syntax.ArrayLiteralExpression: {
        const arrayLiteral = <ArrayLiteralExpression>parent;
        const type = getApparentTypeOfContextualType(arrayLiteral, contextFlags);
        return getContextualTypeForElementExpression(type, indexOfNode(arrayLiteral.elements, node));
      }
      case Syntax.ConditionalExpression:
        return getContextualTypeForConditionalOperand(node, contextFlags);
      case Syntax.TemplateSpan:
        assert(parent.parent.kind === Syntax.TemplateExpression);
        return getContextualTypeForSubstitutionExpression(<TemplateExpression>parent.parent, node);
      case Syntax.ParenthesizedExpression: {
        const tag = isInJSFile(parent) ? qc.getDoc.typeTag(parent) : undefined;
        return tag ? getTypeFromTypeNode(tag.typeExpression.type) : getContextualType(<ParenthesizedExpression>parent, contextFlags);
      }
      case Syntax.JsxExpression:
        return getContextualTypeForJsxExpression(<JsxExpression>parent);
      case Syntax.JsxAttribute:
      case Syntax.JsxSpreadAttribute:
        return getContextualTypeForJsxAttribute(<JsxAttribute | JsxSpreadAttribute>parent);
      case Syntax.JsxOpeningElement:
      case Syntax.JsxSelfClosingElement:
        return getContextualJsxElementAttributesType(<JsxOpeningLikeElement>parent, contextFlags);
    }
    return;
  }
  function getInferenceContext(node: Node) {
    const ancestor = Node.findAncestor(node, (n) => !!n.inferenceContext);
    return ancestor && ancestor.inferenceContext!;
  }
  function getContextualJsxElementAttributesType(node: JsxOpeningLikeElement, contextFlags?: ContextFlags) {
    if (qc.is.kind(JsxOpeningElement, node) && node.parent.contextualType && contextFlags !== ContextFlags.Completions) return node.parent.contextualType;
    return getContextualTypeForArgumentAtIndex(node, 0);
  }
  function getEffectiveFirstArgumentForJsxSignature(signature: Signature, node: JsxOpeningLikeElement) {
    return getJsxReferenceKind(node) !== JsxReferenceKind.Component ? getJsxPropsTypeFromCallSignature(signature, node) : getJsxPropsTypeFromClassType(signature, node);
  }
  function getJsxPropsTypeFromCallSignature(sig: Signature, context: JsxOpeningLikeElement) {
    let propsType = getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType);
    propsType = getJsxManagedAttributesFromLocatedAttributes(context, getJsxNamespaceAt(context), propsType);
    const intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes, context);
    if (intrinsicAttribs !== errorType) propsType = intersectTypes(intrinsicAttribs, propsType);
    return propsType;
  }
  function getJsxPropsTypeForSignatureFromMember(sig: Signature, forcedLookupLocation: __String) {
    if (sig.unionSignatures) {
      const results: Type[] = [];
      for (const signature of sig.unionSignatures) {
        const instance = getReturnTypeOfSignature(signature);
        if (isTypeAny(instance)) return instance;
        const propType = getTypeOfPropertyOfType(instance, forcedLookupLocation);
        if (!propType) return;
        results.push(propType);
      }
      return getIntersectionType(results);
    }
    const instanceType = getReturnTypeOfSignature(sig);
    return isTypeAny(instanceType) ? instanceType : getTypeOfPropertyOfType(instanceType, forcedLookupLocation);
  }
  function getStaticTypeOfReferencedJsxConstructor(context: JsxOpeningLikeElement) {
    if (isJsxIntrinsicIdentifier(context.tagName)) {
      const result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context);
      const fakeSignature = createSignatureForJSXIntrinsic(context, result);
      return getOrCreateTypeFromSignature(fakeSignature);
    }
    const tagType = checkExpressionCached(context.tagName);
    if (tagType.flags & TypeFlags.StringLiteral) {
      const result = getIntrinsicAttributesTypeFromStringLiteralType(tagType as StringLiteralType, context);
      if (!result) return errorType;
      const fakeSignature = createSignatureForJSXIntrinsic(context, result);
      return getOrCreateTypeFromSignature(fakeSignature);
    }
    return tagType;
  }
  function getJsxManagedAttributesFromLocatedAttributes(context: JsxOpeningLikeElement, ns: Symbol, attributesType: Type) {
    const managedSym = getJsxLibraryManagedAttributes(ns);
    if (managedSym) {
      const declaredManagedType = getDeclaredTypeOfSymbol(managedSym);
      const ctorType = getStaticTypeOfReferencedJsxConstructor(context);
      if (length((declaredManagedType as GenericType).typeParameters) >= 2) {
        const args = fillMissingTypeArguments([ctorType, attributesType], (declaredManagedType as GenericType).typeParameters, 2, isInJSFile(context));
        return createTypeReference(declaredManagedType as GenericType, args);
      } else if (length(declaredManagedType.aliasTypeArguments) >= 2) {
        const args = fillMissingTypeArguments([ctorType, attributesType], declaredManagedType.aliasTypeArguments, 2, isInJSFile(context));
        return getTypeAliasInstantiation(declaredManagedType.aliasSymbol!, args);
      }
    }
    return attributesType;
  }
  function getJsxPropsTypeFromClassType(sig: Signature, context: JsxOpeningLikeElement) {
    const ns = getJsxNamespaceAt(context);
    const forcedLookupLocation = getJsxElementPropertiesName(ns);
    let attributesType =
      forcedLookupLocation === undefined
        ? getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)
        : forcedLookupLocation === ''
        ? getReturnTypeOfSignature(sig)
        : getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation);
    if (!attributesType) {
      if (!!forcedLookupLocation && !!length(context.attributes.properties))
        error(context, qd.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, syntax.get.unescUnderscores(forcedLookupLocation));
      return unknownType;
    }
    attributesType = getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType);
    if (isTypeAny(attributesType)) return attributesType;
    else {
      let apparentAttributesType = attributesType;
      const intrinsicClassAttribs = getJsxType(JsxNames.IntrinsicClassAttributes, context);
      if (intrinsicClassAttribs !== errorType) {
        const typeParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol);
        const hostClassType = getReturnTypeOfSignature(sig);
        apparentAttributesType = intersectTypes(
          typeParams
            ? createTypeReference(<GenericType>intrinsicClassAttribs, fillMissingTypeArguments([hostClassType], typeParams, getMinTypeArgumentCount(typeParams), isInJSFile(context)))
            : intrinsicClassAttribs,
          apparentAttributesType
        );
      }
      const intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes, context);
      if (intrinsicAttribs !== errorType) apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType);
      return apparentAttributesType;
    }
  }
  function getContextualCallSignature(type: Type, node: SignatureDeclaration): Signature | undefined {
    const signatures = getSignaturesOfType(type, SignatureKind.Call);
    if (signatures.length === 1) {
      const signature = signatures[0];
      if (!isAritySmaller(signature, node)) return signature;
    }
  }
  function isAritySmaller(signature: Signature, target: SignatureDeclaration) {
    let targetParameterCount = 0;
    for (; targetParameterCount < target.parameters.length; targetParameterCount++) {
      const param = target.parameters[targetParameterCount];
      if (param.initializer || param.questionToken || param.dot3Token || isJSDocOptionalParameter(param)) break;
    }
    if (target.parameters.length && parameterIsThsyntax.is.keyword(target.parameters[0])) targetParameterCount--;
    return !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount;
  }
  function isFunctionExpressionOrArrowFunction(node: Node): node is FunctionExpression | ArrowFunction {
    return node.kind === Syntax.FunctionExpression || node.kind === Syntax.ArrowFunction;
  }
  function getContextualSignatureForFunctionLikeDeclaration(node: FunctionLikeDeclaration): Signature | undefined {
    return isFunctionExpressionOrArrowFunction(node) || qc.is.objectLiteralMethod(node) ? getContextualSignature(<FunctionExpression>node) : undefined;
  }
  function getContextualSignature(node: FunctionExpression | ArrowFunction | MethodDeclaration): Signature | undefined {
    assert(node.kind !== Syntax.MethodDeclaration || qc.is.objectLiteralMethod(node));
    const typeTagSignature = getSignatureOfTypeTag(node);
    if (typeTagSignature) return typeTagSignature;
    const type = getApparentTypeOfContextualType(node, ContextFlags.Signature);
    if (!type) return;
    if (!(type.flags & TypeFlags.Union)) return getContextualCallSignature(type, node);
    let signatureList: Signature[] | undefined;
    const types = (<UnionType>type).types;
    for (const current of types) {
      const signature = getContextualCallSignature(current, node);
      if (signature) {
        if (!signatureList) signatureList = [signature];
        else if (!compareSignaturesIdentical(signatureList[0], signature, true, compareTypesIdentical)) {
          return;
        } else {
          signatureList.push(signature);
        }
      }
    }
    if (signatureList) return signatureList.length === 1 ? signatureList[0] : createUnionSignature(signatureList[0], signatureList);
  }
  function checkSpreadExpression(node: SpreadElement, checkMode?: CheckMode): Type {
    const arrayOrIterableType = checkExpression(node.expression, checkMode);
    return checkIteratedTypeOrElementType(IterationUse.Spread, arrayOrIterableType, undefinedType, node.expression);
  }
  function hasDefaultValue(node: BindingElement | Expression): boolean {
    return (
      (node.kind === Syntax.BindingElement && !!(<BindingElement>node).initializer) || (node.kind === Syntax.BinaryExpression && (<BinaryExpression>node).operatorToken.kind === Syntax.EqualsToken)
    );
  }
  function checkArrayLiteral(node: ArrayLiteralExpression, checkMode: CheckMode | undefined, forceTuple: boolean | undefined): Type {
    const elements = node.elements;
    const elementCount = elements.length;
    const elementTypes: Type[] = [];
    let hasEndingSpreadElement = false;
    let hasNonEndingSpreadElement = false;
    const contextualType = getApparentTypeOfContextualType(node);
    const inDestructuringPattern = isAssignmentTarget(node);
    const inConstContext = isConstContext(node);
    for (let i = 0; i < elementCount; i++) {
      const e = elements[i];
      const spread = e.kind === Syntax.SpreadElement && (<SpreadElement>e).expression;
      const spreadType = spread && checkExpression(spread, checkMode, forceTuple);
      if (spreadType && isTupleType(spreadType)) {
        elementTypes.push(...getTypeArguments(spreadType));
        if (spreadType.target.hasRestElement) {
          if (i === elementCount - 1) hasEndingSpreadElement = true;
          else hasNonEndingSpreadElement = true;
        }
      } else {
        if (inDestructuringPattern && spreadType) {
          const restElementType = getIndexTypeOfType(spreadType, IndexKind.Number) || getIteratedTypeOrElementType(IterationUse.Destructuring, spreadType, undefinedType, undefined, false);
          if (restElementType) elementTypes.push(restElementType);
        } else {
          const elementContextualType = getContextualTypeForElementExpression(contextualType, elementTypes.length);
          const type = checkExpressionForMutableLocation(e, checkMode, elementContextualType, forceTuple);
          elementTypes.push(type);
        }
        if (spread) {
          if (i === elementCount - 1) hasEndingSpreadElement = true;
          else hasNonEndingSpreadElement = true;
        }
      }
    }
    if (!hasNonEndingSpreadElement) {
      const minLength = elementTypes.length - (hasEndingSpreadElement ? 1 : 0);
      let tupleResult;
      if (inDestructuringPattern && minLength > 0) {
        const type = cloneTypeReference(<TypeReference>createTupleType(elementTypes, minLength, hasEndingSpreadElement));
        type.pattern = node;
        return type;
      } else if ((tupleResult = getArrayLiteralTupleTypeIfApplicable(elementTypes, contextualType, hasEndingSpreadElement, elementTypes.length, inConstContext))) {
        return createArrayLiteralType(tupleResult);
      } else if (forceTuple) {
        return createArrayLiteralType(createTupleType(elementTypes, minLength, hasEndingSpreadElement));
      }
    }
    return createArrayLiteralType(
      createArrayType(elementTypes.length ? getUnionType(elementTypes, UnionReduction.Subtype) : strictNullChecks ? implicitNeverType : undefinedWideningType, inConstContext)
    );
  }
  function createArrayLiteralType(type: ObjectType) {
    if (!(getObjectFlags(type) & ObjectFlags.Reference)) return type;
    let literalType = (<TypeReference>type).literalType;
    if (!literalType) {
      literalType = (<TypeReference>type).literalType = cloneTypeReference(<TypeReference>type);
      literalType.objectFlags |= ObjectFlags.ArrayLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
    }
    return literalType;
  }
  function getArrayLiteralTupleTypeIfApplicable(elementTypes: Type[], contextualType: Type | undefined, hasRestElement: boolean, elementCount = elementTypes.length, readonly = false) {
    if (readonly || (contextualType && forEachType(contextualType, isTupleLikeType))) return createTupleType(elementTypes, elementCount - (hasRestElement ? 1 : 0), hasRestElement, readonly);
    return;
  }
  function isNumericName(name: DeclarationName): boolean {
    switch (name.kind) {
      case Syntax.ComputedPropertyName:
        return isNumericComputedName(name);
      case Syntax.Identifier:
        return NumericLiteral.name(name.escapedText);
      case Syntax.NumericLiteral:
      case Syntax.StringLiteral:
        return NumericLiteral.name(name.text);
      default:
        return false;
    }
  }
  function isNumericComputedName(name: ComputedPropertyName): boolean {
    return isTypeAssignableToKind(checkComputedPropertyName(name), TypeFlags.NumberLike);
  }
  function isInfinityOrNaNString(name: string | __String): boolean {
    return name === 'Infinity' || name === '-Infinity' || name === 'NaN';
  }
  function checkComputedPropertyName(node: ComputedPropertyName): Type {
    const links = getNodeLinks(node.expression);
    if (!links.resolvedType) {
      links.resolvedType = checkExpression(node.expression);
      if (
        links.resolvedType.flags & TypeFlags.Nullable ||
        (!isTypeAssignableToKind(links.resolvedType, TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike) && !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType))
      ) {
        error(node, qd.A_computed_property_name_must_be_of_type_string_number_symbol_or_any);
      } else {
        checkThatExpressionIsProperSymbolReference(node.expression, links.resolvedType, true);
      }
    }
    return links.resolvedType;
  }
  function getObjectLiteralIndexInfo(node: ObjectLiteralExpression, offset: number, properties: Symbol[], kind: IndexKind): IndexInfo {
    const propTypes: Type[] = [];
    for (let i = 0; i < properties.length; i++) {
      if (kind === IndexKind.String || isNumericName(node.properties[i + offset].name!)) propTypes.push(getTypeOfSymbol(properties[i]));
    }
    const unionType = propTypes.length ? getUnionType(propTypes, UnionReduction.Subtype) : undefinedType;
    return createIndexInfo(unionType, isConstContext(node));
  }
  function checkObjectLiteral(node: ObjectLiteralExpression, checkMode?: CheckMode): Type {
    const inDestructuringPattern = isAssignmentTarget(node);
    checkGrammarObjectLiteralExpression(node, inDestructuringPattern);
    const allPropertiesTable = strictNullChecks ? new SymbolTable() : undefined;
    let propertiesTable = new SymbolTable();
    let propertiesArray: Symbol[] = [];
    let spread: Type = emptyObjectType;
    const contextualType = getApparentTypeOfContextualType(node);
    const contextualTypeHasPattern =
      contextualType && contextualType.pattern && (contextualType.pattern.kind === Syntax.ObjectBindingPattern || contextualType.pattern.kind === Syntax.ObjectLiteralExpression);
    const inConstContext = isConstContext(node);
    const checkFlags = inConstContext ? CheckFlags.Readonly : 0;
    const isInJavascript = isInJSFile(node) && !isInJsonFile(node);
    const enumTag = qc.getDoc.enumTag(node);
    const isJSObjectLiteral = !contextualType && isInJavascript && !enumTag;
    let objectFlags: ObjectFlags = freshObjectLiteralFlag;
    let patternWithComputedProperties = false;
    let hasComputedStringProperty = false;
    let hasComputedNumberProperty = false;
    for (const elem of node.properties) {
      if (elem.name && qc.is.kind(ComputedPropertyName, elem.name) && !isWellKnownSymbolSyntactically(elem.name)) checkComputedPropertyName(elem.name);
    }
    let offset = 0;
    for (let i = 0; i < node.properties.length; i++) {
      const memberDecl = node.properties[i];
      let member = getSymbolOfNode(memberDecl);
      const computedNameType =
        memberDecl.name && memberDecl.name.kind === Syntax.ComputedPropertyName && !isWellKnownSymbolSyntactically(memberDecl.name.expression) ? checkComputedPropertyName(memberDecl.name) : undefined;
      if (memberDecl.kind === Syntax.PropertyAssignment || memberDecl.kind === Syntax.ShorthandPropertyAssignment || qc.is.objectLiteralMethod(memberDecl)) {
        let type =
          memberDecl.kind === Syntax.PropertyAssignment
            ? checkPropertyAssignment(memberDecl, checkMode)
            : memberDecl.kind === Syntax.ShorthandPropertyAssignment
            ? checkExpressionForMutableLocation(memberDecl.name, checkMode)
            : checkObjectLiteralMethod(memberDecl, checkMode);
        if (isInJavascript) {
          const jsDocType = getTypeForDeclarationFromJSDocComment(memberDecl);
          if (jsDocType) {
            checkTypeAssignableTo(type, jsDocType, memberDecl);
            type = jsDocType;
          } else if (enumTag && enumTag.typeExpression) {
            checkTypeAssignableTo(type, getTypeFromTypeNode(enumTag.typeExpression), memberDecl);
          }
        }
        objectFlags |= getObjectFlags(type) & ObjectFlags.PropagatingFlags;
        const nameType = computedNameType && isTypeUsableAsPropertyName(computedNameType) ? computedNameType : undefined;
        const prop = nameType
          ? new QSymbol(SymbolFlags.Property | member.flags, getPropertyNameFromType(nameType), checkFlags | CheckFlags.Late)
          : new QSymbol(SymbolFlags.Property | member.flags, member.escName, checkFlags);
        if (nameType) prop.nameType = nameType;
        if (inDestructuringPattern) {
          const isOptional =
            (memberDecl.kind === Syntax.PropertyAssignment && hasDefaultValue(memberDecl.initializer)) ||
            (memberDecl.kind === Syntax.ShorthandPropertyAssignment && memberDecl.objectAssignmentInitializer);
          if (isOptional) prop.flags |= SymbolFlags.Optional;
        } else if (contextualTypeHasPattern && !(getObjectFlags(contextualType!) & ObjectFlags.ObjectLiteralPatternWithComputedProperties)) {
          const impliedProp = getPropertyOfType(contextualType!, member.escName);
          if (impliedProp) prop.flags |= impliedProp.flags & SymbolFlags.Optional;
          else if (!compilerOptions.suppressExcessPropertyErrors && !getIndexInfoOfType(contextualType!, IndexKind.String)) {
            error(memberDecl.name, qd.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, member.symbolToString(), typeToString(contextualType!));
          }
        }
        prop.declarations = member.declarations;
        prop.parent = member.parent;
        if (member.valueDeclaration) prop.valueDeclaration = member.valueDeclaration;
        prop.type = type;
        prop.target = member;
        member = prop;
        allPropertiesTable?.set(prop.escName, prop);
      } else if (memberDecl.kind === Syntax.SpreadAssignment) {
        if (propertiesArray.length > 0) {
          spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
          propertiesArray = [];
          propertiesTable = new SymbolTable();
          hasComputedStringProperty = false;
          hasComputedNumberProperty = false;
        }
        const type = getReducedType(checkExpression(memberDecl.expression));
        if (!isValidSpreadType(type)) {
          error(memberDecl, qd.Spread_types_may_only_be_created_from_object_types);
          return errorType;
        }
        if (allPropertiesTable) checkSpreadPropOverrides(type, allPropertiesTable, memberDecl);
        spread = getSpreadType(spread, type, node.symbol, objectFlags, inConstContext);
        offset = i + 1;
        continue;
      } else {
        assert(memberDecl.kind === Syntax.GetAccessor || memberDecl.kind === Syntax.SetAccessor);
        checkNodeDeferred(memberDecl);
      }
      if (computedNameType && !(computedNameType.flags & TypeFlags.StringOrNumberLiteralOrUnique)) {
        if (isTypeAssignableTo(computedNameType, stringNumberSymbolType)) {
          if (isTypeAssignableTo(computedNameType, numberType)) hasComputedNumberProperty = true;
          else {
            hasComputedStringProperty = true;
          }
          if (inDestructuringPattern) patternWithComputedProperties = true;
        }
      } else {
        propertiesTable.set(member.escName, member);
      }
      propertiesArray.push(member);
    }
    if (contextualTypeHasPattern && node.parent.kind !== Syntax.SpreadAssignment) {
      for (const prop of getPropertiesOfType(contextualType!)) {
        if (!propertiesTable.get(prop.escName) && !getPropertyOfType(spread, prop.escName)) {
          if (!(prop.flags & SymbolFlags.Optional))
            error(prop.valueDeclaration || (<TransientSymbol>prop).bindingElement, qd.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);
          propertiesTable.set(prop.escName, prop);
          propertiesArray.push(prop);
        }
      }
    }
    if (spread !== emptyObjectType) {
      if (propertiesArray.length > 0) {
        spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
        propertiesArray = [];
        propertiesTable = new SymbolTable();
        hasComputedStringProperty = false;
        hasComputedNumberProperty = false;
      }
      return mapType(spread, (t) => (t === emptyObjectType ? createObjectLiteralType() : t));
    }
    return createObjectLiteralType();
    function createObjectLiteralType() {
      const stringIndexInfo = hasComputedStringProperty ? getObjectLiteralIndexInfo(node, offset, propertiesArray, IndexKind.String) : undefined;
      const numberIndexInfo = hasComputedNumberProperty ? getObjectLiteralIndexInfo(node, offset, propertiesArray, IndexKind.Number) : undefined;
      const result = createAnonymousType(node.symbol, propertiesTable, empty, empty, stringIndexInfo, numberIndexInfo);
      result.objectFlags |= objectFlags | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
      if (isJSObjectLiteral) result.objectFlags |= ObjectFlags.JSLiteral;
      if (patternWithComputedProperties) result.objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties;
      if (inDestructuringPattern) result.pattern = node;
      return result;
    }
  }
  function isValidSpreadType(type: Type): boolean {
    if (type.flags & TypeFlags.Instantiable) {
      const constraint = getBaseConstraintOfType(type);
      if (constraint !== undefined) return isValidSpreadType(constraint);
    }
    return !!(
      type.flags & (TypeFlags.Any | TypeFlags.NonPrimitive | TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ||
      (getFalsyFlags(type) & TypeFlags.DefinitelyFalsy && isValidSpreadType(removeDefinitelyFalsyTypes(type))) ||
      (type.flags & TypeFlags.UnionOrIntersection && every((<UnionOrIntersectionType>type).types, isValidSpreadType))
    );
  }
  function checkJsxSelfClosingElementDeferred(node: JsxSelfClosingElement) {
    checkJsxOpeningLikeElementOrOpeningFragment(node);
    resolveUntypedCall(node);
  }
  function checkJsxSelfClosingElement(node: JsxSelfClosingElement, _checkMode: CheckMode | undefined): Type {
    checkNodeDeferred(node);
    return getJsxElementTypeAt(node) || anyType;
  }
  function checkJsxElementDeferred(node: JsxElement) {
    checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement);
    if (isJsxIntrinsicIdentifier(node.closingElement.tagName)) getIntrinsicTagSymbol(node.closingElement);
    else {
      checkExpression(node.closingElement.tagName);
    }
    checkJsxChildren(node);
  }
  function checkJsxElement(node: JsxElement, _checkMode: CheckMode | undefined): Type {
    checkNodeDeferred(node);
    return getJsxElementTypeAt(node) || anyType;
  }
  function checkJsxFragment(node: JsxFragment): Type {
    checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment);
    if (compilerOptions.jsx === JsxEmit.React && (compilerOptions.jsxFactory || qc.get.sourceFileOf(node).pragmas.has('jsx')))
      error(node, compilerOptions.jsxFactory ? qd.JSX_fragment_is_not_supported_when_using_jsxFactory : qd.JSX_fragment_is_not_supported_when_using_an_inline_JSX_factory_pragma);
    checkJsxChildren(node);
    return getJsxElementTypeAt(node) || anyType;
  }
  function isUnhyphenatedJsxName(name: string | __String) {
    return !stringContains(name as string, '-');
  }
  function isJsxIntrinsicIdentifier(tagName: JsxTagNameExpression): boolean {
    return tagName.kind === Syntax.Identifier && isIntrinsicJsxName(tagName.escapedText);
  }
  function checkJsxAttribute(node: JsxAttribute, checkMode?: CheckMode) {
    return node.initializer ? checkExpressionForMutableLocation(node.initializer, checkMode) : trueType;
  }
  function createJsxAttributesTypeFromAttributesProperty(openingLikeElement: JsxOpeningLikeElement, checkMode: CheckMode | undefined) {
    const attributes = openingLikeElement.attributes;
    const allAttributesTable = strictNullChecks ? new SymbolTable() : undefined;
    let attributesTable = new SymbolTable();
    let spread: Type = emptyJsxObjectType;
    let hasSpreadAnyType = false;
    let typeToIntersect: Type | undefined;
    let explicitlySpecifyChildrenAttribute = false;
    let objectFlags: ObjectFlags = ObjectFlags.JsxAttributes;
    const jsxChildrenPropertyName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(openingLikeElement));
    for (const attributeDecl of attributes.properties) {
      const member = attributeDecl.symbol;
      if (qc.is.kind(JsxAttribute, attributeDecl)) {
        const exprType = checkJsxAttribute(attributeDecl, checkMode);
        objectFlags |= getObjectFlags(exprType) & ObjectFlags.PropagatingFlags;
        const attributeSymbol = new QSymbol(SymbolFlags.Property | SymbolFlags.Transient | member.flags, member.escName);
        attributeSymbol.declarations = member.declarations;
        attributeSymbol.parent = member.parent;
        if (member.valueDeclaration) attributeSymbol.valueDeclaration = member.valueDeclaration;
        attributeSymbol.type = exprType;
        attributeSymbol.target = member;
        attributesTable.set(attributeSymbol.escName, attributeSymbol);
        allAttributesTable?.set(attributeSymbol.escName, attributeSymbol);
        if (attributeDecl.name.escapedText === jsxChildrenPropertyName) explicitlySpecifyChildrenAttribute = true;
      } else {
        assert(attributeDecl.kind === Syntax.JsxSpreadAttribute);
        if (attributesTable.size > 0) {
          spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, false);
          attributesTable = new SymbolTable();
        }
        const exprType = getReducedType(checkExpressionCached(attributeDecl.expression, checkMode));
        if (isTypeAny(exprType)) hasSpreadAnyType = true;
        if (isValidSpreadType(exprType)) {
          spread = getSpreadType(spread, exprType, attributes.symbol, objectFlags, false);
          if (allAttributesTable) checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl);
        } else {
          typeToIntersect = typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType;
        }
      }
    }
    if (!hasSpreadAnyType) {
      if (attributesTable.size > 0) spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, false);
    }
    const parent = openingLikeElement.parent.kind === Syntax.JsxElement ? (openingLikeElement.parent as JsxElement) : undefined;
    if (parent && parent.openingElement === openingLikeElement && parent.children.length > 0) {
      const childrenTypes: Type[] = checkJsxChildren(parent, checkMode);
      if (!hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName !== '') {
        if (explicitlySpecifyChildrenAttribute) error(attributes, qd._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, syntax.get.unescUnderscores(jsxChildrenPropertyName));
        const contextualType = getApparentTypeOfContextualType(openingLikeElement.attributes);
        const childrenContextualType = contextualType && getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName);
        const childrenPropSymbol = new QSymbol(SymbolFlags.Property | SymbolFlags.Transient, jsxChildrenPropertyName);
        childrenPropSymbol.type =
          childrenTypes.length === 1 ? childrenTypes[0] : getArrayLiteralTupleTypeIfApplicable(childrenTypes, childrenContextualType, false) || createArrayType(getUnionType(childrenTypes));
        childrenPropSymbol.valueDeclaration = PropertySignature.create(undefined, syntax.get.unescUnderscores(jsxChildrenPropertyName), undefined, undefined, undefined);
        childrenPropSymbol.valueDeclaration.parent = attributes;
        childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol;
        const childPropMap = new SymbolTable();
        childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol);
        spread = getSpreadType(spread, createAnonymousType(attributes.symbol, childPropMap, empty, empty, undefined), attributes.symbol, objectFlags, false);
      }
    }
    if (hasSpreadAnyType) return anyType;
    if (typeToIntersect && spread !== emptyJsxObjectType) return getIntersectionType([typeToIntersect, spread]);
    return typeToIntersect || (spread === emptyJsxObjectType ? createJsxAttributesType() : spread);
    function createJsxAttributesType() {
      objectFlags |= freshObjectLiteralFlag;
      const result = createAnonymousType(attributes.symbol, attributesTable, empty, empty, undefined);
      result.objectFlags |= objectFlags | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral;
      return result;
    }
  }
  function checkJsxChildren(node: JsxElement | JsxFragment, checkMode?: CheckMode) {
    const childrenTypes: Type[] = [];
    for (const child of node.children) {
      if (child.kind === Syntax.JsxText) {
        if (!child.onlyTriviaWhitespaces) childrenTypes.push(stringType);
      } else {
        childrenTypes.push(checkExpressionForMutableLocation(child, checkMode));
      }
    }
    return childrenTypes;
  }
  function checkSpreadPropOverrides(type: Type, props: SymbolTable, spread: SpreadAssignment | JsxSpreadAttribute) {
    for (const right of getPropertiesOfType(type)) {
      const left = props.get(right.escName);
      const rightType = getTypeOfSymbol(right);
      if (left && !maybeTypeOfKind(rightType, TypeFlags.Nullable) && !(maybeTypeOfKind(rightType, TypeFlags.AnyOrUnknown) && right.flags & SymbolFlags.Optional)) {
        const diagnostic = error(left.valueDeclaration, qd._0_is_specified_more_than_once_so_this_usage_will_be_overwritten, syntax.get.unescUnderscores(left.escName));
        addRelatedInfo(diagnostic, createDiagnosticForNode(spread, qd.This_spread_always_overwrites_this_property));
      }
    }
  }
  function checkJsxAttributes(node: JsxAttributes, checkMode: CheckMode | undefined) {
    return createJsxAttributesTypeFromAttributesProperty(node.parent, checkMode);
  }
  function getJsxType(name: __String, location: Node | undefined) {
    const namespace = getJsxNamespaceAt(location);
    const exports = namespace && namespace.getExportsOfSymbol();
    const typeSymbol = exports && getSymbol(exports, name, SymbolFlags.Type);
    return typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType;
  }
  function getIntrinsicTagSymbol(node: JsxOpeningLikeElement | JsxClosingElement): Symbol {
    const links = getNodeLinks(node);
    if (!links.resolvedSymbol) {
      const intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements, node);
      if (intrinsicElementsType !== errorType) {
        if (!qc.is.kind(Identifier, node.tagName)) return fail();
        const intrinsicProp = getPropertyOfType(intrinsicElementsType, node.tagName.escapedText);
        if (intrinsicProp) {
          links.jsxFlags |= JsxFlags.IntrinsicNamedElement;
          return (links.resolvedSymbol = intrinsicProp);
        }
        const indexSignatureType = getIndexTypeOfType(intrinsicElementsType, IndexKind.String);
        if (indexSignatureType) {
          links.jsxFlags |= JsxFlags.IntrinsicIndexedElement;
          return (links.resolvedSymbol = intrinsicElementsType.symbol);
        }
        error(node, qd.Property_0_does_not_exist_on_type_1, idText(node.tagName), 'JSX.' + JsxNames.IntrinsicElements);
        return (links.resolvedSymbol = unknownSymbol);
      } else {
        if (noImplicitAny) error(node, qd.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, syntax.get.unescUnderscores(JsxNames.IntrinsicElements));
        return (links.resolvedSymbol = unknownSymbol);
      }
    }
    return links.resolvedSymbol;
  }
  function getJsxNamespaceAt(location: Node | undefined): Symbol {
    const links = location && getNodeLinks(location);
    if (links && links.jsxNamespace) return links.jsxNamespace;
    if (!links || links.jsxNamespace !== false) {
      const namespaceName = getJsxNamespace(location);
      const resolvedNamespace = resolveName(location, namespaceName, SymbolFlags.Namespace, undefined, namespaceName, false);
      if (resolvedNamespace) {
        const s = getSymbol(resolvedNamespace.resolveSymbol().getExportsOfSymbol(), JsxNames.JSX, SymbolFlags.Namespace);
        const candidate = resolveSymbol(s);
        if (candidate) {
          if (links) links.jsxNamespace = candidate;
          return candidate;
        }
        if (links) links.jsxNamespace = false;
      }
    }
    return getGlobalSymbol(JsxNames.JSX, SymbolFlags.Namespace, undefined)!;
  }
  function getNameFromJsxElementAttributesContainer(nameOfAttribPropContainer: __String, jsxNamespace: Symbol): __String | undefined {
    const jsxElementAttribPropInterfaceSym = jsxNamespace && getSymbol(jsxNamespace.exports!, nameOfAttribPropContainer, SymbolFlags.Type);
    const jsxElementAttribPropInterfaceType = jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym);
    const propertiesOfJsxElementAttribPropInterface = jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType);
    if (propertiesOfJsxElementAttribPropInterface) {
      if (propertiesOfJsxElementAttribPropInterface.length === 0) return '' as __String;
      else if (propertiesOfJsxElementAttribPropInterface.length === 1) return propertiesOfJsxElementAttribPropInterface[0].escName;
      else if (propertiesOfJsxElementAttribPropInterface.length > 1) {
        error(jsxElementAttribPropInterfaceSym!.declarations[0], qd.The_global_type_JSX_0_may_not_have_more_than_one_property, syntax.get.unescUnderscores(nameOfAttribPropContainer));
      }
    }
    return;
  }
  function getJsxLibraryManagedAttributes(jsxNamespace: Symbol) {
    return jsxNamespace && getSymbol(jsxNamespace.exports!, JsxNames.LibraryManagedAttributes, SymbolFlags.Type);
  }
  function getJsxElementPropertiesName(jsxNamespace: Symbol) {
    return getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer, jsxNamespace);
  }
  function getJsxElementChildrenPropertyName(jsxNamespace: Symbol): __String | undefined {
    return getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer, jsxNamespace);
  }
  function getUninstantiatedJsxSignaturesOfType(elementType: Type, caller: JsxOpeningLikeElement): readonly Signature[] {
    if (elementType.flags & TypeFlags.String) return [anySignature];
    else if (elementType.flags & TypeFlags.StringLiteral) {
      const intrinsicType = getIntrinsicAttributesTypeFromStringLiteralType(elementType as StringLiteralType, caller);
      if (!intrinsicType) {
        error(caller, qd.Property_0_does_not_exist_on_type_1, (elementType as StringLiteralType).value, 'JSX.' + JsxNames.IntrinsicElements);
        return empty;
      } else {
        const fakeSignature = createSignatureForJSXIntrinsic(caller, intrinsicType);
        return [fakeSignature];
      }
    }
    const apparentElemType = getApparentType(elementType);
    let signatures = getSignaturesOfType(apparentElemType, SignatureKind.Construct);
    if (signatures.length === 0) signatures = getSignaturesOfType(apparentElemType, SignatureKind.Call);
    if (signatures.length === 0 && apparentElemType.flags & TypeFlags.Union)
      signatures = getUnionSignatures(map((apparentElemType as UnionType).types, (t) => getUninstantiatedJsxSignaturesOfType(t, caller)));
    return signatures;
  }
  function getIntrinsicAttributesTypeFromStringLiteralType(type: StringLiteralType, location: Node): Type | undefined {
    const intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements, location);
    if (intrinsicElementsType !== errorType) {
      const stringLiteralTypeName = type.value;
      const intrinsicProp = getPropertyOfType(intrinsicElementsType, syntax.get.escUnderscores(stringLiteralTypeName));
      if (intrinsicProp) return getTypeOfSymbol(intrinsicProp);
      const indexSignatureType = getIndexTypeOfType(intrinsicElementsType, IndexKind.String);
      if (indexSignatureType) return indexSignatureType;
      return;
    }
    return anyType;
  }
  function checkJsxReturnAssignableToAppropriateBound(refKind: JsxReferenceKind, elemInstanceType: Type, openingLikeElement: JsxOpeningLikeElement) {
    if (refKind === JsxReferenceKind.Function) {
      const sfcReturnConstraint = getJsxStatelessElementTypeAt(openingLikeElement);
      if (sfcReturnConstraint)
        checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, assignableRelation, openingLikeElement.tagName, qd.Its_return_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
    } else if (refKind === JsxReferenceKind.Component) {
      const classConstraint = getJsxElementClassTypeAt(openingLikeElement);
      if (classConstraint)
        checkTypeRelatedTo(elemInstanceType, classConstraint, assignableRelation, openingLikeElement.tagName, qd.Its_instance_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
    } else {
      const sfcReturnConstraint = getJsxStatelessElementTypeAt(openingLikeElement);
      const classConstraint = getJsxElementClassTypeAt(openingLikeElement);
      if (!sfcReturnConstraint || !classConstraint) return;
      const combined = getUnionType([sfcReturnConstraint, classConstraint]);
      checkTypeRelatedTo(elemInstanceType, combined, assignableRelation, openingLikeElement.tagName, qd.Its_element_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
    }
    function generateInitialErrorChain(): DiagnosticMessageChain {
      const componentName = qc.get.textOf(openingLikeElement.tagName);
      return chainDiagnosticMessages(undefined, qd._0_cannot_be_used_as_a_JSX_component, componentName);
    }
  }
  function getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node: JsxOpeningLikeElement): Type {
    assert(isJsxIntrinsicIdentifier(node.tagName));
    const links = getNodeLinks(node);
    if (!links.resolvedJsxElementAttributesType) {
      const symbol = getIntrinsicTagSymbol(node);
      if (links.jsxFlags & JsxFlags.IntrinsicNamedElement) return (links.resolvedJsxElementAttributesType = this.getTypeOfSymbol());
      else if (links.jsxFlags & JsxFlags.IntrinsicIndexedElement) return (links.resolvedJsxElementAttributesType = getIndexTypeOfType(getDeclaredTypeOfSymbol(symbol), IndexKind.String)!);
      return (links.resolvedJsxElementAttributesType = errorType);
    }
    return links.resolvedJsxElementAttributesType;
  }
  function getJsxElementClassTypeAt(location: Node): Type | undefined {
    const type = getJsxType(JsxNames.ElementClass, location);
    if (type === errorType) return;
    return type;
  }
  function getJsxElementTypeAt(location: Node): Type {
    return getJsxType(JsxNames.Element, location);
  }
  function getJsxStatelessElementTypeAt(location: Node): Type | undefined {
    const jsxElementType = getJsxElementTypeAt(location);
    if (jsxElementType) return getUnionType([jsxElementType, nullType]);
  }
  function getJsxIntrinsicTagNamesAt(location: Node): Symbol[] {
    const intrinsics = getJsxType(JsxNames.IntrinsicElements, location);
    return intrinsics ? getPropertiesOfType(intrinsics) : empty;
  }
  function checkJsxPreconditions(errorNode: Node) {
    if ((compilerOptions.jsx || JsxEmit.None) === JsxEmit.None) error(errorNode, qd.Cannot_use_JSX_unless_the_jsx_flag_is_provided);
    if (getJsxElementTypeAt(errorNode) === undefined) {
      if (noImplicitAny) error(errorNode, qd.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist);
    }
  }
  function checkJsxOpeningLikeElementOrOpeningFragment(node: JsxOpeningLikeElement | JsxOpeningFragment) {
    const isNodeOpeningLikeElement = qc.isJsx.openingLikeElement(node);
    if (isNodeOpeningLikeElement) checkGrammarJsxElement(<JsxOpeningLikeElement>node);
    checkJsxPreconditions(node);
    const reactRefErr = diagnostics && compilerOptions.jsx === JsxEmit.React ? qd.Cannot_find_name_0 : undefined;
    const reactNamespace = getJsxNamespace(node);
    const reactLocation = isNodeOpeningLikeElement ? (<JsxOpeningLikeElement>node).tagName : node;
    const reactSym = resolveName(reactLocation, reactNamespace, SymbolFlags.Value, reactRefErr, reactNamespace, true);
    if (reactSym) {
      reactSym.isReferenced = SymbolFlags.All;
      if (reactSym.flags & SymbolFlags.Alias && !reactSym.getTypeOnlyAliasDeclaration()) reactSym.markAliasSymbolAsReferenced();
    }
    if (isNodeOpeningLikeElement) {
      const jsxOpeningLikeNode = node as JsxOpeningLikeElement;
      const sig = getResolvedSignature(jsxOpeningLikeNode);
      checkJsxReturnAssignableToAppropriateBound(getJsxReferenceKind(jsxOpeningLikeNode), getReturnTypeOfSignature(sig), jsxOpeningLikeNode);
    }
  }
  function isKnownProperty(targetType: Type, name: __String, isComparingJsxAttributes: boolean): boolean {
    if (targetType.flags & TypeFlags.Object) {
      const resolved = resolveStructuredTypeMembers(targetType as ObjectType);
      if (
        resolved.stringIndexInfo ||
        (resolved.numberIndexInfo && NumericLiteral.name(name)) ||
        getPropertyOfObjectType(targetType, name) ||
        (isComparingJsxAttributes && !isUnhyphenatedJsxName(name))
      ) {
        return true;
      }
    } else if (targetType.flags & TypeFlags.UnionOrIntersection && isExcessPropertyCheckTarget(targetType)) {
      for (const t of (targetType as UnionOrIntersectionType).types) {
        if (isKnownProperty(t, name, isComparingJsxAttributes)) return true;
      }
    }
    return false;
  }
  function isExcessPropertyCheckTarget(type: Type): boolean {
    return !!(
      (type.flags & TypeFlags.Object && !(getObjectFlags(type) & ObjectFlags.ObjectLiteralPatternWithComputedProperties)) ||
      type.flags & TypeFlags.NonPrimitive ||
      (type.flags & TypeFlags.Union && some((<UnionType>type).types, isExcessPropertyCheckTarget)) ||
      (type.flags & TypeFlags.Intersection && every((<IntersectionType>type).types, isExcessPropertyCheckTarget))
    );
  }
  function checkJsxExpression(node: JsxExpression, checkMode?: CheckMode) {
    checkGrammarJsxExpression(node);
    if (node.expression) {
      const type = checkExpression(node.expression, checkMode);
      if (node.dot3Token && type !== anyType && !isArrayType(type)) error(node, qd.JSX_spread_child_must_be_an_array_type);
      return type;
    }
    return errorType;
  }
  function getDeclarationNodeFlagsFromSymbol(s: Symbol): NodeFlags {
    return s.valueDeclaration ? qc.get.combinedFlagsOf(s.valueDeclaration) : 0;
  }
  function checkPropertyAccessibility(
    node:
      | PropertyAccessExpression
      | QualifiedName
      | PropertyAccessExpression
      | VariableDeclaration
      | ParameterDeclaration
      | ImportTypeNode
      | PropertyAssignment
      | ShorthandPropertyAssignment
      | BindingElement,
    isSuper: boolean,
    type: Type,
    prop: Symbol
  ): boolean {
    const flags = getDeclarationModifierFlagsFromSymbol(prop);
    const errorNode = node.kind === Syntax.QualifiedName ? node.right : node.kind === Syntax.ImportType ? node : node.name;
    if (isSuper) {
      if (flags & ModifierFlags.Abstract) {
        error(errorNode, qd.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, prop.symbolToString(), typeToString(getDeclaringClass(prop)!));
        return false;
      }
    }
    if (flags & ModifierFlags.Abstract && qc.is.thisProperty(node) && symbolHasNonMethodDeclaration(prop)) {
      const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop)!);
      if (declaringClassDeclaration && isNodeUsedDuringClassInitialization(node)) {
        error(errorNode, qd.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, prop.symbolToString(), getTextOfIdentifierOrLiteral(declaringClassDeclaration.name!));
        return false;
      }
    }
    if (qc.is.kind(PropertyAccessExpression, node) && qc.is.kind(PrivateIdentifier, node.name)) {
      if (!qc.get.containingClass(node)) {
        error(errorNode, qd.Private_identifiers_are_not_allowed_outside_class_bodies);
        return false;
      }
      return true;
    }
    if (!(flags & ModifierFlags.NonPublicAccessibilityModifier)) return true;
    if (flags & ModifierFlags.Private) {
      const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop)!)!;
      if (!isNodeWithinClass(node, declaringClassDeclaration)) {
        error(errorNode, qd.Property_0_is_private_and_only_accessible_within_class_1, prop.symbolToString(), typeToString(getDeclaringClass(prop)!));
        return false;
      }
      return true;
    }
    if (isSuper) return true;
    let enclosingClass = forEachEnclosingClass(node, (enclosingDeclaration) => {
      const enclosingClass = <InterfaceType>getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingDeclaration)!);
      return isClassDerivedFromDeclaringClasses(enclosingClass, prop) ? enclosingClass : undefined;
    });
    if (!enclosingClass) {
      let thisParameter: ParameterDeclaration | undefined;
      if (flags & ModifierFlags.Static || !(thisParameter = getThisParameterFromNodeContext(node)) || !thisParameter.type) {
        error(errorNode, qd.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, prop.symbolToString(), typeToString(getDeclaringClass(prop) || type));
        return false;
      }
      const thisType = getTypeFromTypeNode(thisParameter.type);
      enclosingClass = ((thisType.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(<TypeParameter>thisType) : thisType) as TypeReference).target;
    }
    if (flags & ModifierFlags.Static) return true;
    if (type.flags & TypeFlags.TypeParameter) type = (type as TypeParameter).isThisType ? getConstraintOfTypeParameter(<TypeParameter>type)! : getBaseConstraintOfType(<TypeParameter>type)!;
    if (!type || !hasBaseType(type, enclosingClass)) {
      error(errorNode, qd.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1, prop.symbolToString(), typeToString(enclosingClass));
      return false;
    }
    return true;
  }
  function getThisParameterFromNodeContext(node: Node) {
    const thisContainer = qc.get.thisContainer(node, false);
    return thisContainer && qc.is.functionLike(thisContainer) ? getThisNodeKind(ParameterDeclaration, thisContainer) : undefined;
  }
  function checkNonNullExpression(node: Expression | QualifiedName) {
    return checkNonNullType(checkExpression(node), node);
  }
  function isNullableType(type: Type) {
    return !!((strictNullChecks ? getFalsyFlags(type) : type.flags) & TypeFlags.Nullable);
  }
  function getNonNullableTypeIfNeeded(type: Type) {
    return isNullableType(type) ? getNonNullableType(type) : type;
  }
  function reportObjectPossiblyNullOrUndefinedError(node: Node, flags: TypeFlags) {
    error(node, flags & TypeFlags.Undefined ? (flags & TypeFlags.Null ? qd.Object_is_possibly_null_or_undefined : qd.Object_is_possibly_undefined) : qd.Object_is_possibly_null);
  }
  function reportCannotInvokePossiblyNullOrUndefinedError(node: Node, flags: TypeFlags) {
    error(
      node,
      flags & TypeFlags.Undefined
        ? flags & TypeFlags.Null
          ? qd.Cannot_invoke_an_object_which_is_possibly_null_or_undefined
          : qd.Cannot_invoke_an_object_which_is_possibly_undefined
        : qd.Cannot_invoke_an_object_which_is_possibly_null
    );
  }
  function checkNonNullTypeWithReporter(type: Type, node: Node, reportError: (node: Node, kind: TypeFlags) => void): Type {
    if (strictNullChecks && type.flags & TypeFlags.Unknown) {
      error(node, qd.Object_is_of_type_unknown);
      return errorType;
    }
    const kind = (strictNullChecks ? getFalsyFlags(type) : type.flags) & TypeFlags.Nullable;
    if (kind) {
      reportError(node, kind);
      const t = getNonNullableType(type);
      return t.flags & (TypeFlags.Nullable | TypeFlags.Never) ? errorType : t;
    }
    return type;
  }
  function checkNonNullType(type: Type, node: Node) {
    return checkNonNullTypeWithReporter(type, node, reportObjectPossiblyNullOrUndefinedError);
  }
  function checkNonNullNonVoidType(type: Type, node: Node): Type {
    const nonNullType = checkNonNullType(type, node);
    if (nonNullType !== errorType && nonNullType.flags & TypeFlags.Void) error(node, qd.Object_is_possibly_undefined);
    return nonNullType;
  }
  function checkPropertyAccessExpression(node: PropertyAccessExpression) {
    return node.flags & NodeFlags.OptionalChain
      ? checkPropertyAccessChain(node as PropertyAccessChain)
      : checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullExpression(node.expression), node.name);
  }
  function checkPropertyAccessChain(node: PropertyAccessChain) {
    const leftType = checkExpression(node.expression);
    const nonOptionalType = getOptionalExpressionType(leftType, node.expression);
    return propagateOptionalTypeMarker(
      checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullType(nonOptionalType, node.expression), node.name),
      node,
      nonOptionalType !== leftType
    );
  }
  function checkQualifiedName(node: QualifiedName) {
    return checkPropertyAccessExpressionOrQualifiedName(node, node.left, checkNonNullExpression(node.left), node.right);
  }
  function isMethodAccessForCall(node: Node) {
    while (node.parent.kind === Syntax.ParenthesizedExpression) {
      node = node.parent;
    }
    return qc.is.callOrNewExpression(node.parent) && node.parent.expression === node;
  }
  function lookupSymbolForPrivateIdentifierDeclaration(propName: __String, location: Node): Symbol | undefined {
    for (let containingClass = qc.get.containingClass(location); !!containingClass; containingClass = qc.get.containingClass(containingClass)) {
      const { symbol } = containingClass;
      const name = getSymbolNameForPrivateIdentifier(symbol, propName);
      const prop = (symbol.members && symbol.members.get(name)) || (symbol.exports && symbol.exports.get(name));
      if (prop) return prop;
    }
  }
  function getPrivateIdentifierPropertyOfType(leftType: Type, lexicallyScopedIdentifier: Symbol): Symbol | undefined {
    return getPropertyOfType(leftType, lexicallyScopedIdentifier.escName);
  }
  function checkPrivateIdentifierPropertyAccess(leftType: Type, right: PrivateIdentifier, lexicallyScopedIdentifier: Symbol | undefined): boolean {
    let propertyOnType: Symbol | undefined;
    const properties = getPropertiesOfType(leftType);
    if (properties) {
      forEach(properties, (symbol: Symbol) => {
        const decl = symbol.valueDeclaration;
        if (decl && qc.is.namedDeclaration(decl) && qc.is.kind(PrivateIdentifier, decl.name) && decl.name.escapedText === right.escapedText) {
          propertyOnType = symbol;
          return true;
        }
      });
    }
    const diagName = diagnosticName(right);
    if (propertyOnType) {
      const typeValueDecl = propertyOnType.valueDeclaration;
      const typeClass = qc.get.containingClass(typeValueDecl);
      assert(!!typeClass);
      if (lexicallyScopedIdentifier) {
        const lexicalValueDecl = lexicallyScopedIdentifier.valueDeclaration;
        const lexicalClass = qc.get.containingClass(lexicalValueDecl);
        assert(!!lexicalClass);
        if (Node.findAncestor(lexicalClass, (n) => typeClass === n)) {
          const diagnostic = error(
            right,
            qd.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling,
            diagName,
            typeToString(leftType)
          );
          addRelatedInfo(
            diagnostic,
            createDiagnosticForNode(lexicalValueDecl, qd.The_shadowing_declaration_of_0_is_defined_here, diagName),
            createDiagnosticForNode(typeValueDecl, qd.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here, diagName)
          );
          return true;
        }
      }
      error(right, qd.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier, diagName, diagnosticName(typeClass.name || anon));
      return true;
    }
    return false;
  }
  function isThisPropertyAccessInConstructor(node: ElementAccessExpression | PropertyAccessExpression | QualifiedName, prop: Symbol) {
    return qc.is.thisProperty(node) && (isAutoTypedProperty(prop) || isConstructorDeclaredProperty(prop)) && qc.get.thisContainer(node, true) === getDeclaringConstructor(prop);
  }
  function checkPropertyAccessExpressionOrQualifiedName(node: PropertyAccessExpression | QualifiedName, left: Expression | QualifiedName, leftType: Type, right: Identifier | PrivateIdentifier) {
    const parentSymbol = getNodeLinks(left).resolvedSymbol;
    const assignmentKind = getAssignmentTargetKind(node);
    const apparentType = getApparentType(assignmentKind !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(leftType) : leftType);
    if (qc.is.kind(PrivateIdentifier, right)) checkExternalEmitHelpers(node, ExternalEmitHelpers.ClassPrivateFieldGet);
    const isAnyLike = isTypeAny(apparentType) || apparentType === silentNeverType;
    let prop: Symbol | undefined;
    if (qc.is.kind(PrivateIdentifier, right)) {
      const lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right);
      if (isAnyLike) {
        if (lexicallyScopedSymbol) return apparentType;
        if (!qc.get.containingClass(right)) {
          grammarErrorOnNode(right, qd.Private_identifiers_are_not_allowed_outside_class_bodies);
          return anyType;
        }
      }
      prop = lexicallyScopedSymbol ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol) : undefined;
      if (!prop && checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol)) return errorType;
    } else {
      if (isAnyLike) {
        if (qc.is.kind(Identifier, left) && parentSymbol) markAliasReferenced(parentSymbol, node);
        return apparentType;
      }
      prop = getPropertyOfType(apparentType, right.escapedText);
    }
    if (qc.is.kind(Identifier, left) && parentSymbol && !(prop && isConstEnumOrConstEnumOnlyModule(prop))) markAliasReferenced(parentSymbol, node);
    let propType: Type;
    if (!prop) {
      const indexInfo =
        !qc.is.kind(PrivateIdentifier, right) && (assignmentKind === AssignmentKind.None || !isGenericObjectType(leftType) || isThisTypeParameter(leftType))
          ? getIndexInfoOfType(apparentType, IndexKind.String)
          : undefined;
      if (!(indexInfo && indexInfo.type)) {
        if (isJSLiteralType(leftType)) return anyType;
        if (leftType.symbol === globalThisSymbol) {
          if (globalThisSymbol.exports!.has(right.escapedText) && globalThisSymbol.exports!.get(right.escapedText)!.flags & SymbolFlags.BlockScoped)
            error(right, qd.Property_0_does_not_exist_on_type_1, syntax.get.unescUnderscores(right.escapedText), typeToString(leftType));
          else if (noImplicitAny) {
            error(right, qd.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(leftType));
          }
          return anyType;
        }
        if (right.escapedText && !checkAndReportErrorForExtendingInterface(node)) reportNonexistentProperty(right, isThisTypeParameter(leftType) ? apparentType : leftType);
        return errorType;
      }
      if (indexInfo.isReadonly && (isAssignmentTarget(node) || qc.is.deleteTarget(node))) error(node, qd.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType));
      propType = indexInfo.type;
    } else {
      checkPropertyNotUsedBeforeDeclaration(prop, node, right);
      markPropertyAsReferenced(prop, node, left.kind === Syntax.ThisKeyword);
      getNodeLinks(node).resolvedSymbol = prop;
      checkPropertyAccessibility(node, left.kind === Syntax.SuperKeyword, apparentType, prop);
      if (isAssignmentToReadonlyEntity(node as Expression, prop, assignmentKind)) {
        error(right, qd.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right));
        return errorType;
      }
      propType = isThisPropertyAccessInConstructor(node, prop) ? autoType : getConstraintForLocation(getTypeOfSymbol(prop), node);
    }
    return getFlowTypeOfAccessExpression(node, prop, propType, right);
  }
  function getFlowTypeOfAccessExpression(node: ElementAccessExpression | PropertyAccessExpression | QualifiedName, prop: Symbol | undefined, propType: Type, errorNode: Node) {
    const assignmentKind = getAssignmentTargetKind(node);
    if (
      !isAccessExpression(node) ||
      assignmentKind === AssignmentKind.Definite ||
      (prop && !(prop.flags & (SymbolFlags.Variable | SymbolFlags.Property | SymbolFlags.Accessor)) && !(prop.flags & SymbolFlags.Method && propType.flags & TypeFlags.Union))
    ) {
      return propType;
    }
    if (propType === autoType) return getFlowTypeOfProperty(node, prop);
    let assumeUninitialized = false;
    if (strictNullChecks && strictPropertyInitialization && node.expression.kind === Syntax.ThisKeyword) {
      const declaration = prop && prop.valueDeclaration;
      if (declaration && isInstancePropertyWithoutInitializer(declaration)) {
        const flowContainer = getControlFlowContainer(node);
        if (flowContainer.kind === Syntax.Constructor && flowContainer.parent === declaration.parent && !(declaration.flags & NodeFlags.Ambient)) assumeUninitialized = true;
      }
    } else if (
      strictNullChecks &&
      prop &&
      prop.valueDeclaration &&
      qc.is.kind(PropertyAccessExpression, prop.valueDeclaration) &&
      getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) &&
      getControlFlowContainer(node) === getControlFlowContainer(prop.valueDeclaration)
    ) {
      assumeUninitialized = true;
    }
    const flowType = getFlowTypeOfReference(node, propType, assumeUninitialized ? getOptionalType(propType) : propType);
    if (assumeUninitialized && !(getFalsyFlags(propType) & TypeFlags.Undefined) && getFalsyFlags(flowType) & TypeFlags.Undefined) {
      error(errorNode, qd.Property_0_is_used_before_being_assigned, prop!.symbolToString());
      return propType;
    }
    return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
  }
  function checkPropertyNotUsedBeforeDeclaration(prop: Symbol, node: PropertyAccessExpression | QualifiedName, right: Identifier | PrivateIdentifier): void {
    const { valueDeclaration } = prop;
    if (!valueDeclaration || qc.get.sourceFileOf(node).isDeclarationFile) return;
    let diagnosticMessage;
    const declarationName = idText(right);
    if (
      isInPropertyInitializer(node) &&
      !(isAccessExpression(node) && isAccessExpression(node.expression)) &&
      !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) &&
      !isPropertyDeclaredInAncestorClass(prop)
    ) {
      diagnosticMessage = error(right, qd.Property_0_is_used_before_its_initialization, declarationName);
    } else if (
      valueDeclaration.kind === Syntax.ClassDeclaration &&
      node.parent.kind !== Syntax.TypeReference &&
      !(valueDeclaration.flags & NodeFlags.Ambient) &&
      !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)
    ) {
      diagnosticMessage = error(right, qd.Class_0_used_before_its_declaration, declarationName);
    }
    if (diagnosticMessage) addRelatedInfo(diagnosticMessage, createDiagnosticForNode(valueDeclaration, qd._0_is_declared_here, declarationName));
  }
  function isInPropertyInitializer(node: Node): boolean {
    return !!Node.findAncestor(node, (node) => {
      switch (node.kind) {
        case Syntax.PropertyDeclaration:
          return true;
        case Syntax.PropertyAssignment:
        case Syntax.MethodDeclaration:
        case Syntax.GetAccessor:
        case Syntax.SetAccessor:
        case Syntax.SpreadAssignment:
        case Syntax.ComputedPropertyName:
        case Syntax.TemplateSpan:
        case Syntax.JsxExpression:
        case Syntax.JsxAttribute:
        case Syntax.JsxAttributes:
        case Syntax.JsxSpreadAttribute:
        case Syntax.JsxOpeningElement:
        case Syntax.ExpressionWithTypeArguments:
        case Syntax.HeritageClause:
          return false;
        default:
          return qc.is.expressionNode(node) ? false : 'quit';
      }
    });
  }
  function isPropertyDeclaredInAncestorClass(prop: Symbol): boolean {
    if (!(prop.parent!.flags & SymbolFlags.Class)) return false;
    let classType: InterfaceType | undefined = getTypeOfSymbol(prop.parent!) as InterfaceType;
    while (true) {
      classType = classType.symbol && (getSuperClass(classType) as InterfaceType | undefined);
      if (!classType) return false;
      const superProperty = getPropertyOfType(classType, prop.escName);
      if (superProperty && superProperty.valueDeclaration) return true;
    }
  }
  function getSuperClass(classType: InterfaceType): Type | undefined {
    const x = getBaseTypes(classType);
    if (x.length === 0) return;
    return getIntersectionType(x);
  }
  function reportNonexistentProperty(propNode: Identifier | PrivateIdentifier, containingType: Type) {
    let errorInfo: DiagnosticMessageChain | undefined;
    let relatedInfo: Diagnostic | undefined;
    if (!qc.is.kind(PrivateIdentifier, propNode) && containingType.flags & TypeFlags.Union && !(containingType.flags & TypeFlags.Primitive)) {
      for (const subtype of (containingType as UnionType).types) {
        if (!getPropertyOfType(subtype, propNode.escapedText) && !getIndexInfoOfType(subtype, IndexKind.String)) {
          errorInfo = chainDiagnosticMessages(errorInfo, qd.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(subtype));
          break;
        }
      }
    }
    if (typeHasStaticProperty(propNode.escapedText, containingType))
      errorInfo = chainDiagnosticMessages(errorInfo, qd.Property_0_is_a_static_member_of_type_1, declarationNameToString(propNode), typeToString(containingType));
    else {
      const promisedType = getPromisedTypeOfPromise(containingType);
      if (promisedType && getPropertyOfType(promisedType, propNode.escapedText)) {
        errorInfo = chainDiagnosticMessages(errorInfo, qd.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(containingType));
        relatedInfo = createDiagnosticForNode(propNode, qd.Did_you_forget_to_use_await);
      } else {
        const suggestion = getSuggestedSymbolForNonexistentProperty(propNode, containingType);
        if (suggestion !== undefined) {
          const suggestedName = suggestion.name;
          errorInfo = chainDiagnosticMessages(errorInfo, qd.Property_0_does_not_exist_on_type_1_Did_you_mean_2, declarationNameToString(propNode), typeToString(containingType), suggestedName);
          relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, qd._0_is_declared_here, suggestedName);
        } else {
          errorInfo = chainDiagnosticMessages(
            elaborateNeverIntersection(errorInfo, containingType),
            qd.Property_0_does_not_exist_on_type_1,
            declarationNameToString(propNode),
            typeToString(containingType)
          );
        }
      }
    }
    const resultDiagnostic = createDiagnosticForNodeFromMessageChain(propNode, errorInfo);
    if (relatedInfo) addRelatedInfo(resultDiagnostic, relatedInfo);
    diagnostics.add(resultDiagnostic);
  }
  function typeHasStaticProperty(propName: __String, containingType: Type): boolean {
    const prop = containingType.symbol && getPropertyOfType(getTypeOfSymbol(containingType.symbol), propName);
    return prop !== undefined && prop.valueDeclaration && hasSyntacticModifier(prop.valueDeclaration, ModifierFlags.Static);
  }
  function getSuggestedSymbolForNonexistentProperty(name: Identifier | PrivateIdentifier | string, containingType: Type): Symbol | undefined {
    return getSpellingSuggestionForName(isString(name) ? name : idText(name), getPropertiesOfType(containingType), SymbolFlags.Value);
  }
  function getSuggestionForNonexistentProperty(name: Identifier | PrivateIdentifier | string, containingType: Type): string | undefined {
    const suggestion = getSuggestedSymbolForNonexistentProperty(name, containingType);
    return suggestion && suggestion.name;
  }
  function getSuggestedSymbolForNonexistentSymbol(location: Node | undefined, outerName: __String, meaning: SymbolFlags): Symbol | undefined {
    assert(outerName !== undefined, 'outername should always be defined');
    const result = resolveNameHelper(location, outerName, meaning, undefined, outerName, false, false, (symbols, name, meaning) => {
      Debug.assertEqual(outerName, name, 'name should equal outerName');
      const symbol = getSymbol(symbols, name, meaning);
      return symbol || getSpellingSuggestionForName(syntax.get.unescUnderscores(name), arrayFrom(symbols.values()), meaning);
    });
    return result;
  }
  function getSuggestionForNonexistentSymbol(location: Node | undefined, outerName: __String, meaning: SymbolFlags): string | undefined {
    const symbolResult = getSuggestedSymbolForNonexistentSymbol(location, outerName, meaning);
    return symbolResult && symbolResult.name;
  }
  function getSuggestedSymbolForNonexistentModule(name: Identifier, targetModule: Symbol): Symbol | undefined {
    return targetModule.exports && getSpellingSuggestionForName(idText(name), getExportsOfModuleAsArray(targetModule), SymbolFlags.ModuleMember);
  }
  function getSuggestionForNonexistentExport(name: Identifier, targetModule: Symbol): string | undefined {
    const suggestion = getSuggestedSymbolForNonexistentModule(name, targetModule);
    return suggestion && suggestion.name;
  }
  function getSuggestionForNonexistentIndexSignature(objectType: Type, expr: ElementAccessExpression, keyedType: Type): string | undefined {
    function hasProp(name: 'set' | 'get') {
      const prop = getPropertyOfObjectType(objectType, <__String>name);
      if (prop) {
        const s = getSingleCallSignature(getTypeOfSymbol(prop));
        return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0));
      }
      return false;
    }
    const suggestedMethod = isAssignmentTarget(expr) ? 'set' : 'get';
    if (!hasProp(suggestedMethod)) return;
    let suggestion = tryGetPropertyAccessOrIdentifierToString(expr.expression);
    if (suggestion === undefined) suggestion = suggestedMethod;
    else {
      suggestion += '.' + suggestedMethod;
    }
    return suggestion;
  }
  function getSpellingSuggestionForName(name: string, symbols: Symbol[], meaning: SymbolFlags): Symbol | undefined {
    return getSpellingSuggestion(name, symbols, getCandidateName);
    function getCandidateName(candidate: Symbol) {
      const candidateName = candidate.name;
      if (startsWith(candidateName, '"')) return;
      if (candidate.flags & meaning) return candidateName;
      if (candidate.flags & SymbolFlags.Alias) {
        const alias = candidate.tryResolveAlias();
        if (alias && alias.flags & meaning) return candidateName;
      }
      return;
    }
  }
  function markPropertyAsReferenced(prop: Symbol, nodeForCheckWriteOnly: Node | undefined, isThisAccess: boolean) {
    const valueDeclaration = prop && prop.flags & SymbolFlags.ClassMember && prop.valueDeclaration;
    if (!valueDeclaration) return;
    const hasPrivateModifier = hasEffectiveModifier(valueDeclaration, ModifierFlags.Private);
    const hasPrivateIdentifier = qc.is.namedDeclaration(prop.valueDeclaration) && qc.is.kind(PrivateIdentifier, prop.valueDeclaration.name);
    if (!hasPrivateModifier && !hasPrivateIdentifier) return;
    if (nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & SymbolFlags.SetAccessor)) return;
    if (isThisAccess) {
      const containingMethod = Node.findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration);
      if (containingMethod && containingMethod.symbol === prop) return;
    }
    (getCheckFlags(prop) & CheckFlags.Instantiated ? s.getLinks(prop).target : prop)!.isReferenced = SymbolFlags.All;
  }
  function isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: __String): boolean {
    switch (node.kind) {
      case Syntax.PropertyAccessExpression:
        return isValidPropertyAccessWithType(node, node.expression.kind === Syntax.SuperKeyword, propertyName, getWidenedType(checkExpression(node.expression)));
      case Syntax.QualifiedName:
        return isValidPropertyAccessWithType(node, false, propertyName, getWidenedType(checkExpression(node.left)));
      case Syntax.ImportType:
        return isValidPropertyAccessWithType(node, false, propertyName, getTypeFromTypeNode(node));
    }
  }
  function isValidPropertyAccessForCompletions(node: PropertyAccessExpression | ImportTypeNode | QualifiedName, type: Type, property: Symbol): boolean {
    return isValidPropertyAccessWithType(node, node.kind === Syntax.PropertyAccessExpression && node.expression.kind === Syntax.SuperKeyword, property.escName, type);
  }
  function isValidPropertyAccessWithType(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, isSuper: boolean, propertyName: __String, type: Type): boolean {
    if (type === errorType || isTypeAny(type)) return true;
    const prop = getPropertyOfType(type, propertyName);
    if (prop) {
      if (qc.is.kind(PropertyAccessExpression, node) && prop.valueDeclaration?.isPrivateIdentifierPropertyDeclaration()) {
        const declClass = qc.get.containingClass(prop.valueDeclaration);
        return !qc.is.optionalChain(node) && !!Node.findAncestor(node, (parent) => parent === declClass);
      }
      return checkPropertyAccessibility(node, isSuper, type, prop);
    }
    return isInJSFile(node) && (type.flags & TypeFlags.Union) !== 0 && (<UnionType>type).types.some((elementType) => isValidPropertyAccessWithType(node, isSuper, propertyName, elementType));
  }
  function getForInVariableSymbol(node: ForInStatement): Symbol | undefined {
    const initializer = node.initializer;
    if (initializer.kind === Syntax.VariableDeclarationList) {
      const variable = (<VariableDeclarationList>initializer).declarations[0];
      if (variable && !qc.is.kind(BindingPattern, variable.name)) return getSymbolOfNode(variable);
    } else if (initializer.kind === Syntax.Identifier) {
      return getResolvedSymbol(<Identifier>initializer);
    }
    return;
  }
  function hasNumericPropertyNames(type: Type) {
    return getIndexTypeOfType(type, IndexKind.Number) && !getIndexTypeOfType(type, IndexKind.String);
  }
  function isForInVariableForNumericPropertyNames(expr: Expression) {
    const e = skipParentheses(expr);
    if (e.kind === Syntax.Identifier) {
      const symbol = getResolvedSymbol(<Identifier>e);
      if (symbol.flags & SymbolFlags.Variable) {
        let child: Node = expr;
        let node = expr.parent;
        while (node) {
          if (
            node.kind === Syntax.ForInStatement &&
            child === (<ForInStatement>node).statement &&
            getForInVariableSymbol(<ForInStatement>node) === symbol &&
            hasNumericPropertyNames(getTypeOfExpression((<ForInStatement>node).expression))
          ) {
            return true;
          }
          child = node;
          node = node.parent;
        }
      }
    }
    return false;
  }
  function checkIndexedAccess(node: ElementAccessExpression): Type {
    return node.flags & NodeFlags.OptionalChain ? checkElementAccessChain(node as ElementAccessChain) : checkElementAccessExpression(node, checkNonNullExpression(node.expression));
  }
  function checkElementAccessChain(node: ElementAccessChain) {
    const exprType = checkExpression(node.expression);
    const nonOptionalType = getOptionalExpressionType(exprType, node.expression);
    return propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType, node.expression)), node, nonOptionalType !== exprType);
  }
  function checkElementAccessExpression(node: ElementAccessExpression, exprType: Type): Type {
    const objectType = getAssignmentTargetKind(node) !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(exprType) : exprType;
    const indexExpression = node.argumentExpression;
    const indexType = checkExpression(indexExpression);
    if (objectType === errorType || objectType === silentNeverType) return objectType;
    if (isConstEnumObjectType(objectType) && !StringLiteral.like(indexExpression)) {
      error(indexExpression, qd.A_const_enum_member_can_only_be_accessed_using_a_string_literal);
      return errorType;
    }
    const effectiveIndexType = isForInVariableForNumericPropertyNames(indexExpression) ? numberType : indexType;
    const accessFlags = isAssignmentTarget(node) ? AccessFlags.Writing | (isGenericObjectType(objectType) && !isThisTypeParameter(objectType) ? AccessFlags.NoIndexSignatures : 0) : AccessFlags.None;
    const indexedAccessType = getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, node, accessFlags) || errorType;
    return checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node, indexedAccessType.symbol, indexedAccessType, indexExpression), node);
  }
  function checkThatExpressionIsProperSymbolReference(expression: Expression, expressionType: Type, reportError: boolean): boolean {
    if (expressionType === errorType) return false;
    if (!isWellKnownSymbolSyntactically(expression)) return false;
    if ((expressionType.flags & TypeFlags.ESSymbolLike) === 0) {
      if (reportError) error(expression, qd.A_computed_property_name_of_the_form_0_must_be_of_type_symbol, qc.get.textOf(expression));
      return false;
    }
    const leftHandSide = <Identifier>(<PropertyAccessExpression>expression).expression;
    const leftHandSideSymbol = getResolvedSymbol(leftHandSide);
    if (!leftHandSideSymbol) return false;
    const globalESSymbol = getGlobalESSymbolConstructorSymbol(true);
    if (!globalESSymbol) return false;
    if (leftHandSideSymbol !== globalESSymbol) {
      if (reportError) error(leftHandSide, qd.Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object);
      return false;
    }
    return true;
  }
  function callLikeExpressionMayHaveTypeArguments(node: CallLikeExpression): node is CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement {
    return qc.is.callOrNewExpression(node) || qc.is.kind(TaggedTemplateExpression, node) || qc.isJsx.openingLikeElement(node);
  }
  function resolveUntypedCall(node: CallLikeExpression): Signature {
    if (callLikeExpressionMayHaveTypeArguments(node)) forEach(node.typeArguments, checkSourceElement);
    if (node.kind === Syntax.TaggedTemplateExpression) checkExpression(node.template);
    else if (qc.isJsx.openingLikeElement(node)) {
      checkExpression(node.attributes);
    } else if (node.kind !== Syntax.Decorator) {
      forEach((<CallExpression>node).arguments, (argument) => {
        checkExpression(argument);
      });
    }
    return anySignature;
  }
  function resolveErrorCall(node: CallLikeExpression): Signature {
    resolveUntypedCall(node);
    return unknownSignature;
  }
  function reorderCandidates(signatures: readonly Signature[], result: Signature[], callChainFlags: SignatureFlags): void {
    let lastParent: Node | undefined;
    let lastSymbol: Symbol | undefined;
    let cutoffIndex = 0;
    let index: number | undefined;
    let specializedIndex = -1;
    let spliceIndex: number;
    assert(!result.length);
    for (const signature of signatures) {
      const symbol = signature.declaration && getSymbolOfNode(signature.declaration);
      const parent = signature.declaration && signature.declaration.parent;
      if (!lastSymbol || symbol === lastSymbol) {
        if (lastParent && parent === lastParent) index = index! + 1;
        else {
          lastParent = parent;
          index = cutoffIndex;
        }
      } else {
        index = cutoffIndex = result.length;
        lastParent = parent;
      }
      lastSymbol = symbol;
      if (signatureHasLiteralTypes(signature)) {
        specializedIndex++;
        spliceIndex = specializedIndex;
        cutoffIndex++;
      } else {
        spliceIndex = index;
      }
      result.splice(spliceIndex, 0, callChainFlags ? getOptionalCallSignature(signature, callChainFlags) : signature);
    }
  }
  function isSpreadArgument(arg: Expression | undefined): arg is Expression {
    return !!arg && (arg.kind === Syntax.SpreadElement || (arg.kind === Syntax.SyntheticExpression && (<SyntheticExpression>arg).isSpread));
  }
  function getSpreadArgumentIndex(args: readonly Expression[]): number {
    return findIndex(args, isSpreadArgument);
  }
  function acceptsVoid(t: Type): boolean {
    return !!(t.flags & TypeFlags.Void);
  }
  function hasCorrectArity(node: CallLikeExpression, args: readonly Expression[], signature: Signature, signatureHelpTrailingComma = false) {
    let argCount: number;
    let callIsIncomplete = false;
    let effectiveParameterCount = getParameterCount(signature);
    let effectiveMinimumArguments = getMinArgumentCount(signature);
    if (node.kind === Syntax.TaggedTemplateExpression) {
      argCount = args.length;
      if (node.template.kind === Syntax.TemplateExpression) {
        const lastSpan = last(node.template.templateSpans);
        callIsIncomplete = qc.is.missing(lastSpan.literal) || !!lastSpan.literal.isUnterminated;
      } else {
        const templateLiteral = <LiteralExpression>node.template;
        assert(templateLiteral.kind === Syntax.NoSubstitutionLiteral);
        callIsIncomplete = !!templateLiteral.isUnterminated;
      }
    } else if (node.kind === Syntax.Decorator) {
      argCount = getDecoratorArgumentCount(node, signature);
    } else if (qc.isJsx.openingLikeElement(node)) {
      callIsIncomplete = node.attributes.end === node.end;
      if (callIsIncomplete) return true;
      argCount = effectiveMinimumArguments === 0 ? args.length : 1;
      effectiveParameterCount = args.length === 0 ? effectiveParameterCount : 1;
      effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1);
    } else {
      if (!node.arguments) {
        assert(node.kind === Syntax.NewExpression);
        return getMinArgumentCount(signature) === 0;
      }
      argCount = signatureHelpTrailingComma ? args.length + 1 : args.length;
      callIsIncomplete = node.arguments.end === node.end;
      const spreadArgIndex = getSpreadArgumentIndex(args);
      if (spreadArgIndex >= 0) return spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature));
    }
    if (!hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount) return false;
    if (callIsIncomplete || argCount >= effectiveMinimumArguments) return true;
    for (let i = argCount; i < effectiveMinimumArguments; i++) {
      const type = getTypeAtPosition(signature, i);
      if (filterType(type, acceptsVoid).flags & TypeFlags.Never) return false;
    }
    return true;
  }
  function hasCorrectTypeArgumentArity(signature: Signature, typeArguments: Nodes<TypeNode> | undefined) {
    const numTypeParameters = length(signature.typeParameters);
    const minTypeArgumentCount = getMinTypeArgumentCount(signature.typeParameters);
    return !some(typeArguments) || (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters);
  }
  function getSingleCallSignature(type: Type): Signature | undefined {
    return getSingleSignature(type, SignatureKind.Call, false);
  }
  function getSingleCallOrConstructSignature(type: Type): Signature | undefined {
    return getSingleSignature(type, SignatureKind.Call, false);
  }
  function getSingleSignature(type: Type, kind: SignatureKind, allowMembers: boolean): Signature | undefined {
    if (type.flags & TypeFlags.Object) {
      const resolved = resolveStructuredTypeMembers(<ObjectType>type);
      if (allowMembers || (resolved.properties.length === 0 && !resolved.stringIndexInfo && !resolved.numberIndexInfo)) {
        if (kind === SignatureKind.Call && resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0) return resolved.callSignatures[0];
        if (kind === SignatureKind.Construct && resolved.constructSignatures.length === 1 && resolved.callSignatures.length === 0) return resolved.constructSignatures[0];
      }
    }
    return;
  }
  function instantiateSignatureInContextOf(signature: Signature, contextualSignature: Signature, inferenceContext?: InferenceContext, compareTypes?: TypeComparer): Signature {
    const context = createInferenceContext(signature.typeParameters!, signature, InferenceFlags.None, compareTypes);
    const restType = getEffectiveRestType(contextualSignature);
    const mapper = inferenceContext && (restType && restType.flags & TypeFlags.TypeParameter ? inferenceContext.nonFixingMapper : inferenceContext.mapper);
    const sourceSignature = mapper ? instantiateSignature(contextualSignature, mapper) : contextualSignature;
    applyToParameterTypes(sourceSignature, signature, (source, target) => {
      inferTypes(context.inferences, source, target);
    });
    if (!inferenceContext) {
      applyToReturnTypes(contextualSignature, signature, (source, target) => {
        inferTypes(context.inferences, source, target, InferencePriority.ReturnType);
      });
    }
    return getSignatureInstantiation(signature, getInferredTypes(context), isInJSFile(contextualSignature.declaration));
  }
  function inferJsxTypeArguments(node: JsxOpeningLikeElement, signature: Signature, checkMode: CheckMode, context: InferenceContext): Type[] {
    const paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
    const checkAttrType = checkExpressionWithContextualType(node.attributes, paramType, context, checkMode);
    inferTypes(context.inferences, checkAttrType, paramType);
    return getInferredTypes(context);
  }
  function inferTypeArguments(node: CallLikeExpression, signature: Signature, args: readonly Expression[], checkMode: CheckMode, context: InferenceContext): Type[] {
    if (qc.isJsx.openingLikeElement(node)) return inferJsxTypeArguments(node, signature, checkMode, context);
    if (node.kind !== Syntax.Decorator) {
      const contextualType = getContextualType(node);
      if (contextualType) {
        const outerContext = getInferenceContext(node);
        const outerMapper = getMapperFromContext(cloneInferenceContext(outerContext, InferenceFlags.NoDefault));
        const instantiatedType = instantiateType(contextualType, outerMapper);
        const contextualSignature = getSingleCallSignature(instantiatedType);
        const inferenceSourceType =
          contextualSignature && contextualSignature.typeParameters
            ? getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters))
            : instantiatedType;
        const inferenceTargetType = getReturnTypeOfSignature(signature);
        inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, InferencePriority.ReturnType);
        const returnContext = createInferenceContext(signature.typeParameters!, signature, context.flags);
        const returnSourceType = instantiateType(contextualType, outerContext && outerContext.returnMapper);
        inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType);
        context.returnMapper = some(returnContext.inferences, hasInferenceCandidates) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : undefined;
      }
    }
    const thisType = getThisTypeOfSignature(signature);
    if (thisType) {
      const thisArgumentNode = getThisArgumentOfCall(node);
      const thisArgumentType = thisArgumentNode ? checkExpression(thisArgumentNode) : voidType;
      inferTypes(context.inferences, thisArgumentType, thisType);
    }
    const restType = getNonArrayRestType(signature);
    const argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
    for (let i = 0; i < argCount; i++) {
      const arg = args[i];
      if (arg.kind !== Syntax.OmittedExpression) {
        const paramType = getTypeAtPosition(signature, i);
        const argType = checkExpressionWithContextualType(arg, paramType, context, checkMode);
        inferTypes(context.inferences, argType, paramType);
      }
    }
    if (restType) {
      const spreadType = getSpreadArgumentType(args, argCount, args.length, restType, context);
      inferTypes(context.inferences, spreadType, restType);
    }
    return getInferredTypes(context);
  }
  function getArrayifiedType(type: Type) {
    return type.flags & TypeFlags.Union
      ? mapType(type, getArrayifiedType)
      : type.flags & (TypeFlags.Any | TypeFlags.Instantiable) || isMutableArrayOrTuple(type)
      ? type
      : isTupleType(type)
      ? createTupleType(getTypeArguments(type), type.target.minLength, type.target.hasRestElement, false, type.target.labeledElementDeclarations)
      : createArrayType(getIndexedAccessType(type, numberType));
  }
  function getSpreadArgumentType(args: readonly Expression[], index: number, argCount: number, restType: Type, context: InferenceContext | undefined) {
    if (index >= argCount - 1) {
      const arg = args[argCount - 1];
      if (isSpreadArgument(arg)) {
        return arg.kind === Syntax.SyntheticExpression
          ? createArrayType((<SyntheticExpression>arg).type)
          : getArrayifiedType(checkExpressionWithContextualType((<SpreadElement>arg).expression, restType, context, CheckMode.Normal));
      }
    }
    const types = [];
    const names: (ParameterDeclaration | NamedTupleMember)[] = [];
    let spreadIndex = -1;
    for (let i = index; i < argCount; i++) {
      const contextualType = getIndexedAccessType(restType, getLiteralType(i - index));
      const argType = checkExpressionWithContextualType(args[i], contextualType, context, CheckMode.Normal);
      if (spreadIndex < 0 && isSpreadArgument(args[i])) spreadIndex = i - index;
      if (args[i].kind === Syntax.SyntheticExpression && (args[i] as SyntheticExpression).tupleNameSource) names.push((args[i] as SyntheticExpression).tupleNameSource!);
      const hasPrimitiveContextualType = maybeTypeOfKind(contextualType, TypeFlags.Primitive | TypeFlags.Index);
      types.push(hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType));
    }
    return spreadIndex < 0
      ? createTupleType(types, undefined, length(names) === length(types) ? names : undefined)
      : createTupleType(append(types.slice(0, spreadIndex), getUnionType(types.slice(spreadIndex))), spreadIndex, undefined);
  }
  function checkTypeArguments(signature: Signature, typeArgumentNodes: readonly TypeNode[], reportErrors: boolean, headMessage?: DiagnosticMessage): Type[] | undefined {
    const isJavascript = isInJSFile(signature.declaration);
    const typeParameters = signature.typeParameters!;
    const typeArgumentTypes = fillMissingTypeArguments(map(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript);
    let mapper: TypeMapper | undefined;
    for (let i = 0; i < typeArgumentNodes.length; i++) {
      assert(typeParameters[i] !== undefined, 'Should not call checkTypeArguments with too many type arguments');
      const constraint = getConstraintOfTypeParameter(typeParameters[i]);
      if (constraint) {
        const errorInfo = reportErrors && headMessage ? () => chainDiagnosticMessages(undefined, qd.Type_0_does_not_satisfy_the_constraint_1) : undefined;
        const typeArgumentHeadMessage = headMessage || qd.Type_0_does_not_satisfy_the_constraint_1;
        if (!mapper) mapper = createTypeMapper(typeParameters, typeArgumentTypes);
        const typeArgument = typeArgumentTypes[i];
        if (
          !checkTypeAssignableTo(
            typeArgument,
            getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument),
            reportErrors ? typeArgumentNodes[i] : undefined,
            typeArgumentHeadMessage,
            errorInfo
          )
        ) {
          return;
        }
      }
    }
    return typeArgumentTypes;
  }
  function getJsxReferenceKind(node: JsxOpeningLikeElement): JsxReferenceKind {
    if (isJsxIntrinsicIdentifier(node.tagName)) return JsxReferenceKind.Mixed;
    const tagType = getApparentType(checkExpression(node.tagName));
    if (length(getSignaturesOfType(tagType, SignatureKind.Construct))) return JsxReferenceKind.Component;
    if (length(getSignaturesOfType(tagType, SignatureKind.Call))) return JsxReferenceKind.Function;
    return JsxReferenceKind.Mixed;
  }
  function checkApplicableSignatureForJsxOpeningLikeElement(
    node: JsxOpeningLikeElement,
    signature: Signature,
    relation: qb.QMap<RelationComparisonResult>,
    checkMode: CheckMode,
    reportErrors: boolean,
    containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined,
    errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean }
  ) {
    const paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
    const attributesType = checkExpressionWithContextualType(node.attributes, paramType, undefined, checkMode);
    return (
      checkTagNameDoesNotExpectTooManyArguments() &&
      checkTypeRelatedToAndOptionallyElaborate(attributesType, paramType, relation, reportErrors ? node.tagName : undefined, node.attributes, undefined, containingMessageChain, errorOutputContainer)
    );
    function checkTagNameDoesNotExpectTooManyArguments(): boolean {
      const tagType = qc.is.kind(JsxOpeningElement, node) || (qc.is.kind(JsxSelfClosingElement, node) && !isJsxIntrinsicIdentifier(node.tagName)) ? checkExpression(node.tagName) : undefined;
      if (!tagType) return true;
      const tagCallSignatures = getSignaturesOfType(tagType, SignatureKind.Call);
      if (!length(tagCallSignatures)) return true;
      const factory = getJsxFactoryEntity(node);
      if (!factory) return true;
      const factorySymbol = resolveEntityName(factory, SymbolFlags.Value, true, false, node);
      if (!factorySymbol) return true;
      const factoryType = getTypeOfSymbol(factorySymbol);
      const callSignatures = getSignaturesOfType(factoryType, SignatureKind.Call);
      if (!length(callSignatures)) return true;
      let hasFirstParamSignatures = false;
      let maxParamCount = 0;
      for (const sig of callSignatures) {
        const firstparam = getTypeAtPosition(sig, 0);
        const signaturesOfParam = getSignaturesOfType(firstparam, SignatureKind.Call);
        if (!length(signaturesOfParam)) continue;
        for (const paramSig of signaturesOfParam) {
          hasFirstParamSignatures = true;
          if (hasEffectiveRestParameter(paramSig)) return true;
          const paramCount = getParameterCount(paramSig);
          if (paramCount > maxParamCount) maxParamCount = paramCount;
        }
      }
      if (!hasFirstParamSignatures) return true;
      let absoluteMinArgCount = Infinity;
      for (const tagSig of tagCallSignatures) {
        const tagRequiredArgCount = getMinArgumentCount(tagSig);
        if (tagRequiredArgCount < absoluteMinArgCount) absoluteMinArgCount = tagRequiredArgCount;
      }
      if (absoluteMinArgCount <= maxParamCount) return true;
      if (reportErrors) {
        const diag = createDiagnosticForNode(
          node.tagName,
          qd.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3,
          entityNameToString(node.tagName),
          absoluteMinArgCount,
          entityNameToString(factory),
          maxParamCount
        );
        const tagNameDeclaration = getSymbolAtLocation(node.tagName)?.valueDeclaration;
        if (tagNameDeclaration) addRelatedInfo(diag, createDiagnosticForNode(tagNameDeclaration, qd._0_is_declared_here, entityNameToString(node.tagName)));
        if (errorOutputContainer && errorOutputContainer.skipLogging) (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag);
        if (!errorOutputContainer.skipLogging) diagnostics.add(diag);
      }
      return false;
    }
  }
  function getSignatureApplicabilityError(
    node: CallLikeExpression,
    args: readonly Expression[],
    signature: Signature,
    relation: qb.QMap<RelationComparisonResult>,
    checkMode: CheckMode,
    reportErrors: boolean,
    containingMessageChain: (() => DiagnosticMessageChain | undefined) | undefined
  ): readonly Diagnostic[] | undefined {
    const errorOutputContainer: { errors?: Diagnostic[]; skipLogging?: boolean } = { errors: undefined, skipLogging: true };
    if (qc.isJsx.openingLikeElement(node)) {
      if (!checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer)) {
        assert(!reportErrors || !!errorOutputContainer.errors, 'jsx should have errors when reporting errors');
        return errorOutputContainer.errors || empty;
      }
      return;
    }
    const thisType = getThisTypeOfSignature(signature);
    if (thisType && thisType !== voidType && node.kind !== Syntax.NewExpression) {
      const thisArgumentNode = getThisArgumentOfCall(node);
      let thisArgumentType: Type;
      if (thisArgumentNode) {
        thisArgumentType = checkExpression(thisArgumentNode);
        if (qc.is.optionalChainRoot(thisArgumentNode.parent)) thisArgumentType = getNonNullableType(thisArgumentType);
        else if (qc.is.optionalChain(thisArgumentNode.parent)) {
          thisArgumentType = removeOptionalTypeMarker(thisArgumentType);
        }
      } else {
        thisArgumentType = voidType;
      }
      const errorNode = reportErrors ? thisArgumentNode || node : undefined;
      const headMessage = qd.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1;
      if (!checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer)) {
        assert(!reportErrors || !!errorOutputContainer.errors, 'this parameter should have errors when reporting errors');
        return errorOutputContainer.errors || empty;
      }
    }
    const headMessage = qd.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
    const restType = getNonArrayRestType(signature);
    const argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
    for (let i = 0; i < argCount; i++) {
      const arg = args[i];
      if (arg.kind !== Syntax.OmittedExpression) {
        const paramType = getTypeAtPosition(signature, i);
        const argType = checkExpressionWithContextualType(arg, paramType, undefined, checkMode);
        const checkArgType = checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(argType) : argType;
        if (!checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, reportErrors ? arg : undefined, arg, headMessage, containingMessageChain, errorOutputContainer)) {
          assert(!reportErrors || !!errorOutputContainer.errors, 'parameter should have errors when reporting errors');
          maybeAddMissingAwaitInfo(arg, checkArgType, paramType);
          return errorOutputContainer.errors || empty;
        }
      }
    }
    if (restType) {
      const spreadType = getSpreadArgumentType(args, argCount, args.length, restType, undefined);
      const errorNode = reportErrors ? (argCount < args.length ? args[argCount] : node) : undefined;
      if (!checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, undefined, errorOutputContainer)) {
        assert(!reportErrors || !!errorOutputContainer.errors, 'rest parameter should have errors when reporting errors');
        maybeAddMissingAwaitInfo(errorNode, spreadType, restType);
        return errorOutputContainer.errors || empty;
      }
    }
    return;
    function maybeAddMissingAwaitInfo(errorNode: Node | undefined, source: Type, target: Type) {
      if (errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length) {
        if (getAwaitedTypeOfPromise(target)) return;
        const awaitedTypeOfSource = getAwaitedTypeOfPromise(source);
        if (awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation))
          addRelatedInfo(errorOutputContainer.errors[0], createDiagnosticForNode(errorNode, qd.Did_you_forget_to_use_await));
      }
    }
  }
  function getThisArgumentOfCall(node: CallLikeExpression): LeftHandSideExpression | undefined {
    if (node.kind === Syntax.CallExpression) {
      const callee = skipOuterExpressions(node.expression);
      if (isAccessExpression(callee)) return callee.expression;
    }
  }
  function createSyntheticExpression(parent: Node, type: Type, isSpread?: boolean, tupleNameSource?: ParameterDeclaration | NamedTupleMember) {
    const result = <SyntheticExpression>createNode(Syntax.SyntheticExpression, parent.pos, parent.end);
    result.parent = parent;
    result.type = type;
    result.isSpread = isSpread || false;
    result.tupleNameSource = tupleNameSource;
    return result;
  }
  function getEffectiveCallArguments(node: CallLikeExpression): readonly Expression[] {
    if (node.kind === Syntax.TaggedTemplateExpression) {
      const template = node.template;
      const args: Expression[] = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
      if (template.kind === Syntax.TemplateExpression) {
        forEach(template.templateSpans, (span) => {
          args.push(span.expression);
        });
      }
      return args;
    }
    if (node.kind === Syntax.Decorator) return getEffectiveDecoratorArguments(node);
    if (qc.isJsx.openingLikeElement(node)) return node.attributes.properties.length > 0 || (qc.is.kind(JsxOpeningElement, node) && node.parent.children.length > 0) ? [node.attributes] : empty;
    const args = node.arguments || empty;
    const length = args.length;
    if (length && isSpreadArgument(args[length - 1]) && getSpreadArgumentIndex(args) === length - 1) {
      const spreadArgument = <SpreadElement>args[length - 1];
      const type = flowLoopCount ? checkExpression(spreadArgument.expression) : checkExpressionCached(spreadArgument.expression);
      if (isTupleType(type)) {
        const typeArguments = getTypeArguments(<TypeReference>type);
        const restIndex = type.target.hasRestElement ? typeArguments.length - 1 : -1;
        const syntheticArgs = map(typeArguments, (t, i) => createSyntheticExpression(spreadArgument, t, i === restIndex, type.target.labeledElementDeclarations?.[i]));
        return concatenate(args.slice(0, length - 1), syntheticArgs);
      }
    }
    return args;
  }
  function getEffectiveDecoratorArguments(node: Decorator): readonly Expression[] {
    const parent = node.parent;
    const expr = node.expression;
    switch (parent.kind) {
      case Syntax.ClassDeclaration:
      case Syntax.ClassExpression:
        return [createSyntheticExpression(expr, getTypeOfSymbol(getSymbolOfNode(parent)))];
      case Syntax.Parameter:
        const func = <FunctionLikeDeclaration>parent.parent;
        return [
          createSyntheticExpression(expr, parent.parent.kind === Syntax.Constructor ? getTypeOfSymbol(getSymbolOfNode(func)) : errorType),
          createSyntheticExpression(expr, anyType),
          createSyntheticExpression(expr, numberType),
        ];
      case Syntax.PropertyDeclaration:
      case Syntax.MethodDeclaration:
      case Syntax.GetAccessor:
      case Syntax.SetAccessor:
        const hasPropDesc = parent.kind !== Syntax.PropertyDeclaration;
        return [
          createSyntheticExpression(expr, getParentTypeOfClassElement(<ClassElement>parent)),
          createSyntheticExpression(expr, getClassElementPropertyKeyType(<ClassElement>parent)),
          createSyntheticExpression(expr, hasPropDesc ? createTypedPropertyDescriptorType(getTypeOfNode(parent)) : anyType),
        ];
    }
    return fail();
  }
  function getDecoratorArgumentCount(node: Decorator, signature: Signature) {
    switch (node.parent.kind) {
      case Syntax.ClassDeclaration:
      case Syntax.ClassExpression:
        return 1;
      case Syntax.PropertyDeclaration:
        return 2;
      case Syntax.MethodDeclaration:
      case Syntax.GetAccessor:
      case Syntax.SetAccessor:
        return signature.parameters.length <= 2 ? 2 : 3;
      case Syntax.Parameter:
        return 3;
      default:
        return fail();
    }
  }
  function getDiagnosticSpanForCallNode(node: CallExpression, doNotIncludeArguments?: boolean) {
    let start: number;
    let length: number;
    const sourceFile = qc.get.sourceFileOf(node);
    if (qc.is.kind(PropertyAccessExpression, node.expression)) {
      const nameSpan = getErrorSpanForNode(sourceFile, node.expression.name);
      start = nameSpan.start;
      length = doNotIncludeArguments ? nameSpan.length : node.end - start;
    } else {
      const expressionSpan = getErrorSpanForNode(sourceFile, node.expression);
      start = expressionSpan.start;
      length = doNotIncludeArguments ? expressionSpan.length : node.end - start;
    }
    return { start, length, sourceFile };
  }
  function getDiagnosticForCallNode(
    node: CallLikeExpression,
    message: DiagnosticMessage,
    arg0?: string | number,
    arg1?: string | number,
    arg2?: string | number,
    arg3?: string | number
  ): DiagnosticWithLocation {
    if (qc.is.kind(CallExpression, node)) {
      const { sourceFile, start, length } = getDiagnosticSpanForCallNode(node);
      return createFileDiagnostic(sourceFile, start, length, message, arg0, arg1, arg2, arg3);
    }
    return createDiagnosticForNode(node, message, arg0, arg1, arg2, arg3);
  }
  function getArgumentArityError(node: CallLikeExpression, signatures: readonly Signature[], args: readonly Expression[]) {
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    let belowArgCount = Number.NEGATIVE_INFINITY;
    let aboveArgCount = Number.POSITIVE_INFINITY;
    let argCount = args.length;
    let closestSignature: Signature | undefined;
    for (const sig of signatures) {
      const minCount = getMinArgumentCount(sig);
      const maxCount = getParameterCount(sig);
      if (minCount < argCount && minCount > belowArgCount) belowArgCount = minCount;
      if (argCount < maxCount && maxCount < aboveArgCount) aboveArgCount = maxCount;
      if (minCount < min) {
        min = minCount;
        closestSignature = sig;
      }
      max = Math.max(max, maxCount);
    }
    const hasRestParameter = some(signatures, hasEffectiveRestParameter);
    const paramRange = hasRestParameter ? min : min < max ? min + '-' + max : min;
    const hasSpreadArgument = getSpreadArgumentIndex(args) > -1;
    if (argCount <= max && hasSpreadArgument) argCount--;
    let spanArray: Nodes<Node>;
    let related: DiagnosticWithLocation | undefined;
    const error =
      hasRestParameter || hasSpreadArgument
        ? hasRestParameter && hasSpreadArgument
          ? qd.Expected_at_least_0_arguments_but_got_1_or_more
          : hasRestParameter
          ? qd.Expected_at_least_0_arguments_but_got_1
          : qd.Expected_0_arguments_but_got_1_or_more
        : qd.Expected_0_arguments_but_got_1;
    if (closestSignature && getMinArgumentCount(closestSignature) > argCount && closestSignature.declaration) {
      const paramDecl = closestSignature.declaration.parameters[closestSignature.thisParameter ? argCount + 1 : argCount];
      if (paramDecl) {
        related = createDiagnosticForNode(
          paramDecl,
          qc.is.kind(BindingPattern, paramDecl.name) ? qd.An_argument_matching_this_binding_pattern_was_not_provided : qd.An_argument_for_0_was_not_provided,
          !paramDecl.name ? argCount : !qc.is.kind(BindingPattern, paramDecl.name) ? idText(getFirstIdentifier(paramDecl.name)) : undefined
        );
      }
    }
    if (min < argCount && argCount < max)
      return getDiagnosticForCallNode(node, qd.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, argCount, belowArgCount, aboveArgCount);
    if (!hasSpreadArgument && argCount < min) {
      const diagnostic = getDiagnosticForCallNode(node, error, paramRange, argCount);
      return related ? addRelatedInfo(diagnostic, related) : diagnostic;
    }
    if (hasRestParameter || hasSpreadArgument) {
      spanArray = new Nodes(args);
      if (hasSpreadArgument && argCount) {
        const nextArg = elementAt(args, getSpreadArgumentIndex(args) + 1) || undefined;
        spanArray = new Nodes(args.slice(max > argCount && nextArg ? args.indexOf(nextArg) : Math.min(max, args.length - 1)));
      }
    } else {
      spanArray = new Nodes(args.slice(max));
    }
    spanArray.pos = first(spanArray).pos;
    spanArray.end = last(spanArray).end;
    if (spanArray.end === spanArray.pos) spanArray.end++;
    const diagnostic = createDiagnosticForNodes(qc.get.sourceFileOf(node), spanArray, error, paramRange, argCount);
    return related ? addRelatedInfo(diagnostic, related) : diagnostic;
  }
  function getTypeArgumentArityError(node: Node, signatures: readonly Signature[], typeArguments: Nodes<TypeNode>) {
    const argCount = typeArguments.length;
    if (signatures.length === 1) {
      const sig = signatures[0];
      const min = getMinTypeArgumentCount(sig.typeParameters);
      const max = length(sig.typeParameters);
      return createDiagnosticForNodes(qc.get.sourceFileOf(node), typeArguments, qd.Expected_0_type_arguments_but_got_1, min < max ? min + '-' + max : min, argCount);
    }
    let belowArgCount = -Infinity;
    let aboveArgCount = Infinity;
    for (const sig of signatures) {
      const min = getMinTypeArgumentCount(sig.typeParameters);
      const max = length(sig.typeParameters);
      if (min > argCount) aboveArgCount = Math.min(aboveArgCount, min);
      else if (max < argCount) {
        belowArgCount = Math.max(belowArgCount, max);
      }
    }
    if (belowArgCount !== -Infinity && aboveArgCount !== Infinity) {
      return createDiagnosticForNodes(
        qc.get.sourceFileOf(node),
        typeArguments,
        qd.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments,
        argCount,
        belowArgCount,
        aboveArgCount
      );
    }
    return createDiagnosticForNodes(qc.get.sourceFileOf(node), typeArguments, qd.Expected_0_type_arguments_but_got_1, belowArgCount === -Infinity ? aboveArgCount : belowArgCount, argCount);
  }
  function resolveCall(
    node: CallLikeExpression,
    signatures: readonly Signature[],
    candidatesOutArray: Signature[] | undefined,
    checkMode: CheckMode,
    callChainFlags: SignatureFlags,
    fallbackError?: DiagnosticMessage
  ): Signature {
    const isTaggedTemplate = node.kind === Syntax.TaggedTemplateExpression;
    const isDecorator = node.kind === Syntax.Decorator;
    const isJsxOpeningOrSelfClosingElement = qc.isJsx.openingLikeElement(node);
    const reportErrors = !candidatesOutArray;
    let typeArguments: Nodes<TypeNode> | undefined;
    if (!isDecorator) {
      typeArguments = (<CallExpression>node).typeArguments;
      if (isTaggedTemplate || isJsxOpeningOrSelfClosingElement || (<CallExpression>node).expression.kind !== Syntax.SuperKeyword) forEach(typeArguments, checkSourceElement);
    }
    const candidates = candidatesOutArray || [];
    reorderCandidates(signatures, candidates, callChainFlags);
    if (!candidates.length) {
      if (reportErrors) diagnostics.add(getDiagnosticForCallNode(node, qd.Call_target_does_not_contain_any_signatures));
      return resolveErrorCall(node);
    }
    const args = getEffectiveCallArguments(node);
    const isSingleNonGenericCandidate = candidates.length === 1 && !candidates[0].typeParameters;
    let argCheckMode = !isDecorator && !isSingleNonGenericCandidate && some(args, isContextSensitive) ? CheckMode.SkipContextSensitive : CheckMode.Normal;
    let candidatesForArgumentError: Signature[] | undefined;
    let candidateForArgumentArityError: Signature | undefined;
    let candidateForTypeArgumentError: Signature | undefined;
    let result: Signature | undefined;
    const signatureHelpTrailingComma = !!(checkMode & CheckMode.IsForSignatureHelp) && node.kind === Syntax.CallExpression && node.arguments.trailingComma;
    if (candidates.length > 1) result = chooseOverload(candidates, subtypeRelation, signatureHelpTrailingComma);
    if (!result) result = chooseOverload(candidates, assignableRelation, signatureHelpTrailingComma);
    if (result) return result;
    if (reportErrors) {
      if (candidatesForArgumentError) {
        if (candidatesForArgumentError.length === 1 || candidatesForArgumentError.length > 3) {
          const last = candidatesForArgumentError[candidatesForArgumentError.length - 1];
          let chain: DiagnosticMessageChain | undefined;
          if (candidatesForArgumentError.length > 3) {
            chain = chainDiagnosticMessages(chain, qd.The_last_overload_gave_the_following_error);
            chain = chainDiagnosticMessages(chain, qd.No_overload_matches_this_call);
          }
          const diags = getSignatureApplicabilityError(node, args, last, assignableRelation, CheckMode.Normal, true, () => chain);
          if (diags) {
            for (const d of diags) {
              if (last.declaration && candidatesForArgumentError.length > 3) addRelatedInfo(d, createDiagnosticForNode(last.declaration, qd.The_last_overload_is_declared_here));
              diagnostics.add(d);
            }
          } else {
            fail('No error for last overload signature');
          }
        } else {
          const allDiagnostics: (readonly DiagnosticRelatedInformation[])[] = [];
          let max = 0;
          let min = Number.MAX_VALUE;
          let minIndex = 0;
          let i = 0;
          for (const c of candidatesForArgumentError) {
            const chain = () => chainDiagnosticMessages(undefined, qd.Overload_0_of_1_2_gave_the_following_error, i + 1, candidates.length, signatureToString(c));
            const diags = getSignatureApplicabilityError(node, args, c, assignableRelation, CheckMode.Normal, true, chain);
            if (diags) {
              if (diags.length <= min) {
                min = diags.length;
                minIndex = i;
              }
              max = Math.max(max, diags.length);
              allqd.push(diags);
            } else {
              fail('No error for 3 or fewer overload signatures');
            }
            i++;
          }
          const diags = max > 1 ? allDiagnostics[minIndex] : flatten(allDiagnostics);
          assert(diags.length > 0, 'No errors reported for 3 or fewer overload signatures');
          const chain = chainDiagnosticMessages(
            map(diags, (d) => (typeof d.messageText === 'string' ? (d as DiagnosticMessageChain) : d.messageText)),
            qd.No_overload_matches_this_call
          );
          const related = flatMap(diags, (d) => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[];
          if (every(diags, (d) => d.start === diags[0].start && d.length === diags[0].length && d.file === diags[0].file)) {
            const { file, start, length } = diags[0];
            diagnostics.add({ file, start, length, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related });
          } else {
            diagnostics.add(createDiagnosticForNodeFromMessageChain(node, chain, related));
          }
        }
      } else if (candidateForArgumentArityError) {
        diagnostics.add(getArgumentArityError(node, [candidateForArgumentArityError], args));
      } else if (candidateForTypeArgumentError) {
        checkTypeArguments(candidateForTypeArgumentError, (node as CallExpression | TaggedTemplateExpression | JsxOpeningLikeElement).typeArguments!, true, fallbackError);
      } else {
        const signaturesWithCorrectTypeArgumentArity = filter(signatures, (s) => hasCorrectTypeArgumentArity(s, typeArguments));
        if (signaturesWithCorrectTypeArgumentArity.length === 0) diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments!));
        else if (!isDecorator) {
          diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args));
        } else if (fallbackError) {
          diagnostics.add(getDiagnosticForCallNode(node, fallbackError));
        }
      }
    }
    return getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray);
    function chooseOverload(candidates: Signature[], relation: qb.QMap<RelationComparisonResult>, signatureHelpTrailingComma = false) {
      candidatesForArgumentError = undefined;
      candidateForArgumentArityError = undefined;
      candidateForTypeArgumentError = undefined;
      if (isSingleNonGenericCandidate) {
        const candidate = candidates[0];
        if (some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) return;
        if (getSignatureApplicabilityError(node, args, candidate, relation, CheckMode.Normal, false, undefined)) {
          candidatesForArgumentError = [candidate];
          return;
        }
        return candidate;
      }
      for (let candidateIndex = 0; candidateIndex < candidates.length; candidateIndex++) {
        const candidate = candidates[candidateIndex];
        if (!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) continue;
        let checkCandidate: Signature;
        let inferenceContext: InferenceContext | undefined;
        if (candidate.typeParameters) {
          let typeArgumentTypes: Type[] | undefined;
          if (some(typeArguments)) {
            typeArgumentTypes = checkTypeArguments(candidate, typeArguments, false);
            if (!typeArgumentTypes) {
              candidateForTypeArgumentError = candidate;
              continue;
            }
          } else {
            inferenceContext = createInferenceContext(candidate.typeParameters, candidate, isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None);
            typeArgumentTypes = inferTypeArguments(node, candidate, args, argCheckMode | CheckMode.SkipGenericFunctions, inferenceContext);
            argCheckMode |= inferenceContext.flags & InferenceFlags.SkippedGenericFunction ? CheckMode.SkipGenericFunctions : CheckMode.Normal;
          }
          checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);
          if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {
            candidateForArgumentArityError = checkCandidate;
            continue;
          }
        } else {
          checkCandidate = candidate;
        }
        if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, false, undefined)) {
          (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
          continue;
        }
        if (argCheckMode) {
          argCheckMode = CheckMode.Normal;
          if (inferenceContext) {
            const typeArgumentTypes = inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext);
            checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);
            if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {
              candidateForArgumentArityError = checkCandidate;
              continue;
            }
          }
          if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, false, undefined)) {
            (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
            continue;
          }
        }
        candidates[candidateIndex] = checkCandidate;
        return checkCandidate;
      }
      return;
    }
  }
  function getCandidateForOverloadFailure(node: CallLikeExpression, candidates: Signature[], args: readonly Expression[], hasCandidatesOutArray: boolean): Signature {
    assert(candidates.length > 0);
    checkNodeDeferred(node);
    return hasCandidatesOutArray || candidates.length === 1 || candidates.some((c) => !!c.typeParameters)
      ? pickLongestCandidateSignature(node, candidates, args)
      : createUnionOfSignaturesForOverloadFailure(candidates);
  }
  function createUnionOfSignaturesForOverloadFailure(candidates: readonly Signature[]): Signature {
    const thisParameters = mapDefined(candidates, (c) => c.thisParameter);
    let thisParameter: Symbol | undefined;
    if (thisParameters.length) thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map(getTypeOfParameter));
    const { min: minArgumentCount, max: maxNonRestParam } = minAndMax(candidates, getNumNonRestParameters);
    const parameters: Symbol[] = [];
    for (let i = 0; i < maxNonRestParam; i++) {
      const symbols = mapDefined(candidates, (s) =>
        signatureHasRestParameter(s) ? (i < s.parameters.length - 1 ? s.parameters[i] : last(s.parameters)) : i < s.parameters.length ? s.parameters[i] : undefined
      );
      assert(symbols.length !== 0);
      parameters.push(
        createCombinedSymbolFromTypes(
          symbols,
          mapDefined(candidates, (candidate) => tryGetTypeAtPosition(candidate, i))
        )
      );
    }
    const restParameterSymbols = mapDefined(candidates, (c) => (signatureHasRestParameter(c) ? last(c.parameters) : undefined));
    let flags = SignatureFlags.None;
    if (restParameterSymbols.length !== 0) {
      const type = createArrayType(getUnionType(mapDefined(candidates, tryGetRestTypeOfSignature), UnionReduction.Subtype));
      parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type));
      flags |= SignatureFlags.HasRestParameter;
    }
    if (candidates.some(signatureHasLiteralTypes)) flags |= SignatureFlags.HasLiteralTypes;
    return createSignature(candidates[0].declaration, undefined, thisParameter, parameters, getIntersectionType(candidates.map(getReturnTypeOfSignature)), undefined, minArgumentCount, flags);
  }
  function getNumNonRestParameters(signature: Signature): number {
    const numParams = signature.parameters.length;
    return signatureHasRestParameter(signature) ? numParams - 1 : numParams;
  }
  function createCombinedSymbolFromTypes(sources: readonly Symbol[], types: Type[]): Symbol {
    return createCombinedSymbolForOverloadFailure(sources, getUnionType(types, UnionReduction.Subtype));
  }
  function createCombinedSymbolForOverloadFailure(sources: readonly Symbol[], type: Type): Symbol {
    return createSymbolWithType(first(sources), type);
  }
  function pickLongestCandidateSignature(node: CallLikeExpression, candidates: Signature[], args: readonly Expression[]): Signature {
    const bestIndex = getLongestCandidateIndex(candidates, apparentArgumentCount === undefined ? args.length : apparentArgumentCount);
    const candidate = candidates[bestIndex];
    const { typeParameters } = candidate;
    if (!typeParameters) return candidate;
    const typeArgumentNodes: readonly TypeNode[] | undefined = callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined;
    const instantiated = typeArgumentNodes
      ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node)))
      : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args);
    candidates[bestIndex] = instantiated;
    return instantiated;
  }
  function getTypeArgumentsFromNodes(typeArgumentNodes: readonly TypeNode[], typeParameters: readonly TypeParameter[], isJs: boolean): readonly Type[] {
    const typeArguments = typeArgumentNodes.map(getTypeOfNode);
    while (typeArguments.length > typeParameters.length) {
      typeArguments.pop();
    }
    while (typeArguments.length < typeParameters.length) {
      typeArguments.push(getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs));
    }
    return typeArguments;
  }
  function inferSignatureInstantiationForOverloadFailure(node: CallLikeExpression, typeParameters: readonly TypeParameter[], candidate: Signature, args: readonly Expression[]): Signature {
    const inferenceContext = createInferenceContext(typeParameters, candidate, isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None);
    const typeArgumentTypes = inferTypeArguments(node, candidate, args, CheckMode.SkipContextSensitive | CheckMode.SkipGenericFunctions, inferenceContext);
    return createSignatureInstantiation(candidate, typeArgumentTypes);
  }
  function getLongestCandidateIndex(candidates: Signature[], argsCount: number): number {
    let maxParamsIndex = -1;
    let maxParams = -1;
    for (let i = 0; i < candidates.length; i++) {
      const candidate = candidates[i];
      const paramCount = getParameterCount(candidate);
      if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) return i;
      if (paramCount > maxParams) {
        maxParams = paramCount;
        maxParamsIndex = i;
      }
    }
    return maxParamsIndex;
  }
  function resolveCallExpression(node: CallExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
    if (node.expression.kind === Syntax.SuperKeyword) {
      const superType = checkSuperExpression(node.expression);
      if (isTypeAny(superType)) {
        for (const arg of node.arguments) {
          checkExpression(arg);
        }
        return anySignature;
      }
      if (superType !== errorType) {
        const baseTypeNode = getEffectiveBaseTypeNode(qc.get.containingClass(node)!);
        if (baseTypeNode) {
          const baseConstructors = getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode);
          return resolveCall(node, baseConstructors, candidatesOutArray, checkMode, SignatureFlags.None);
        }
      }
      return resolveUntypedCall(node);
    }
    let callChainFlags: SignatureFlags;
    let funcType = checkExpression(node.expression);
    if (qc.is.callChain(node)) {
      const nonOptionalType = getOptionalExpressionType(funcType, node.expression);
      callChainFlags = nonOptionalType === funcType ? SignatureFlags.None : isOutermostOptionalChain(node) ? SignatureFlags.IsOuterCallChain : SignatureFlags.IsInnerCallChain;
      funcType = nonOptionalType;
    } else {
      callChainFlags = SignatureFlags.None;
    }
    funcType = checkNonNullTypeWithReporter(funcType, node.expression, reportCannotInvokePossiblyNullOrUndefinedError);
    if (funcType === silentNeverType) return silentNeverSignature;
    const apparentType = getApparentType(funcType);
    if (apparentType === errorType) return resolveErrorCall(node);
    const callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
    const numConstructSignatures = getSignaturesOfType(apparentType, SignatureKind.Construct).length;
    if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) {
      if (funcType !== errorType && node.typeArguments) error(node, qd.Untyped_function_calls_may_not_accept_type_arguments);
      return resolveUntypedCall(node);
    }
    if (!callSignatures.length) {
      if (numConstructSignatures) error(node, qd.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
      else {
        let relatedInformation: DiagnosticRelatedInformation | undefined;
        if (node.arguments.length === 1) {
          const text = qc.get.sourceFileOf(node).text;
          if (syntax.is.lineBreak(text.charCodeAt(syntax.skipTrivia(text, node.expression.end, true) - 1)))
            relatedInformation = createDiagnosticForNode(node.expression, qd.Are_you_missing_a_semicolon);
        }
        invocationError(node.expression, apparentType, SignatureKind.Call, relatedInformation);
      }
      return resolveErrorCall(node);
    }
    if (checkMode & CheckMode.SkipGenericFunctions && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction)) {
      skippedGenericFunction(node, checkMode);
      return resolvingSignature;
    }
    if (callSignatures.some((sig) => isInJSFile(sig.declaration) && !!qc.getDoc.classTag(sig.declaration!))) {
      error(node, qd.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
      return resolveErrorCall(node);
    }
    return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags);
  }
  function isGenericFunctionReturningFunction(signature: Signature) {
    return !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature)));
  }
  function isUntypedFunctionCall(funcType: Type, apparentFuncType: Type, numCallSignatures: number, numConstructSignatures: number): boolean {
    return (
      isTypeAny(funcType) ||
      (isTypeAny(apparentFuncType) && !!(funcType.flags & TypeFlags.TypeParameter)) ||
      (!numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags & (TypeFlags.Union | TypeFlags.Never)) && isTypeAssignableTo(funcType, globalFunctionType))
    );
  }
  function resolveNewExpression(node: NewExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
    let expressionType = checkNonNullExpression(node.expression);
    if (expressionType === silentNeverType) return silentNeverSignature;
    expressionType = getApparentType(expressionType);
    if (expressionType === errorType) return resolveErrorCall(node);
    if (isTypeAny(expressionType)) {
      if (node.typeArguments) error(node, qd.Untyped_function_calls_may_not_accept_type_arguments);
      return resolveUntypedCall(node);
    }
    const constructSignatures = getSignaturesOfType(expressionType, SignatureKind.Construct);
    if (constructSignatures.length) {
      if (!isConstructorAccessible(node, constructSignatures[0])) return resolveErrorCall(node);
      const valueDecl = expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol);
      if (valueDecl && hasSyntacticModifier(valueDecl, ModifierFlags.Abstract)) {
        error(node, qd.Cannot_create_an_instance_of_an_abstract_class);
        return resolveErrorCall(node);
      }
      return resolveCall(node, constructSignatures, candidatesOutArray, checkMode, SignatureFlags.None);
    }
    const callSignatures = getSignaturesOfType(expressionType, SignatureKind.Call);
    if (callSignatures.length) {
      const signature = resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlags.None);
      if (!noImplicitAny) {
        if (signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) !== voidType)
          error(node, qd.Only_a_void_function_can_be_called_with_the_new_keyword);
        if (getThisTypeOfSignature(signature) === voidType) error(node, qd.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void);
      }
      return signature;
    }
    invocationError(node.expression, expressionType, SignatureKind.Construct);
    return resolveErrorCall(node);
  }
  function typeHasProtectedAccessibleBase(target: Symbol, type: InterfaceType): boolean {
    const baseTypes = getBaseTypes(type);
    if (!length(baseTypes)) return false;
    const firstBase = baseTypes[0];
    if (firstBase.flags & TypeFlags.Intersection) {
      const types = (firstBase as IntersectionType).types;
      const mixinFlags = findMixins(types);
      let i = 0;
      for (const intersectionMember of (firstBase as IntersectionType).types) {
        if (!mixinFlags[i]) {
          if (getObjectFlags(intersectionMember) & (ObjectFlags.Class | ObjectFlags.Interface)) {
            if (intersectionMember.symbol === target) return true;
            if (typeHasProtectedAccessibleBase(target, intersectionMember as InterfaceType)) return true;
          }
        }
        i++;
      }
      return false;
    }
    if (firstBase.symbol === target) return true;
    return typeHasProtectedAccessibleBase(target, firstBase as InterfaceType);
  }
  function isConstructorAccessible(node: NewExpression, signature: Signature) {
    if (!signature || !signature.declaration) return true;
    const declaration = signature.declaration;
    const modifiers = getSelectedEffectiveModifierFlags(declaration, ModifierFlags.NonPublicAccessibilityModifier);
    if (!modifiers || declaration.kind !== Syntax.Constructor) return true;
    const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(declaration.parent.symbol)!;
    const declaringClass = <InterfaceType>getDeclaredTypeOfSymbol(declaration.parent.symbol);
    if (!isNodeWithinClass(node, declaringClassDeclaration)) {
      const containingClass = qc.get.containingClass(node);
      if (containingClass && modifiers & ModifierFlags.Protected) {
        const containingType = getTypeOfNode(containingClass);
        if (typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType as InterfaceType)) return true;
      }
      if (modifiers & ModifierFlags.Private) error(node, qd.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
      if (modifiers & ModifierFlags.Protected) error(node, qd.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
      return false;
    }
    return true;
  }
  function invocationErrorDetails(errorTarget: Node, apparentType: Type, kind: SignatureKind): { messageChain: DiagnosticMessageChain; relatedMessage: DiagnosticMessage | undefined } {
    let errorInfo: DiagnosticMessageChain | undefined;
    const isCall = kind === SignatureKind.Call;
    const awaitedType = getAwaitedType(apparentType);
    const maybeMissingAwait = awaitedType && getSignaturesOfType(awaitedType, kind).length > 0;
    if (apparentType.flags & TypeFlags.Union) {
      const types = (apparentType as UnionType).types;
      let hasSignatures = false;
      for (const constituent of types) {
        const signatures = getSignaturesOfType(constituent, kind);
        if (signatures.length !== 0) {
          hasSignatures = true;
          if (errorInfo) break;
        } else {
          if (!errorInfo) {
            errorInfo = chainDiagnosticMessages(errorInfo, isCall ? qd.Type_0_has_no_call_signatures : qd.Type_0_has_no_construct_signatures, typeToString(constituent));
            errorInfo = chainDiagnosticMessages(errorInfo, isCall ? qd.Not_all_constituents_of_type_0_are_callable : qd.Not_all_constituents_of_type_0_are_constructable, typeToString(apparentType));
          }
          if (hasSignatures) break;
        }
      }
      if (!hasSignatures) errorInfo = chainDiagnosticMessages(undefined, isCall ? qd.No_constituent_of_type_0_is_callable : qd.No_constituent_of_type_0_is_constructable, typeToString(apparentType));
      if (!errorInfo) {
        errorInfo = chainDiagnosticMessages(
          errorInfo,
          isCall
            ? qd.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other
            : qd.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other,
          typeToString(apparentType)
        );
      }
    } else {
      errorInfo = chainDiagnosticMessages(errorInfo, isCall ? qd.Type_0_has_no_call_signatures : qd.Type_0_has_no_construct_signatures, typeToString(apparentType));
    }
    let headMessage = isCall ? qd.This_expression_is_not_callable : qd.This_expression_is_not_constructable;
    if (qc.is.kind(CallExpression, errorTarget.parent) && errorTarget.parent.arguments.length === 0) {
      const { resolvedSymbol } = getNodeLinks(errorTarget);
      if (resolvedSymbol && resolvedSymbol.flags & SymbolFlags.GetAccessor) headMessage = qd.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without;
    }
    return {
      messageChain: chainDiagnosticMessages(errorInfo, headMessage),
      relatedMessage: maybeMissingAwait ? qd.Did_you_forget_to_use_await : undefined,
    };
  }
  function invocationError(errorTarget: Node, apparentType: Type, kind: SignatureKind, relatedInformation?: DiagnosticRelatedInformation) {
    const { messageChain, relatedMessage: relatedInfo } = invocationErrorDetails(errorTarget, apparentType, kind);
    const diagnostic = createDiagnosticForNodeFromMessageChain(errorTarget, messageChain);
    if (relatedInfo) addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo));
    if (qc.is.kind(CallExpression, errorTarget.parent)) {
      const { start, length } = getDiagnosticSpanForCallNode(errorTarget.parent, true);
      diagnostic.start = start;
      diagnostic.length = length;
    }
    diagnostics.add(diagnostic);
    invocationErrorRecovery(apparentType, kind, relatedInformation ? addRelatedInfo(diagnostic, relatedInformation) : diagnostic);
  }
  function invocationErrorRecovery(apparentType: Type, kind: SignatureKind, diagnostic: Diagnostic) {
    if (!apparentType.symbol) return;
    const importNode = s.getLinks(apparentType.symbol).originatingImport;
    if (importNode && !qc.is.importCall(importNode)) {
      const sigs = getSignaturesOfType(getTypeOfSymbol(s.getLinks(apparentType.symbol).target!), kind);
      if (!sigs || !sigs.length) return;
      addRelatedInfo(
        diagnostic,
        createDiagnosticForNode(
          importNode,
          qd.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead
        )
      );
    }
  }
  function resolveTaggedTemplateExpression(node: TaggedTemplateExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
    const tagType = checkExpression(node.tag);
    const apparentType = getApparentType(tagType);
    if (apparentType === errorType) return resolveErrorCall(node);
    const callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
    const numConstructSignatures = getSignaturesOfType(apparentType, SignatureKind.Construct).length;
    if (isUntypedFunctionCall(tagType, apparentType, callSignatures.length, numConstructSignatures)) return resolveUntypedCall(node);
    if (!callSignatures.length) {
      invocationError(node.tag, apparentType, SignatureKind.Call);
      return resolveErrorCall(node);
    }
    return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlags.None);
  }
  function getDiagnosticHeadMessageForDecoratorResolution(node: Decorator) {
    switch (node.parent.kind) {
      case Syntax.ClassDeclaration:
      case Syntax.ClassExpression:
        return qd.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;
      case Syntax.Parameter:
        return qd.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;
      case Syntax.PropertyDeclaration:
        return qd.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;
      case Syntax.MethodDeclaration:
      case Syntax.GetAccessor:
      case Syntax.SetAccessor:
        return qd.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;
      default:
        return fail();
    }
  }
  function resolveDecorator(node: Decorator, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
    const funcType = checkExpression(node.expression);
    const apparentType = getApparentType(funcType);
    if (apparentType === errorType) return resolveErrorCall(node);
    const callSignatures = getSignaturesOfType(apparentType, SignatureKind.Call);
    const numConstructSignatures = getSignaturesOfType(apparentType, SignatureKind.Construct).length;
    if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) return resolveUntypedCall(node);
    if (isPotentiallyUncalledDecorator(node, callSignatures)) {
      const nodeStr = qc.get.textOf(node.expression, false);
      error(node, qd._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr);
      return resolveErrorCall(node);
    }
    const headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
    if (!callSignatures.length) {
      const errorDetails = invocationErrorDetails(node.expression, apparentType, SignatureKind.Call);
      const messageChain = chainDiagnosticMessages(errorDetails.messageChain, headMessage);
      const diag = createDiagnosticForNodeFromMessageChain(node.expression, messageChain);
      if (errorDetails.relatedMessage) addRelatedInfo(diag, createDiagnosticForNode(node.expression, errorDetails.relatedMessage));
      diagnostics.add(diag);
      invocationErrorRecovery(apparentType, SignatureKind.Call, diag);
      return resolveErrorCall(node);
    }
    return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlags.None, headMessage);
  }
  function createSignatureForJSXIntrinsic(node: JsxOpeningLikeElement, result: Type): Signature {
    const namespace = getJsxNamespaceAt(node);
    const exports = namespace && namespace.getExportsOfSymbol();
    const typeSymbol = exports && getSymbol(exports, JsxNames.Element, SymbolFlags.Type);
    const returnNode = typeSymbol && nodeBuilder.symbolToEntityName(typeSymbol, SymbolFlags.Type, node);
    const declaration = FunctionTypeNode.create(
      undefined,
      [new qc.ParameterDeclaration(undefined, undefined, undefined, 'props', undefined, nodeBuilder.typeToTypeNode(result, node))],
      returnNode ? TypeReferenceNode.create(returnNode, undefined) : new qc.KeywordTypeNode(Syntax.AnyKeyword)
    );
    const parameterSymbol = new QSymbol(SymbolFlags.FunctionScopedVariable, 'props' as __String);
    parameterSymbol.type = result;
    return createSignature(declaration, undefined, undefined, [parameterSymbol], typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType, undefined, 1, SignatureFlags.None);
  }
  function resolveJsxOpeningLikeElement(node: JsxOpeningLikeElement, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
    if (isJsxIntrinsicIdentifier(node.tagName)) {
      const result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
      const fakeSignature = createSignatureForJSXIntrinsic(node, result);
      checkTypeAssignableToAndOptionallyElaborate(
        checkExpressionWithContextualType(node.attributes, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), undefined, CheckMode.Normal),
        result,
        node.tagName,
        node.attributes
      );
      return fakeSignature;
    }
    const exprTypes = checkExpression(node.tagName);
    const apparentType = getApparentType(exprTypes);
    if (apparentType === errorType) return resolveErrorCall(node);
    const signatures = getUninstantiatedJsxSignaturesOfType(exprTypes, node);
    if (isUntypedFunctionCall(exprTypes, apparentType, signatures.length, 0)) return resolveUntypedCall(node);
    if (signatures.length === 0) {
      error(node.tagName, qd.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, qc.get.textOf(node.tagName));
      return resolveErrorCall(node);
    }
    return resolveCall(node, signatures, candidatesOutArray, checkMode, SignatureFlags.None);
  }
  function isPotentiallyUncalledDecorator(decorator: Decorator, signatures: readonly Signature[]) {
    return (
      signatures.length &&
      every(signatures, (signature) => signature.minArgumentCount === 0 && !signatureHasRestParameter(signature) && signature.parameters.length < getDecoratorArgumentCount(decorator, signature))
    );
  }
  function resolveSignature(node: CallLikeExpression, candidatesOutArray: Signature[] | undefined, checkMode: CheckMode): Signature {
    switch (node.kind) {
      case Syntax.CallExpression:
        return resolveCallExpression(node, candidatesOutArray, checkMode);
      case Syntax.NewExpression:
        return resolveNewExpression(node, candidatesOutArray, checkMode);
      case Syntax.TaggedTemplateExpression:
        return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode);
      case Syntax.Decorator:
        return resolveDecorator(node, candidatesOutArray, checkMode);
      case Syntax.JsxOpeningElement:
      case Syntax.JsxSelfClosingElement:
        return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode);
    }
    throw Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.");
  }
  function getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[] | undefined, checkMode?: CheckMode): Signature {
    const links = getNodeLinks(node);
    const cached = links.resolvedSignature;
    if (cached && cached !== resolvingSignature && !candidatesOutArray) return cached;
    links.resolvedSignature = resolvingSignature;
    const result = resolveSignature(node, candidatesOutArray, checkMode || CheckMode.Normal);
    if (result !== resolvingSignature) links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached;
    return result;
  }
  function isJSConstructor(node: Node | undefined): node is FunctionDeclaration | FunctionExpression {
    if (!node || !isInJSFile(node)) return false;
    const func =
      qc.is.kind(FunctionDeclaration, node) || qc.is.kind(FunctionExpression, node)
        ? node
        : qc.is.kind(VariableDeclaration, node) && node.initializer && qc.is.kind(FunctionExpression, node.initializer)
        ? node.initializer
        : undefined;
    if (func) {
      if (qc.getDoc.classTag(node)) return true;
      const symbol = getSymbolOfNode(func);
      return !!symbol && hasEntries(symbol.members);
    }
    return false;
  }
  function mergeJSSymbols(target: Symbol, source: Symbol | undefined) {
    if (source) {
      const links = s.getLinks(source);
      if (!links.inferredClassSymbol || !links.inferredClassSymbol.has('' + target.getId())) {
        const inferred = isTransientSymbol(target) ? target : (target.clone() as TransientSymbol);
        inferred.exports = inferred.exports || new SymbolTable();
        inferred.members = inferred.members || new SymbolTable();
        inferred.flags |= source.flags & SymbolFlags.Class;
        if (hasEntries(source.exports)) inferred.exports.merge(source.exports);
        if (hasEntries(source.members)) inferred.members.merge(source.members);
        (links.inferredClassSymbol || (links.inferredClassSymbol = new qb.QMap<TransientSymbol>())).set('' + inferred.getId(), inferred);
        return inferred;
      }
      return links.inferredClassSymbol.get('' + target.getId());
    }
  }
  function getAssignedClassSymbol(decl: Declaration): Symbol | undefined {
    const assignmentSymbol =
      decl &&
      decl.parent &&
      ((qc.is.kind(FunctionDeclaration, decl) && getSymbolOfNode(decl)) ||
        (qc.is.kind(BinaryExpression, decl.parent) && getSymbolOfNode(decl.parent.left)) ||
        (qc.is.kind(VariableDeclaration, decl.parent) && getSymbolOfNode(decl.parent)));
    const prototype = assignmentSymbol && assignmentSymbol.exports && assignmentSymbol.exports.get('prototype' as __String);
    const init = prototype && prototype.valueDeclaration && getAssignedJSPrototype(prototype.valueDeclaration);
    return init ? getSymbolOfNode(init) : undefined;
  }
  function getAssignedJSPrototype(node: Node) {
    if (!node.parent) return false;
    let parent: Node = node.parent;
    while (parent && parent.kind === Syntax.PropertyAccessExpression) {
      parent = parent.parent;
    }
    if (parent && qc.is.kind(BinaryExpression, parent) && isPrototypeAccess(parent.left) && parent.operatorToken.kind === Syntax.EqualsToken) {
      const right = getInitializerOfBinaryExpression(parent);
      return qc.is.kind(ObjectLiteralExpression, right) && right;
    }
  }
  function checkCallExpression(node: CallExpression | NewExpression, checkMode?: CheckMode): Type {
    if (!checkGrammarTypeArguments(node, node.typeArguments)) checkGrammarArguments(node.arguments);
    const signature = getResolvedSignature(node, undefined, checkMode);
    if (signature === resolvingSignature) return nonInferrableType;
    if (node.expression.kind === Syntax.SuperKeyword) return voidType;
    if (node.kind === Syntax.NewExpression) {
      const declaration = signature.declaration;
      if (
        declaration &&
        declaration.kind !== Syntax.Constructor &&
        declaration.kind !== Syntax.ConstructSignature &&
        declaration.kind !== Syntax.ConstructorType &&
        !qc.isDoc.constructSignature(declaration) &&
        !isJSConstructor(declaration)
      ) {
        if (noImplicitAny) error(node, qd.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
        return anyType;
      }
    }
    if (isInJSFile(node) && isCommonJsRequire(node)) return resolveExternalModuleTypeByLiteral(node.arguments![0] as StringLiteral);
    const returnType = getReturnTypeOfSignature(signature);
    if (returnType.flags & TypeFlags.ESSymbolLike && isSymbolOrSymbolForCall(node)) return getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(node.parent));
    if (node.kind === Syntax.CallExpression && node.parent.kind === Syntax.ExpressionStatement && returnType.flags & TypeFlags.Void && getTypePredicateOfSignature(signature)) {
      if (!isDottedName(node.expression)) error(node.expression, qd.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name);
      else if (!getEffectsSignature(node)) {
        const diagnostic = error(node.expression, qd.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation);
        getTypeOfDottedName(node.expression, diagnostic);
      }
    }
    if (isInJSFile(node)) {
      const decl = getDeclarationOfExpando(node);
      if (decl) {
        const jsSymbol = getSymbolOfNode(decl);
        if (jsSymbol && hasEntries(jsSymbol.exports)) {
          const jsAssignmentType = createAnonymousType(jsSymbol, jsSymbol.exports, empty, empty, undefined, undefined);
          jsAssignmentType.objectFlags |= ObjectFlags.JSLiteral;
          return getIntersectionType([returnType, jsAssignmentType]);
        }
      }
    }
    return returnType;
  }
  function isSymbolOrSymbolForCall(node: Node) {
    if (!qc.is.kind(CallExpression, node)) return false;
    let left = node.expression;
    if (qc.is.kind(PropertyAccessExpression, left) && left.name.escapedText === 'for') left = left.expression;
    if (!qc.is.kind(Identifier, left) || left.escapedText !== 'Symbol') return false;
    const globalESSymbol = getGlobalESSymbolConstructorSymbol(false);
    if (!globalESSymbol) return false;
    return globalESSymbol === resolveName(left, 'Symbol' as __String, SymbolFlags.Value, undefined, undefined, false);
  }
  function checkImportCallExpression(node: ImportCall): Type {
    if (!checkGrammarArguments(node.arguments)) checkGrammarImportCallExpression(node);
    if (node.arguments.length === 0) return createPromiseReturnType(node, anyType);
    const specifier = node.arguments[0];
    const specifierType = checkExpressionCached(specifier);
    for (let i = 1; i < node.arguments.length; ++i) {
      checkExpressionCached(node.arguments[i]);
    }
    if (specifierType.flags & TypeFlags.Undefined || specifierType.flags & TypeFlags.Null || !isTypeAssignableTo(specifierType, stringType))
      error(specifier, qd.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType));
    const moduleSymbol = resolveExternalModuleName(node, specifier);
    if (moduleSymbol) {
      const esModuleSymbol = resolveESModuleSymbol(moduleSymbol, specifier, true, false);
      if (esModuleSymbol) return createPromiseReturnType(node, getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol));
    }
    return createPromiseReturnType(node, anyType);
  }
  function getTypeWithSyntheticDefaultImportType(type: Type, symbol: Symbol, originalSymbol: Symbol): Type {
    if (allowSyntheticDefaultImports && type && type !== errorType) {
      const synthType = type as SyntheticDefaultModuleType;
      if (!synthType.syntheticType) {
        const file = find(originalSymbol.declarations, isSourceFile);
        const hasSyntheticDefault = canHaveSyntheticDefault(file, originalSymbol, false);
        if (hasSyntheticDefault) {
          const memberTable = new SymbolTable();
          const newSymbol = new QSymbol(SymbolFlags.Alias, InternalSymbolName.Default);
          newSymbol.nameType = getLiteralType('default');
          newSymbol.target = symbol.resolveSymbol();
          memberTable.set(InternalSymbolName.Default, newSymbol);
          const anonymousSymbol = new QSymbol(SymbolFlags.TypeLiteral, InternalSymbolName.Type);
          const defaultContainingObject = createAnonymousType(anonymousSymbol, memberTable, empty, empty, undefined);
          anonymousSymbol.type = defaultContainingObject;
          synthType.syntheticType = isValidSpreadType(type) ? getSpreadType(type, defaultContainingObject, anonymousSymbol, false) : defaultContainingObject;
        } else {
          synthType.syntheticType = type;
        }
      }
      return synthType.syntheticType;
    }
    return type;
  }
  function isCommonJsRequire(node: Node): boolean {
    if (!isRequireCall(node, true)) return false;
    if (!qc.is.kind(Identifier, node.expression)) return fail();
    const resolvedRequire = resolveName(node.expression, node.expression.escapedText, SymbolFlags.Value, undefined, undefined, true)!;
    if (resolvedRequire === requireSymbol) return true;
    if (resolvedRequire.flags & SymbolFlags.Alias) return false;
    const targetDeclarationKind =
      resolvedRequire.flags & SymbolFlags.Function ? Syntax.FunctionDeclaration : resolvedRequire.flags & SymbolFlags.Variable ? Syntax.VariableDeclaration : Syntax.Unknown;
    if (targetDeclarationKind !== Syntax.Unknown) {
      const decl = getDeclarationOfKind(resolvedRequire, targetDeclarationKind)!;
      return !!decl && !!(decl.flags & NodeFlags.Ambient);
    }
    return false;
  }
  function checkTaggedTemplateExpression(node: TaggedTemplateExpression): Type {
    if (!checkGrammarTaggedTemplateChain(node)) checkGrammarTypeArguments(node, node.typeArguments);
    return getReturnTypeOfSignature(getResolvedSignature(node));
  }
  function checkAssertion(node: AssertionExpression) {
    return checkAssertionWorker(node, node.type, node.expression);
  }
  function isValidConstAssertionArgument(node: Node): boolean {
    switch (node.kind) {
      case Syntax.StringLiteral:
      case Syntax.NoSubstitutionLiteral:
      case Syntax.NumericLiteral:
      case Syntax.BigIntLiteral:
      case Syntax.TrueKeyword:
      case Syntax.FalseKeyword:
      case Syntax.ArrayLiteralExpression:
      case Syntax.ObjectLiteralExpression:
        return true;
      case Syntax.ParenthesizedExpression:
        return isValidConstAssertionArgument((<ParenthesizedExpression>node).expression);
      case Syntax.PrefixUnaryExpression:
        const op = (<PrefixUnaryExpression>node).operator;
        const arg = (<PrefixUnaryExpression>node).operand;
        return (op === Syntax.MinusToken && (arg.kind === Syntax.NumericLiteral || arg.kind === Syntax.BigIntLiteral)) || (op === Syntax.PlusToken && arg.kind === Syntax.NumericLiteral);
      case Syntax.PropertyAccessExpression:
      case Syntax.ElementAccessExpression:
        const expr = (<PropertyAccessExpression | ElementAccessExpression>node).expression;
        if (qc.is.kind(Identifier, expr)) {
          let symbol = getSymbolAtLocation(expr);
          if (symbol && symbol.flags & SymbolFlags.Alias) symbol = this.resolveAlias();
          return !!(symbol && symbol.flags & SymbolFlags.Enum && getEnumKind(symbol) === EnumKind.Literal);
        }
    }
    return false;
  }
  function checkAssertionWorker(errNode: Node, type: TypeNode, expression: UnaryExpression | Expression, checkMode?: CheckMode) {
    let exprType = checkExpression(expression, checkMode);
    if (qc.is.constTypeReference(type)) {
      if (!isValidConstAssertionArgument(expression)) error(expression, qd.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals);
      return getRegularTypeOfLiteralType(exprType);
    }
    checkSourceElement(type);
    exprType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(exprType));
    const targetType = getTypeFromTypeNode(type);
    if (produceDiagnostics && targetType !== errorType) {
      const widenedType = getWidenedType(exprType);
      if (!isTypeComparableTo(targetType, widenedType)) {
        checkTypeComparableTo(
          exprType,
          targetType,
          errNode,
          qd.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first
        );
      }
    }
    return targetType;
  }
  function checkNonNullChain(node: NonNullChain) {
    const leftType = checkExpression(node.expression);
    const nonOptionalType = getOptionalExpressionType(leftType, node.expression);
    return propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node, nonOptionalType !== leftType);
  }
  function checkNonNullAssertion(node: NonNullExpression) {
    return node.flags & NodeFlags.OptionalChain ? checkNonNullChain(node as NonNullChain) : getNonNullableType(checkExpression(node.expression));
  }
  function checkMetaProperty(node: MetaProperty): Type {
    checkGrammarMetaProperty(node);
    if (node.keywordToken === Syntax.NewKeyword) return checkNewTargetMetaProperty(node);
    if (node.keywordToken === Syntax.ImportKeyword) return checkImportMetaProperty(node);
    return Debug.assertNever(node.keywordToken);
  }
  function checkNewTargetMetaProperty(node: MetaProperty) {
    const container = qc.get.newTargetContainer(node);
    if (!container) {
      error(node, qd.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, 'new.target');
      return errorType;
    } else if (container.kind === Syntax.Constructor) {
      const symbol = getSymbolOfNode(container.parent as ClassLikeDeclaration);
      return this.getTypeOfSymbol();
    } else {
      const symbol = getSymbolOfNode(container)!;
      return this.getTypeOfSymbol();
    }
  }
  function checkImportMetaProperty(node: MetaProperty) {
    if (moduleKind !== ModuleKind.ESNext && moduleKind !== ModuleKind.System) error(node, qd.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_esnext_or_system);
    const file = qc.get.sourceFileOf(node);
    assert(!!(file.flags & NodeFlags.PossiblyContainsImportMeta), 'Containing file is missing import meta node flag.');
    assert(!!file.externalModuleIndicator, 'Containing file should be a module.');
    return node.name.escapedText === 'meta' ? getGlobalImportMetaType() : errorType;
  }
  function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember) {
    assert(qc.is.kind(Identifier, d.name));
    return d.name.escapedText;
  }
  function getParameterNameAtPosition(signature: Signature, pos: number) {
    const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
    if (pos < paramCount) return signature.parameters[pos].escName;
    const restParameter = signature.parameters[paramCount] || unknownSymbol;
    const restType = getTypeOfSymbol(restParameter);
    if (isTupleType(restType)) {
      const associatedNames = (<TupleType>(<TypeReference>restType).target).labeledElementDeclarations;
      const index = pos - paramCount;
      return (associatedNames && getTupleElementLabel(associatedNames[index])) || ((restParameter.escName + '_' + index) as __String);
    }
    return restParameter.escName;
  }
  function isValidDeclarationForTupleLabel(d: Declaration): d is NamedTupleMember | (ParameterDeclaration & { name: Identifier }) {
    return d.kind === Syntax.NamedTupleMember || (qc.is.kind(ParameterDeclaration, d) && d.name && qc.is.kind(Identifier, d.name));
  }
  function getNameableDeclarationAtPosition(signature: Signature, pos: number) {
    const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
    if (pos < paramCount) {
      const decl = signature.parameters[pos].valueDeclaration;
      return decl && isValidDeclarationForTupleLabel(decl) ? decl : undefined;
    }
    const restParameter = signature.parameters[paramCount] || unknownSymbol;
    const restType = getTypeOfSymbol(restParameter);
    if (isTupleType(restType)) {
      const associatedNames = (<TupleType>(<TypeReference>restType).target).labeledElementDeclarations;
      const index = pos - paramCount;
      return associatedNames && associatedNames[index];
    }
    return restParameter.valueDeclaration && isValidDeclarationForTupleLabel(restParameter.valueDeclaration) ? restParameter.valueDeclaration : undefined;
  }
  function getTypeAtPosition(signature: Signature, pos: number): Type {
    return tryGetTypeAtPosition(signature, pos) || anyType;
  }
  function tryGetTypeAtPosition(signature: Signature, pos: number): Type | undefined {
    const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
    if (pos < paramCount) return getTypeOfParameter(signature.parameters[pos]);
    if (signatureHasRestParameter(signature)) {
      const restType = getTypeOfSymbol(signature.parameters[paramCount]);
      const index = pos - paramCount;
      if (!isTupleType(restType) || restType.target.hasRestElement || index < getTypeArguments(restType).length) return getIndexedAccessType(restType, getLiteralType(index));
    }
    return;
  }
  function getRestTypeAtPosition(source: Signature, pos: number): Type {
    const paramCount = getParameterCount(source);
    const restType = getEffectiveRestType(source);
    const nonRestCount = paramCount - (restType ? 1 : 0);
    if (restType && pos === nonRestCount) return restType;
    const types = [];
    let names: (NamedTupleMember | ParameterDeclaration)[] | undefined = [];
    for (let i = pos; i < nonRestCount; i++) {
      types.push(getTypeAtPosition(source, i));
      const name = getNameableDeclarationAtPosition(source, i);
      if (name && names) names.push(name);
      else names = undefined;
    }
    if (restType) {
      types.push(getIndexedAccessType(restType, numberType));
      const name = getNameableDeclarationAtPosition(source, nonRestCount);
      if (name && names) names.push(name);
      else names = undefined;
    }
    const minArgumentCount = getMinArgumentCount(source);
    const minLength = minArgumentCount < pos ? 0 : minArgumentCount - pos;
    return createTupleType(types, minLength, !!restType, false, names);
  }
  function getParameterCount(signature: Signature) {
    const length = signature.parameters.length;
    if (signatureHasRestParameter(signature)) {
      const restType = getTypeOfSymbol(signature.parameters[length - 1]);
      if (isTupleType(restType)) return length + getTypeArguments(restType).length - 1;
    }
    return length;
  }
  function getMinArgumentCount(signature: Signature, strongArityForUntypedJS?: boolean) {
    if (signatureHasRestParameter(signature)) {
      const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
      if (isTupleType(restType)) {
        const minLength = restType.target.minLength;
        if (minLength > 0) return signature.parameters.length - 1 + minLength;
      }
    }
    if (!strongArityForUntypedJS && signature.flags & SignatureFlags.IsUntypedSignatureInJSFile) return 0;
    return signature.minArgumentCount;
  }
  function hasEffectiveRestParameter(signature: Signature) {
    if (signatureHasRestParameter(signature)) {
      const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
      return !isTupleType(restType) || restType.target.hasRestElement;
    }
    return false;
  }
  function getEffectiveRestType(signature: Signature) {
    if (signatureHasRestParameter(signature)) {
      const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
      return isTupleType(restType) ? getRestArrayTypeOfTupleType(restType) : restType;
    }
    return;
  }
  function getNonArrayRestType(signature: Signature) {
    const restType = getEffectiveRestType(signature);
    return restType && !isArrayType(restType) && !isTypeAny(restType) && (getReducedType(restType).flags & TypeFlags.Never) === 0 ? restType : undefined;
  }
  function getTypeOfFirstParameterOfSignature(signature: Signature) {
    return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType);
  }
  function getTypeOfFirstParameterOfSignatureWithFallback(signature: Signature, fallbackType: Type) {
    return signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType;
  }
  function inferFromAnnotatedParameters(signature: Signature, context: Signature, inferenceContext: InferenceContext) {
    const len = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
    for (let i = 0; i < len; i++) {
      const declaration = <ParameterDeclaration>signature.parameters[i].valueDeclaration;
      if (declaration.type) {
        const typeNode = getEffectiveTypeAnnotationNode(declaration);
        if (typeNode) inferTypes(inferenceContext.inferences, getTypeFromTypeNode(typeNode), getTypeAtPosition(context, i));
      }
    }
    const restType = getEffectiveRestType(context);
    if (restType && restType.flags & TypeFlags.TypeParameter) {
      const instantiatedContext = instantiateSignature(context, inferenceContext.nonFixingMapper);
      assignContextualParameterTypes(signature, instantiatedContext);
      const restPos = getParameterCount(context) - 1;
      inferTypes(inferenceContext.inferences, getRestTypeAtPosition(signature, restPos), restType);
    }
  }
  function assignContextualParameterTypes(signature: Signature, context: Signature) {
    signature.typeParameters = context.typeParameters;
    if (context.thisParameter) {
      const parameter = signature.thisParameter;
      if (!parameter || (parameter.valueDeclaration && !(<ParameterDeclaration>parameter.valueDeclaration).type)) {
        if (!parameter) signature.thisParameter = createSymbolWithType(context.thisParameter, undefined);
        assignParameterType(signature.thisParameter!, getTypeOfSymbol(context.thisParameter));
      }
    }
    const len = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
    for (let i = 0; i < len; i++) {
      const parameter = signature.parameters[i];
      if (!getEffectiveTypeAnnotationNode(<ParameterDeclaration>parameter.valueDeclaration)) {
        const contextualParameterType = tryGetTypeAtPosition(context, i);
        assignParameterType(parameter, contextualParameterType);
      }
    }
    if (signatureHasRestParameter(signature)) {
      const parameter = last(signature.parameters);
      if (isTransientSymbol(parameter) || !getEffectiveTypeAnnotationNode(<ParameterDeclaration>parameter.valueDeclaration)) {
        const contextualParameterType = getRestTypeAtPosition(context, len);
        assignParameterType(parameter, contextualParameterType);
      }
    }
  }
  function assignNonContextualParameterTypes(signature: Signature) {
    if (signature.thisParameter) assignParameterType(signature.thisParameter);
    for (const parameter of signature.parameters) {
      assignParameterType(parameter);
    }
  }
  function assignParameterType(parameter: Symbol, type?: Type) {
    const links = s.getLinks(parameter);
    if (!links.type) {
      const declaration = parameter.valueDeclaration as ParameterDeclaration;
      links.type = type || getWidenedTypeForVariableLikeDeclaration(declaration, true);
      if (declaration.name.kind !== Syntax.Identifier) {
        if (links.type === unknownType) links.type = getTypeFromBindingPattern(declaration.name);
        assignBindingElementTypes(declaration.name);
      }
    }
  }
  function assignBindingElementTypes(pattern: BindingPattern) {
    for (const element of pattern.elements) {
      if (!qc.is.kind(OmittedExpression, element)) {
        if (element.name.kind === Syntax.Identifier) s.getLinks(getSymbolOfNode(element)).type = getTypeForBindingElement(element);
        else assignBindingElementTypes(element.name);
      }
    }
  }
  function createPromiseType(promisedType: Type): Type {
    const globalPromiseType = getGlobalPromiseType(true);
    if (globalPromiseType !== emptyGenericType) {
      promisedType = getAwaitedType(promisedType) || unknownType;
      return createTypeReference(globalPromiseType, [promisedType]);
    }
    return unknownType;
  }
  function createPromiseLikeType(promisedType: Type): Type {
    const globalPromiseLikeType = getGlobalPromiseLikeType(true);
    if (globalPromiseLikeType !== emptyGenericType) {
      promisedType = getAwaitedType(promisedType) || unknownType;
      return createTypeReference(globalPromiseLikeType, [promisedType]);
    }
    return unknownType;
  }
  function createPromiseReturnType(func: FunctionLikeDeclaration | ImportCall, promisedType: Type) {
    const promiseType = createPromiseType(promisedType);
    if (promiseType === unknownType) {
      error(
        func,
        qc.is.importCall(func)
          ? qd.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option
          : qd.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option
      );
      return errorType;
    } else if (!getGlobalPromiseConstructorSymbol(true)) {
      error(
        func,
        qc.is.importCall(func)
          ? qd.A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option
          : qd.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option
      );
    }
    return promiseType;
  }
  function getReturnTypeFromBody(func: FunctionLikeDeclaration, checkMode?: CheckMode): Type {
    if (!func.body) return errorType;
    const functionFlags = getFunctionFlags(func);
    const isAsync = (functionFlags & FunctionFlags.Async) !== 0;
    const isGenerator = (functionFlags & FunctionFlags.Generator) !== 0;
    let returnType: Type | undefined;
    let yieldType: Type | undefined;
    let nextType: Type | undefined;
    let fallbackReturnType: Type = voidType;
    if (func.body.kind !== Syntax.Block) {
      returnType = checkExpressionCached(func.body, checkMode && checkMode & ~CheckMode.SkipGenericFunctions);
      if (isAsync) returnType = checkAwaitedType(returnType, func, qd.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
    } else if (isGenerator) {
      const returnTypes = checkAndAggregateReturnExpressionTypes(func, checkMode);
      if (!returnTypes) fallbackReturnType = neverType;
      else if (returnTypes.length > 0) returnType = getUnionType(returnTypes, UnionReduction.Subtype);
      const { yieldTypes, nextTypes } = checkAndAggregateYieldOperandTypes(func, checkMode);
      yieldType = some(yieldTypes) ? getUnionType(yieldTypes, UnionReduction.Subtype) : undefined;
      nextType = some(nextTypes) ? getIntersectionType(nextTypes) : undefined;
    } else {
      const types = checkAndAggregateReturnExpressionTypes(func, checkMode);
      if (!types) return functionFlags & FunctionFlags.Async ? createPromiseReturnType(func, neverType) : neverType;
      if (types.length === 0) return functionFlags & FunctionFlags.Async ? createPromiseReturnType(func, voidType) : voidType;
      returnType = getUnionType(types, UnionReduction.Subtype);
    }
    if (returnType || yieldType || nextType) {
      if (yieldType) reportErrorsFromWidening(func, yieldType, WideningKind.GeneratorYield);
      if (returnType) reportErrorsFromWidening(func, returnType, WideningKind.FunctionReturn);
      if (nextType) reportErrorsFromWidening(func, nextType, WideningKind.GeneratorNext);
      if ((returnType && isUnitType(returnType)) || (yieldType && isUnitType(yieldType)) || (nextType && isUnitType(nextType))) {
        const contextualSignature = getContextualSignatureForFunctionLikeDeclaration(func);
        const contextualType = !contextualSignature
          ? undefined
          : contextualSignature === getSignatureFromDeclaration(func)
          ? isGenerator
            ? undefined
            : returnType
          : instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func);
        if (isGenerator) {
          yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, IterationTypeKind.Yield, isAsync);
          returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, IterationTypeKind.Return, isAsync);
          nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, IterationTypeKind.Next, isAsync);
        } else returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync);
      }
      if (yieldType) yieldType = getWidenedType(yieldType);
      if (returnType) returnType = getWidenedType(returnType);
      if (nextType) nextType = getWidenedType(nextType);
    }
    if (isGenerator)
      return createGeneratorReturnType(yieldType || neverType, returnType || fallbackReturnType, nextType || getContextualIterationType(IterationTypeKind.Next, func) || unknownType, isAsync);
    return isAsync ? createPromiseType(returnType || fallbackReturnType) : returnType || fallbackReturnType;
  }
  function createGeneratorReturnType(yieldType: Type, returnType: Type, nextType: Type, isAsyncGenerator: boolean) {
    const resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
    const globalGeneratorType = resolver.getGlobalGeneratorType(false);
    yieldType = resolver.resolveIterationType(yieldType, undefined) || unknownType;
    returnType = resolver.resolveIterationType(returnType, undefined) || unknownType;
    nextType = resolver.resolveIterationType(nextType, undefined) || unknownType;
    if (globalGeneratorType === emptyGenericType) {
      const globalType = resolver.getGlobalIterableIteratorType(false);
      const iterationTypes = globalType !== emptyGenericType ? getIterationTypesOfGlobalIterableType(globalType, resolver) : undefined;
      const iterableIteratorReturnType = iterationTypes ? iterationTypes.returnType : anyType;
      const iterableIteratorNextType = iterationTypes ? iterationTypes.nextType : undefinedType;
      if (isTypeAssignableTo(returnType, iterableIteratorReturnType) && isTypeAssignableTo(iterableIteratorNextType, nextType)) {
        if (globalType !== emptyGenericType) return createTypeFromGenericGlobalType(globalType, [yieldType]);
        resolver.getGlobalIterableIteratorType(true);
        return emptyObjectType;
      }
      resolver.getGlobalGeneratorType(true);
      return emptyObjectType;
    }
    return createTypeFromGenericGlobalType(globalGeneratorType, [yieldType, returnType, nextType]);
  }
  function checkAndAggregateYieldOperandTypes(func: FunctionLikeDeclaration, checkMode: CheckMode | undefined) {
    const yieldTypes: Type[] = [];
    const nextTypes: Type[] = [];
    const isAsync = (getFunctionFlags(func) & FunctionFlags.Async) !== 0;
    forEachYieldExpression(<Block>func.body, (yieldExpression) => {
      const yieldExpressionType = yieldExpression.expression ? checkExpression(yieldExpression.expression, checkMode) : undefinedWideningType;
      pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync));
      let nextType: Type | undefined;
      if (yieldExpression.asteriskToken) {
        const iterationTypes = getIterationTypesOfIterable(yieldExpressionType, isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar, yieldExpression.expression);
        nextType = iterationTypes && iterationTypes.nextType;
      } else nextType = getContextualType(yieldExpression);
      if (nextType) pushIfUnique(nextTypes, nextType);
    });
    return { yieldTypes, nextTypes };
  }
  function getYieldedTypeOfYieldExpression(node: YieldExpression, expressionType: Type, sentType: Type, isAsync: boolean): Type | undefined {
    const errorNode = node.expression || node;
    const yieldedType = node.asteriskToken ? checkIteratedTypeOrElementType(isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar, expressionType, sentType, errorNode) : expressionType;
    return !isAsync
      ? yieldedType
      : getAwaitedType(
          yieldedType,
          errorNode,
          node.asteriskToken
            ? qd.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member
            : qd.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member
        );
  }
  function getFactsFromTypeofSwitch(start: number, end: number, witnesses: string[], hasDefault: boolean): TypeFacts {
    let facts: TypeFacts = TypeFacts.None;
    if (hasDefault) {
      for (let i = end; i < witnesses.length; i++) {
        facts |= typeofNEFacts.get(witnesses[i]) || TypeFacts.TypeofNEHostObject;
      }
      for (let i = start; i < end; i++) {
        facts &= ~(typeofNEFacts.get(witnesses[i]) || 0);
      }
      for (let i = 0; i < start; i++) {
        facts |= typeofNEFacts.get(witnesses[i]) || TypeFacts.TypeofNEHostObject;
      }
    } else {
      for (let i = start; i < end; i++) {
        facts |= typeofEQFacts.get(witnesses[i]) || TypeFacts.TypeofEQHostObject;
      }
      for (let i = 0; i < start; i++) {
        facts &= ~(typeofEQFacts.get(witnesses[i]) || 0);
      }
    }
    return facts;
  }
  function isExhaustiveSwitchStatement(node: SwitchStatement): boolean {
    const links = getNodeLinks(node);
    return links.isExhaustive !== undefined ? links.isExhaustive : (links.isExhaustive = computeExhaustiveSwitchStatement(node));
  }
  function computeExhaustiveSwitchStatement(node: SwitchStatement): boolean {
    if (node.expression.kind === Syntax.TypeOfExpression) {
      const operandType = getTypeOfExpression((node.expression as TypeOfExpression).expression);
      const witnesses = getSwitchClauseTypeOfWitnesses(node, false);
      const notEqualFacts = getFactsFromTypeofSwitch(0, 0, witnesses, true);
      const type = getBaseConstraintOfType(operandType) || operandType;
      return !!(filterType(type, (t) => (getTypeFacts(t) & notEqualFacts) === notEqualFacts).flags & TypeFlags.Never);
    }
    const type = getTypeOfExpression(node.expression);
    if (!isLiteralType(type)) return false;
    const switchTypes = getSwitchClauseTypes(node);
    if (!switchTypes.length || some(switchTypes, isNeitherUnitTypeNorNever)) return false;
    return eachTypeContainedIn(mapType(type, getRegularTypeOfLiteralType), switchTypes);
  }
  function functionHasImplicitReturn(func: FunctionLikeDeclaration) {
    return func.endFlowNode && isReachableFlowNode(func.endFlowNode);
  }
  function checkAndAggregateReturnExpressionTypes(func: FunctionLikeDeclaration, checkMode: CheckMode | undefined): Type[] | undefined {
    const functionFlags = getFunctionFlags(func);
    const aggregatedTypes: Type[] = [];
    let hasReturnWithNoExpression = functionHasImplicitReturn(func);
    let hasReturnOfTypeNever = false;
    forEachReturnStatement(<Block>func.body, (returnStatement) => {
      const expr = returnStatement.expression;
      if (expr) {
        let type = checkExpressionCached(expr, checkMode && checkMode & ~CheckMode.SkipGenericFunctions);
        if (functionFlags & FunctionFlags.Async) type = checkAwaitedType(type, func, qd.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
        if (type.flags & TypeFlags.Never) hasReturnOfTypeNever = true;
        pushIfUnique(aggregatedTypes, type);
      } else {
        hasReturnWithNoExpression = true;
      }
    });
    if (aggregatedTypes.length === 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func))) return;
    if (strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression && !(isJSConstructor(func) && aggregatedTypes.some((t) => t.symbol === func.symbol)))
      pushIfUnique(aggregatedTypes, undefinedType);
    return aggregatedTypes;
  }
  function mayReturnNever(func: FunctionLikeDeclaration): boolean {
    switch (func.kind) {
      case Syntax.FunctionExpression:
      case Syntax.ArrowFunction:
        return true;
      case Syntax.MethodDeclaration:
        return func.parent.kind === Syntax.ObjectLiteralExpression;
      default:
        return false;
    }
  }
  function checkAllCodePathsInNonVoidFunctionReturnOrThrow(func: FunctionLikeDeclaration | MethodSignature, returnType: Type | undefined): void {
    if (!produceDiagnostics) return;
    const functionFlags = getFunctionFlags(func);
    const type = returnType && unwrapReturnType(returnType, functionFlags);
    if (type && maybeTypeOfKind(type, TypeFlags.Any | TypeFlags.Void)) return;
    if (func.kind === Syntax.MethodSignature || qc.is.missing(func.body) || func.body!.kind !== Syntax.Block || !functionHasImplicitReturn(func)) return;
    const hasExplicitReturn = func.flags & NodeFlags.HasExplicitReturn;
    if (type && type.flags & TypeFlags.Never) error(getEffectiveReturnTypeNode(func), qd.A_function_returning_never_cannot_have_a_reachable_end_point);
    else if (type && !hasExplicitReturn) {
      error(getEffectiveReturnTypeNode(func), qd.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value);
    } else if (type && strictNullChecks && !isTypeAssignableTo(undefinedType, type)) {
      error(getEffectiveReturnTypeNode(func) || func, qd.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined);
    } else if (compilerOptions.noImplicitReturns) {
      if (!type) {
        if (!hasExplicitReturn) return;
        const inferredReturnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
        if (isUnwrappedReturnTypeVoidOrAny(func, inferredReturnType)) return;
      }
      error(getEffectiveReturnTypeNode(func) || func, qd.Not_all_code_paths_return_a_value);
    }
  }
  function checkFunctionExpressionOrObjectLiteralMethod(node: FunctionExpression | ArrowFunction | MethodDeclaration, checkMode?: CheckMode): Type {
    assert(node.kind !== Syntax.MethodDeclaration || qc.is.objectLiteralMethod(node));
    checkNodeDeferred(node);
    if (checkMode && checkMode & CheckMode.SkipContextSensitive && isContextSensitive(node)) {
      if (!getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node)) {
        const contextualSignature = getContextualSignature(node);
        if (contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature))) {
          const links = getNodeLinks(node);
          if (links.contextFreeType) return links.contextFreeType;
          const returnType = getReturnTypeFromBody(node, checkMode);
          const returnOnlySignature = createSignature(undefined, undefined, undefined, empty, returnType, undefined, 0, SignatureFlags.None);
          const returnOnlyType = createAnonymousType(node.symbol, emptySymbols, [returnOnlySignature], empty, undefined, undefined);
          returnOnlyType.objectFlags |= ObjectFlags.NonInferrableType;
          return (links.contextFreeType = returnOnlyType);
        }
      }
      return anyFunctionType;
    }
    const hasGrammarError = checkGrammarFunctionLikeDeclaration(node);
    if (!hasGrammarError && node.kind === Syntax.FunctionExpression) checkGrammarForGenerator(node);
    contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode);
    return getTypeOfSymbol(getSymbolOfNode(node));
  }
  function contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node: FunctionExpression | ArrowFunction | MethodDeclaration, checkMode?: CheckMode) {
    const links = getNodeLinks(node);
    if (!(links.flags & NodeCheckFlags.ContextChecked)) {
      const contextualSignature = getContextualSignature(node);
      if (!(links.flags & NodeCheckFlags.ContextChecked)) {
        links.flags |= NodeCheckFlags.ContextChecked;
        const signature = firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfNode(node)), SignatureKind.Call));
        if (!signature) return;
        if (isContextSensitive(node)) {
          if (contextualSignature) {
            const inferenceContext = getInferenceContext(node);
            if (checkMode && checkMode & CheckMode.Inferential) inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext!);
            const instantiatedContextualSignature = inferenceContext ? instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature;
            assignContextualParameterTypes(signature, instantiatedContextualSignature);
          } else {
            assignNonContextualParameterTypes(signature);
          }
        }
        if (contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType) {
          const returnType = getReturnTypeFromBody(node, checkMode);
          if (!signature.resolvedReturnType) signature.resolvedReturnType = returnType;
        }
        checkSignatureDeclaration(node);
      }
    }
  }
  function checkFunctionExpressionOrObjectLiteralMethodDeferred(node: ArrowFunction | FunctionExpression | MethodDeclaration) {
    assert(node.kind !== Syntax.MethodDeclaration || qc.is.objectLiteralMethod(node));
    const functionFlags = getFunctionFlags(node);
    const returnType = getReturnTypeFromAnnotation(node);
    checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
    if (node.body) {
      if (!getEffectiveReturnTypeNode(node)) getReturnTypeOfSignature(getSignatureFromDeclaration(node));
      if (node.body.kind === Syntax.Block) checkSourceElement(node.body);
      else {
        const exprType = checkExpression(node.body);
        const returnOrPromisedType = returnType && unwrapReturnType(returnType, functionFlags);
        if (returnOrPromisedType) {
          if ((functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async) {
            const awaitedType = checkAwaitedType(exprType, node.body, qd.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
            checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, node.body, node.body);
          } else {
            checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, node.body, node.body);
          }
        }
      }
    }
  }
  function checkArithmeticOperandType(operand: Node, type: Type, diagnostic: DiagnosticMessage, isAwaitValid = false): boolean {
    if (!isTypeAssignableTo(type, numberOrBigIntType)) {
      const awaitedType = isAwaitValid && getAwaitedTypeOfPromise(type);
      errorAndMaybeSuggestAwait(operand, !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType), diagnostic);
      return false;
    }
    return true;
  }
  function isReadonlyAssignmentDeclaration(d: Declaration) {
    if (!qc.is.kind(CallExpression, d)) return false;
    if (!isBindableObjectDefinePropertyCall(d)) return false;
    const objectLitType = checkExpressionCached(d.arguments[2]);
    const valueType = getTypeOfPropertyOfType(objectLitType, 'value' as __String);
    if (valueType) {
      const writableProp = getPropertyOfType(objectLitType, 'writable' as __String);
      const writableType = writableProp && getTypeOfSymbol(writableProp);
      if (!writableType || writableType === falseType || writableType === regularFalseType) return true;
      if (writableProp && writableProp.valueDeclaration && qc.is.kind(PropertyAssignment, writableProp.valueDeclaration)) {
        const initializer = writableProp.valueDeclaration.initializer;
        const rawOriginalType = checkExpression(initializer);
        if (rawOriginalType === falseType || rawOriginalType === regularFalseType) return true;
      }
      return false;
    }
    const setProp = getPropertyOfType(objectLitType, 'set' as __String);
    return !setProp;
  }
  function isAssignmentToReadonlyEntity(expr: Expression, symbol: Symbol, assignmentKind: AssignmentKind) {
    if (assignmentKind === AssignmentKind.None) return false;
    if (isReadonlySymbol(symbol)) {
      if (symbol.flags & SymbolFlags.Property && isAccessExpression(expr) && expr.expression.kind === Syntax.ThisKeyword) {
        const ctor = qc.get.containingFunction(expr);
        if (!(ctor && ctor.kind === Syntax.Constructor)) return true;
        if (symbol.valueDeclaration) {
          const isAssignmentDeclaration = qc.is.kind(BinaryExpression, symbol.valueDeclaration);
          const isLocalPropertyDeclaration = ctor.parent === symbol.valueDeclaration.parent;
          const isLocalParameterProperty = ctor === symbol.valueDeclaration.parent;
          const isLocalThisPropertyAssignment = isAssignmentDeclaration && symbol.parent?.valueDeclaration === ctor.parent;
          const isLocalThisPropertyAssignmentConstructorFunction = isAssignmentDeclaration && symbol.parent?.valueDeclaration === ctor;
          const isWriteableSymbol = isLocalPropertyDeclaration || isLocalParameterProperty || isLocalThisPropertyAssignment || isLocalThisPropertyAssignmentConstructorFunction;
          return !isWriteableSymbol;
        }
      }
      return true;
    }
    if (isAccessExpression(expr)) {
      const node = skipParentheses(expr.expression);
      if (node.kind === Syntax.Identifier) {
        const symbol = getNodeLinks(node).resolvedSymbol!;
        if (symbol.flags & SymbolFlags.Alias) {
          const declaration = symbol.getDeclarationOfAliasSymbol();
          return !!declaration && declaration.kind === Syntax.NamespaceImport;
        }
      }
    }
    return false;
  }
  function checkReferenceExpression(expr: Expression, invalidReferenceMessage: DiagnosticMessage, invalidOptionalChainMessage: DiagnosticMessage): boolean {
    const node = skipOuterExpressions(expr, OuterExpressionKinds.Assertions | OuterExpressionKinds.Parentheses);
    if (node.kind !== Syntax.Identifier && !isAccessExpression(node)) {
      error(expr, invalidReferenceMessage);
      return false;
    }
    if (node.flags & NodeFlags.OptionalChain) {
      error(expr, invalidOptionalChainMessage);
      return false;
    }
    return true;
  }
  function checkDeleteExpression(node: DeleteExpression): Type {
    checkExpression(node.expression);
    const expr = skipParentheses(node.expression);
    if (!isAccessExpression(expr)) {
      error(expr, qd.The_operand_of_a_delete_operator_must_be_a_property_reference);
      return booleanType;
    }
    if (expr.kind === Syntax.PropertyAccessExpression && qc.is.kind(PrivateIdentifier, expr.name)) error(expr, qd.The_operand_of_a_delete_operator_cannot_be_a_private_identifier);
    const links = getNodeLinks(expr);
    const symbol = getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol);
    if (symbol) {
      if (isReadonlySymbol(symbol)) error(expr, qd.The_operand_of_a_delete_operator_cannot_be_a_read_only_property);
      checkDeleteExpressionMustBeOptional(expr, this.getTypeOfSymbol());
    }
    return booleanType;
  }
  function checkDeleteExpressionMustBeOptional(expr: AccessExpression, type: Type) {
    const AnyOrUnknownOrNeverFlags = TypeFlags.AnyOrUnknown | TypeFlags.Never;
    if (strictNullChecks && !(type.flags & AnyOrUnknownOrNeverFlags) && !(getFalsyFlags(type) & TypeFlags.Undefined)) error(expr, qd.The_operand_of_a_delete_operator_must_be_optional);
  }
  function checkTypeOfExpression(node: TypeOfExpression): Type {
    checkExpression(node.expression);
    return typeofType;
  }
  function checkVoidExpression(node: VoidExpression): Type {
    checkExpression(node.expression);
    return undefinedWideningType;
  }
  function isTopLevelAwait(node: AwaitExpression) {
    const container = qc.get.thisContainer(node, true);
    return qc.is.kind(SourceFile, container);
  }
  function checkAwaitExpression(node: AwaitExpression): Type {
    if (produceDiagnostics) {
      if (!(node.flags & NodeFlags.AwaitContext)) {
        if (isTopLevelAwait(node)) {
          const sourceFile = qc.get.sourceFileOf(node);
          if (!hasParseDiagnostics(sourceFile)) {
            let span: TextSpan | undefined;
            if (!isEffectiveExternalModule(sourceFile, compilerOptions)) {
              if (!span) span = getSpanOfTokenAtPosition(sourceFile, node.pos);
              const diagnostic = createFileDiagnostic(
                sourceFile,
                span.start,
                span.length,
                qd.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module
              );
              diagnostics.add(diagnostic);
            }
            if (moduleKind !== ModuleKind.ESNext && moduleKind !== ModuleKind.System) {
              span = getSpanOfTokenAtPosition(sourceFile, node.pos);
              const diagnostic = createFileDiagnostic(
                sourceFile,
                span.start,
                span.length,
                qd.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_esnext_or_system_and_the_target_option_is_set_to_es2017_or_higher
              );
              diagnostics.add(diagnostic);
            }
          }
        } else {
          const sourceFile = qc.get.sourceFileOf(node);
          if (!hasParseDiagnostics(sourceFile)) {
            const span = getSpanOfTokenAtPosition(sourceFile, node.pos);
            const diagnostic = createFileDiagnostic(sourceFile, span.start, span.length, qd.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules);
            const func = qc.get.containingFunction(node);
            if (func && func.kind !== Syntax.Constructor && (getFunctionFlags(func) & FunctionFlags.Async) === 0) {
              const relatedInfo = createDiagnosticForNode(func, qd.Did_you_mean_to_mark_this_function_as_async);
              addRelatedInfo(diagnostic, relatedInfo);
            }
            diagnostics.add(diagnostic);
          }
        }
      }
      if (isInParameterInitializerBeforeContainingFunction(node)) error(node, qd.await_expressions_cannot_be_used_in_a_parameter_initializer);
    }
    const operandType = checkExpression(node.expression);
    const awaitedType = checkAwaitedType(operandType, node, qd.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
    if (awaitedType === operandType && awaitedType !== errorType && !(operandType.flags & TypeFlags.AnyOrUnknown))
      addErrorOrSuggestion(false, createDiagnosticForNode(node, qd.await_has_no_effect_on_the_type_of_this_expression));
    return awaitedType;
  }
  function checkPrefixUnaryExpression(node: PrefixUnaryExpression): Type {
    const operandType = checkExpression(node.operand);
    if (operandType === silentNeverType) return silentNeverType;
    switch (node.operand.kind) {
      case Syntax.NumericLiteral:
        switch (node.operator) {
          case Syntax.MinusToken:
            return getFreshTypeOfLiteralType(getLiteralType(-(node.operand as NumericLiteral).text));
          case Syntax.PlusToken:
            return getFreshTypeOfLiteralType(getLiteralType(+(node.operand as NumericLiteral).text));
        }
        break;
      case Syntax.BigIntLiteral:
        if (node.operator === Syntax.MinusToken) {
          return getFreshTypeOfLiteralType(
            getLiteralType({
              negative: true,
              base10Value: parsePseudoBigInt((node.operand as BigIntLiteral).text),
            })
          );
        }
    }
    switch (node.operator) {
      case Syntax.PlusToken:
      case Syntax.MinusToken:
      case Syntax.TildeToken:
        checkNonNullType(operandType, node.operand);
        if (maybeTypeOfKind(operandType, TypeFlags.ESSymbolLike)) error(node.operand, qd.The_0_operator_cannot_be_applied_to_type_symbol, Token.toString(node.operator));
        if (node.operator === Syntax.PlusToken) {
          if (maybeTypeOfKind(operandType, TypeFlags.BigIntLike))
            error(node.operand, qd.Operator_0_cannot_be_applied_to_type_1, Token.toString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)));
          return numberType;
        }
        return getUnaryResultType(operandType);
      case Syntax.ExclamationToken:
        checkTruthinessExpression(node.operand);
        const facts = getTypeFacts(operandType) & (TypeFacts.Truthy | TypeFacts.Falsy);
        return facts === TypeFacts.Truthy ? falseType : facts === TypeFacts.Falsy ? trueType : booleanType;
      case Syntax.Plus2Token:
      case Syntax.Minus2Token:
        const ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), qd.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);
        if (ok) {
          checkReferenceExpression(
            node.operand,
            qd.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,
            qd.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access
          );
        }
        return getUnaryResultType(operandType);
    }
    return errorType;
  }
  function checkPostfixUnaryExpression(node: PostfixUnaryExpression): Type {
    const operandType = checkExpression(node.operand);
    if (operandType === silentNeverType) return silentNeverType;
    const ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), qd.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);
    if (ok) {
      checkReferenceExpression(
        node.operand,
        qd.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,
        qd.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access
      );
    }
    return getUnaryResultType(operandType);
  }
  function getUnaryResultType(operandType: Type): Type {
    if (maybeTypeOfKind(operandType, TypeFlags.BigIntLike))
      return isTypeAssignableToKind(operandType, TypeFlags.AnyOrUnknown) || maybeTypeOfKind(operandType, TypeFlags.NumberLike) ? numberOrBigIntType : bigintType;
    return numberType;
  }
  function maybeTypeOfKind(type: Type, kind: TypeFlags): boolean {
    if (type.flags & kind) return true;
    if (type.flags & TypeFlags.UnionOrIntersection) {
      const types = (<UnionOrIntersectionType>type).types;
      for (const t of types) {
        if (maybeTypeOfKind(t, kind)) return true;
      }
    }
    return false;
  }
  function isTypeAssignableToKind(source: Type, kind: TypeFlags, strict?: boolean): boolean {
    if (source.flags & kind) return true;
    if (strict && source.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null)) return false;
    return (
      (!!(kind & TypeFlags.NumberLike) && isTypeAssignableTo(source, numberType)) ||
      (!!(kind & TypeFlags.BigIntLike) && isTypeAssignableTo(source, bigintType)) ||
      (!!(kind & TypeFlags.StringLike) && isTypeAssignableTo(source, stringType)) ||
      (!!(kind & TypeFlags.BooleanLike) && isTypeAssignableTo(source, booleanType)) ||
      (!!(kind & TypeFlags.Void) && isTypeAssignableTo(source, voidType)) ||
      (!!(kind & TypeFlags.Never) && isTypeAssignableTo(source, neverType)) ||
      (!!(kind & TypeFlags.Null) && isTypeAssignableTo(source, nullType)) ||
      (!!(kind & TypeFlags.Undefined) && isTypeAssignableTo(source, undefinedType)) ||
      (!!(kind & TypeFlags.ESSymbol) && isTypeAssignableTo(source, esSymbolType)) ||
      (!!(kind & TypeFlags.NonPrimitive) && isTypeAssignableTo(source, nonPrimitiveType))
    );
  }
  function allTypesAssignableToKind(source: Type, kind: TypeFlags, strict?: boolean): boolean {
    return source.flags & TypeFlags.Union ? every((source as UnionType).types, (subType) => allTypesAssignableToKind(subType, kind, strict)) : isTypeAssignableToKind(source, kind, strict);
  }
  function isConstEnumObjectType(type: Type): boolean {
    return !!(getObjectFlags(type) & ObjectFlags.Anonymous) && !!type.symbol && isConstEnumSymbol(type.symbol);
  }
  function checkInstanceOfExpression(left: Expression, right: Expression, leftType: Type, rightType: Type): Type {
    if (leftType === silentNeverType || rightType === silentNeverType) return silentNeverType;
    if (!isTypeAny(leftType) && allTypesAssignableToKind(leftType, TypeFlags.Primitive))
      error(left, qd.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
    if (!(isTypeAny(rightType) || typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType)))
      error(right, qd.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);
    return booleanType;
  }
  function checkInExpression(left: Expression, right: Expression, leftType: Type, rightType: Type): Type {
    if (leftType === silentNeverType || rightType === silentNeverType) return silentNeverType;
    leftType = checkNonNullType(leftType, left);
    rightType = checkNonNullType(rightType, right);
    if (!(allTypesAssignableToKind(leftType, TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike) || isTypeAssignableToKind(leftType, TypeFlags.Index | TypeFlags.TypeParameter)))
      error(left, qd.The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol);
    if (!allTypesAssignableToKind(rightType, TypeFlags.NonPrimitive | TypeFlags.InstantiableNonPrimitive))
      error(right, qd.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
    return booleanType;
  }
  function checkObjectLiteralAssignment(node: ObjectLiteralExpression, sourceType: Type, rightIsThis?: boolean): Type {
    const properties = node.properties;
    if (strictNullChecks && properties.length === 0) return checkNonNullType(sourceType, node);
    for (let i = 0; i < properties.length; i++) {
      checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis);
    }
    return sourceType;
  }
  function checkObjectLiteralDestructuringPropertyAssignment(
    node: ObjectLiteralExpression,
    objectLiteralType: Type,
    propertyIndex: number,
    allProperties?: Nodes<ObjectLiteralElementLike>,
    rightIsThis = false
  ) {
    const properties = node.properties;
    const property = properties[propertyIndex];
    if (property.kind === Syntax.PropertyAssignment || property.kind === Syntax.ShorthandPropertyAssignment) {
      const name = property.name;
      const exprType = getLiteralTypeFromPropertyName(name);
      if (isTypeUsableAsPropertyName(exprType)) {
        const text = getPropertyNameFromType(exprType);
        const prop = getPropertyOfType(objectLiteralType, text);
        if (prop) {
          markPropertyAsReferenced(prop, property, rightIsThis);
          checkPropertyAccessibility(property, false, objectLiteralType, prop);
        }
      }
      const elementType = getIndexedAccessType(objectLiteralType, exprType, name);
      const type = getFlowTypeOfDestructuring(property, elementType);
      return checkDestructuringAssignment(property.kind === Syntax.ShorthandPropertyAssignment ? property : property.initializer, type);
    } else if (property.kind === Syntax.SpreadAssignment) {
      if (propertyIndex < properties.length - 1) error(property, qd.A_rest_element_must_be_last_in_a_destructuring_pattern);
      else {
        if (languageVersion < ScriptTarget.ESNext) checkExternalEmitHelpers(property, ExternalEmitHelpers.Rest);
        const nonRestNames: PropertyName[] = [];
        if (allProperties) {
          for (const otherProperty of allProperties) {
            if (!qc.is.kind(SpreadAssignment, otherProperty)) nonRestNames.push(otherProperty.name);
          }
        }
        const type = getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol);
        checkGrammarForDisallowedTrailingComma(allProperties, qd.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
        return checkDestructuringAssignment(property.expression, type);
      }
    } else {
      error(property, qd.Property_assignment_expected);
    }
  }
  function checkArrayLiteralAssignment(node: ArrayLiteralExpression, sourceType: Type, checkMode?: CheckMode): Type {
    const elements = node.elements;
    const elementType = checkIteratedTypeOrElementType(IterationUse.Destructuring, sourceType, undefinedType, node) || errorType;
    for (let i = 0; i < elements.length; i++) {
      checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, elementType, checkMode);
    }
    return sourceType;
  }
  function checkArrayLiteralDestructuringElementAssignment(node: ArrayLiteralExpression, sourceType: Type, elementIndex: number, elementType: Type, checkMode?: CheckMode) {
    const elements = node.elements;
    const element = elements[elementIndex];
    if (element.kind !== Syntax.OmittedExpression) {
      if (element.kind !== Syntax.SpreadElement) {
        const indexType = getLiteralType(elementIndex);
        if (isArrayLikeType(sourceType)) {
          const accessFlags = hasDefaultValue(element) ? AccessFlags.NoTupleBoundsCheck : 0;
          const elementType = getIndexedAccessTypeOrUndefined(sourceType, indexType, createSyntheticExpression(element, indexType), accessFlags) || errorType;
          const assignedType = hasDefaultValue(element) ? getTypeWithFacts(elementType, TypeFacts.NEUndefined) : elementType;
          const type = getFlowTypeOfDestructuring(element, assignedType);
          return checkDestructuringAssignment(element, type, checkMode);
        }
        return checkDestructuringAssignment(element, elementType, checkMode);
      }
      if (elementIndex < elements.length - 1) error(element, qd.A_rest_element_must_be_last_in_a_destructuring_pattern);
      else {
        const restExpression = (<SpreadElement>element).expression;
        if (restExpression.kind === Syntax.BinaryExpression && (<BinaryExpression>restExpression).operatorToken.kind === Syntax.EqualsToken)
          error((<BinaryExpression>restExpression).operatorToken, qd.A_rest_element_cannot_have_an_initializer);
        else {
          checkGrammarForDisallowedTrailingComma(node.elements, qd.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
          const type = everyType(sourceType, isTupleType) ? mapType(sourceType, (t) => sliceTupleType(<TupleTypeReference>t, elementIndex)) : createArrayType(elementType);
          return checkDestructuringAssignment(restExpression, type, checkMode);
        }
      }
    }
    return;
  }
  function checkDestructuringAssignment(exprOrAssignment: Expression | ShorthandPropertyAssignment, sourceType: Type, checkMode?: CheckMode, rightIsThis?: boolean): Type {
    let target: Expression;
    if (exprOrAssignment.kind === Syntax.ShorthandPropertyAssignment) {
      const prop = <ShorthandPropertyAssignment>exprOrAssignment;
      if (prop.objectAssignmentInitializer) {
        if (strictNullChecks && !(getFalsyFlags(checkExpression(prop.objectAssignmentInitializer)) & TypeFlags.Undefined)) sourceType = getTypeWithFacts(sourceType, TypeFacts.NEUndefined);
        checkBinaryLikeExpression(prop.name, prop.equalsToken!, prop.objectAssignmentInitializer, checkMode);
      }
      target = (<ShorthandPropertyAssignment>exprOrAssignment).name;
    } else {
      target = exprOrAssignment;
    }
    if (target.kind === Syntax.BinaryExpression && (<BinaryExpression>target).operatorToken.kind === Syntax.EqualsToken) {
      checkBinaryExpression(<BinaryExpression>target, checkMode);
      target = (<BinaryExpression>target).left;
    }
    if (target.kind === Syntax.ObjectLiteralExpression) return checkObjectLiteralAssignment(<ObjectLiteralExpression>target, sourceType, rightIsThis);
    if (target.kind === Syntax.ArrayLiteralExpression) return checkArrayLiteralAssignment(<ArrayLiteralExpression>target, sourceType, checkMode);
    return checkReferenceAssignment(target, sourceType, checkMode);
  }
  function checkReferenceAssignment(target: Expression, sourceType: Type, checkMode?: CheckMode): Type {
    const targetType = checkExpression(target, checkMode);
    const error =
      target.parent.kind === Syntax.SpreadAssignment
        ? qd.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access
        : qd.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access;
    const optionalError =
      target.parent.kind === Syntax.SpreadAssignment
        ? qd.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access
        : qd.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access;
    if (checkReferenceExpression(target, error, optionalError)) checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target);
    if (qc.is.privateIdentifierPropertyAccessExpression(target)) checkExternalEmitHelpers(target.parent, ExternalEmitHelpers.ClassPrivateFieldSet);
    return sourceType;
  }
  function isSideEffectFree(node: Node): boolean {
    node = skipParentheses(node);
    switch (node.kind) {
      case Syntax.Identifier:
      case Syntax.StringLiteral:
      case Syntax.RegexLiteral:
      case Syntax.TaggedTemplateExpression:
      case Syntax.TemplateExpression:
      case Syntax.NoSubstitutionLiteral:
      case Syntax.NumericLiteral:
      case Syntax.BigIntLiteral:
      case Syntax.TrueKeyword:
      case Syntax.FalseKeyword:
      case Syntax.NullKeyword:
      case Syntax.UndefinedKeyword:
      case Syntax.FunctionExpression:
      case Syntax.ClassExpression:
      case Syntax.ArrowFunction:
      case Syntax.ArrayLiteralExpression:
      case Syntax.ObjectLiteralExpression:
      case Syntax.TypeOfExpression:
      case Syntax.NonNullExpression:
      case Syntax.JsxSelfClosingElement:
      case Syntax.JsxElement:
        return true;
      case Syntax.ConditionalExpression:
        return isSideEffectFree((node as ConditionalExpression).whenTrue) && isSideEffectFree((node as ConditionalExpression).whenFalse);
      case Syntax.BinaryExpression:
        if (syntax.is.assignmentOperator((node as BinaryExpression).operatorToken.kind)) return false;
        return isSideEffectFree((node as BinaryExpression).left) && isSideEffectFree((node as BinaryExpression).right);
      case Syntax.PrefixUnaryExpression:
      case Syntax.PostfixUnaryExpression:
        switch ((node as PrefixUnaryExpression).operator) {
          case Syntax.ExclamationToken:
          case Syntax.PlusToken:
          case Syntax.MinusToken:
          case Syntax.TildeToken:
            return true;
        }
        return false;
      case Syntax.VoidExpression:
      case Syntax.TypeAssertionExpression:
      case Syntax.AsExpression:
      default:
        return false;
    }
  }
  function isTypeEqualityComparableTo(source: Type, target: Type) {
    return (target.flags & TypeFlags.Nullable) !== 0 || isTypeComparableTo(source, target);
  }
  const enum CheckBinaryExpressionState {
    MaybeCheckLeft,
    CheckRight,
    FinishCheck,
  }
  function checkBinaryExpression(node: BinaryExpression, checkMode?: CheckMode) {
    const workStacks: {
      expr: BinaryExpression[];
      state: CheckBinaryExpressionState[];
      leftType: (Type | undefined)[];
    } = {
      expr: [node],
      state: [CheckBinaryExpressionState.MaybeCheckLeft],
      leftType: [undefined],
    };
    let stackIndex = 0;
    let lastResult: Type | undefined;
    while (stackIndex >= 0) {
      node = workStacks.expr[stackIndex];
      switch (workStacks.state[stackIndex]) {
        case CheckBinaryExpressionState.MaybeCheckLeft: {
          if (isInJSFile(node) && getAssignedExpandoInitializer(node)) {
            finishInvocation(checkExpression(node.right, checkMode));
            break;
          }
          checkGrammarNullishCoalesceWithLogicalExpression(node);
          const operator = node.operatorToken.kind;
          if (operator === Syntax.EqualsToken && (node.left.kind === Syntax.ObjectLiteralExpression || node.left.kind === Syntax.ArrayLiteralExpression)) {
            finishInvocation(checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, node.right.kind === Syntax.ThisKeyword));
            break;
          }
          advanceState(CheckBinaryExpressionState.CheckRight);
          maybeCheckExpression(node.left);
          break;
        }
        case CheckBinaryExpressionState.CheckRight: {
          const leftType = lastResult!;
          workStacks.leftType[stackIndex] = leftType;
          const operator = node.operatorToken.kind;
          if (operator === Syntax.Ampersand2Token || operator === Syntax.Bar2Token || operator === Syntax.Question2Token) checkTruthinessOfType(leftType, node.left);
          advanceState(CheckBinaryExpressionState.FinishCheck);
          maybeCheckExpression(node.right);
          break;
        }
        case CheckBinaryExpressionState.FinishCheck: {
          const leftType = workStacks.leftType[stackIndex]!;
          const rightType = lastResult!;
          finishInvocation(checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, node));
          break;
        }
        default:
          return fail(`Invalid state ${workStacks.state[stackIndex]} for checkBinaryExpression`);
      }
    }
    return lastResult!;
    function finishInvocation(result: Type) {
      lastResult = result;
      stackIndex--;
    }
    function advanceState(nextState: CheckBinaryExpressionState) {
      workStacks.state[stackIndex] = nextState;
    }
    function maybeCheckExpression(node: Expression) {
      if (qc.is.kind(node, BinaryExpression)) {
        stackIndex++;
        workStacks.expr[stackIndex] = node;
        workStacks.state[stackIndex] = CheckBinaryExpressionState.MaybeCheckLeft;
        workStacks.leftType[stackIndex] = undefined;
      } else {
        lastResult = checkExpression(node, checkMode);
      }
    }
  }
  function checkGrammarNullishCoalesceWithLogicalExpression(node: BinaryExpression) {
    const { left, operatorToken, right } = node;
    if (operatorToken.kind === Syntax.Question2Token) {
      if (qc.is.kind(BinaryExpression, left) && (left.operatorToken.kind === Syntax.Bar2Token || left.operatorToken.kind === Syntax.Ampersand2Token))
        grammarErrorOnNode(left, qd._0_and_1_operations_cannot_be_mixed_without_parentheses, Token.toString(left.operatorToken.kind), Token.toString(operatorToken.kind));
      if (qc.is.kind(BinaryExpression, right) && (right.operatorToken.kind === Syntax.Bar2Token || right.operatorToken.kind === Syntax.Ampersand2Token))
        grammarErrorOnNode(right, qd._0_and_1_operations_cannot_be_mixed_without_parentheses, Token.toString(right.operatorToken.kind), Token.toString(operatorToken.kind));
    }
  }
  function checkBinaryLikeExpression(left: Expression, operatorToken: Node, right: Expression, checkMode?: CheckMode, errorNode?: Node): Type {
    const operator = operatorToken.kind;
    if (operator === Syntax.EqualsToken && (left.kind === Syntax.ObjectLiteralExpression || left.kind === Syntax.ArrayLiteralExpression))
      return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode, right.kind === Syntax.ThisKeyword);
    let leftType: Type;
    if (operator === Syntax.Ampersand2Token || operator === Syntax.Bar2Token || operator === Syntax.Question2Token) leftType = checkTruthinessExpression(left, checkMode);
    else {
      leftType = checkExpression(left, checkMode);
    }
    const rightType = checkExpression(right, checkMode);
    return checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, errorNode);
  }
  function checkBinaryLikeExpressionWorker(left: Expression, operatorToken: Node, right: Expression, leftType: Type, rightType: Type, errorNode?: Node): Type {
    const operator = operatorToken.kind;
    switch (operator) {
      case Syntax.AsteriskToken:
      case Syntax.Asterisk2Token:
      case Syntax.AsteriskEqualsToken:
      case Syntax.Asterisk2EqualsToken:
      case Syntax.SlashToken:
      case Syntax.SlashEqualsToken:
      case Syntax.PercentToken:
      case Syntax.PercentEqualsToken:
      case Syntax.MinusToken:
      case Syntax.MinusEqualsToken:
      case Syntax.LessThan2Token:
      case Syntax.LessThan2EqualsToken:
      case Syntax.GreaterThan2Token:
      case Syntax.GreaterThan2EqualsToken:
      case Syntax.GreaterThan3Token:
      case Syntax.GreaterThan3EqualsToken:
      case Syntax.BarToken:
      case Syntax.BarEqualsToken:
      case Syntax.CaretToken:
      case Syntax.CaretEqualsToken:
      case Syntax.AmpersandToken:
      case Syntax.AmpersandEqualsToken:
        if (leftType === silentNeverType || rightType === silentNeverType) return silentNeverType;
        leftType = checkNonNullType(leftType, left);
        rightType = checkNonNullType(rightType, right);
        let suggestedOperator: Syntax | undefined;
        if (leftType.flags & TypeFlags.BooleanLike && rightType.flags & TypeFlags.BooleanLike && (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== undefined) {
          error(errorNode || operatorToken, qd.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, Token.toString(operatorToken.kind), Token.toString(suggestedOperator));
          return numberType;
        } else {
          const leftOk = checkArithmeticOperandType(left, leftType, qd.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, true);
          const rightOk = checkArithmeticOperandType(right, rightType, qd.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, true);
          let resultType: Type;
          if (
            (isTypeAssignableToKind(leftType, TypeFlags.AnyOrUnknown) && isTypeAssignableToKind(rightType, TypeFlags.AnyOrUnknown)) ||
            !(maybeTypeOfKind(leftType, TypeFlags.BigIntLike) || maybeTypeOfKind(rightType, TypeFlags.BigIntLike))
          ) {
            resultType = numberType;
          } else if (bothAreBigIntLike(leftType, rightType)) {
            switch (operator) {
              case Syntax.GreaterThan3Token:
              case Syntax.GreaterThan3EqualsToken:
                reportOperatorError();
                break;
              case Syntax.Asterisk2Token:
              case Syntax.Asterisk2EqualsToken:
            }
            resultType = bigintType;
          } else {
            reportOperatorError(bothAreBigIntLike);
            resultType = errorType;
          }
          if (leftOk && rightOk) checkAssignmentOperator(resultType);
          return resultType;
        }
      case Syntax.PlusToken:
      case Syntax.PlusEqualsToken:
        if (leftType === silentNeverType || rightType === silentNeverType) return silentNeverType;
        if (!isTypeAssignableToKind(leftType, TypeFlags.StringLike) && !isTypeAssignableToKind(rightType, TypeFlags.StringLike)) {
          leftType = checkNonNullType(leftType, left);
          rightType = checkNonNullType(rightType, right);
        }
        let resultType: Type | undefined;
        if (isTypeAssignableToKind(leftType, TypeFlags.NumberLike, true)) resultType = numberType;
        else if (isTypeAssignableToKind(leftType, TypeFlags.BigIntLike, true)) {
          resultType = bigintType;
        } else if (isTypeAssignableToKind(leftType, TypeFlags.StringLike, true)) {
          resultType = stringType;
        } else if (isTypeAny(leftType) || isTypeAny(rightType)) {
          resultType = leftType === errorType || rightType === errorType ? errorType : anyType;
        }
        if (resultType && !checkForDisallowedESSymbolOperand(operator)) return resultType;
        if (!resultType) {
          const closeEnoughKind = TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.AnyOrUnknown;
          reportOperatorError((left, right) => isTypeAssignableToKind(left, closeEnoughKind) && isTypeAssignableToKind(right, closeEnoughKind));
          return anyType;
        }
        if (operator === Syntax.PlusEqualsToken) checkAssignmentOperator(resultType);
        return resultType;
      case Syntax.LessThanToken:
      case Syntax.GreaterThanToken:
      case Syntax.LessThanEqualsToken:
      case Syntax.GreaterThanEqualsToken:
        if (checkForDisallowedESSymbolOperand(operator)) {
          leftType = getBaseTypeOfLiteralType(checkNonNullType(leftType, left));
          rightType = getBaseTypeOfLiteralType(checkNonNullType(rightType, right));
          reportOperatorErrorUnless(
            (left, right) => isTypeComparableTo(left, right) || isTypeComparableTo(right, left) || (isTypeAssignableTo(left, numberOrBigIntType) && isTypeAssignableTo(right, numberOrBigIntType))
          );
        }
        return booleanType;
      case Syntax.Equals2Token:
      case Syntax.ExclamationEqualsToken:
      case Syntax.Equals3Token:
      case Syntax.ExclamationEquals2Token:
        reportOperatorErrorUnless((left, right) => isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left));
        return booleanType;
      case Syntax.InstanceOfKeyword:
        return checkInstanceOfExpression(left, right, leftType, rightType);
      case Syntax.InKeyword:
        return checkInExpression(left, right, leftType, rightType);
      case Syntax.Ampersand2Token:
        return getTypeFacts(leftType) & TypeFacts.Truthy ? getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) : leftType;
      case Syntax.Bar2Token:
        return getTypeFacts(leftType) & TypeFacts.Falsy ? getUnionType([removeDefinitelyFalsyTypes(leftType), rightType], UnionReduction.Subtype) : leftType;
      case Syntax.Question2Token:
        return getTypeFacts(leftType) & TypeFacts.EQUndefinedOrNull ? getUnionType([getNonNullableType(leftType), rightType], UnionReduction.Subtype) : leftType;
      case Syntax.EqualsToken:
        const declKind = qc.is.kind(BinaryExpression, left.parent) ? getAssignmentDeclarationKind(left.parent) : AssignmentDeclarationKind.None;
        checkAssignmentDeclaration(declKind, rightType);
        if (isAssignmentDeclaration(declKind)) {
          if (
            !(rightType.flags & TypeFlags.Object) ||
            (declKind !== AssignmentDeclarationKind.ModuleExports &&
              declKind !== AssignmentDeclarationKind.Prototype &&
              !isEmptyObjectType(rightType) &&
              !isFunctionObjectType(rightType as ObjectType) &&
              !(getObjectFlags(rightType) & ObjectFlags.Class))
          ) {
            checkAssignmentOperator(rightType);
          }
          return leftType;
        } else {
          checkAssignmentOperator(rightType);
          return getRegularTypeOfObjectLiteral(rightType);
        }
      case Syntax.CommaToken:
        if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isEvalNode(right)) error(left, qd.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);
        return rightType;
      default:
        return fail();
    }
    function bothAreBigIntLike(left: Type, right: Type): boolean {
      return isTypeAssignableToKind(left, TypeFlags.BigIntLike) && isTypeAssignableToKind(right, TypeFlags.BigIntLike);
    }
    function checkAssignmentDeclaration(kind: AssignmentDeclarationKind, rightType: Type) {
      if (kind === AssignmentDeclarationKind.ModuleExports) {
        for (const prop of getPropertiesOfObjectType(rightType)) {
          const propType = getTypeOfSymbol(prop);
          if (propType.symbol && propType.symbol.flags & SymbolFlags.Class) {
            const name = prop.escName;
            const symbol = resolveName(prop.valueDeclaration, name, SymbolFlags.Type, undefined, name, false);
            if (symbol && symbol.declarations.some(isJSDocTypedefTag)) {
              addDuplicateDeclarationErrorsForSymbols(symbol, qd.Duplicate_identifier_0, syntax.get.unescUnderscores(name), prop);
              addDuplicateDeclarationErrorsForSymbols(prop, qd.Duplicate_identifier_0, syntax.get.unescUnderscores(name), symbol);
            }
          }
        }
      }
    }
    function isEvalNode(node: Expression) {
      return node.kind === Syntax.Identifier && (node as Identifier).escapedText === 'eval';
    }
    function checkForDisallowedESSymbolOperand(operator: Syntax): boolean {
      const offendingSymbolOperand = maybeTypeOfKind(leftType, TypeFlags.ESSymbolLike) ? left : maybeTypeOfKind(rightType, TypeFlags.ESSymbolLike) ? right : undefined;
      if (offendingSymbolOperand) {
        error(offendingSymbolOperand, qd.The_0_operator_cannot_be_applied_to_type_symbol, Token.toString(operator));
        return false;
      }
      return true;
    }
    function getSuggestedBooleanOperator(operator: Syntax): Syntax | undefined {
      switch (operator) {
        case Syntax.BarToken:
        case Syntax.BarEqualsToken:
          return Syntax.Bar2Token;
        case Syntax.CaretToken:
        case Syntax.CaretEqualsToken:
          return Syntax.ExclamationEquals2Token;
        case Syntax.AmpersandToken:
        case Syntax.AmpersandEqualsToken:
          return Syntax.Ampersand2Token;
        default:
          return;
      }
    }
    function checkAssignmentOperator(valueType: Type): void {
      if (produceDiagnostics && syntax.is.assignmentOperator(operator)) {
        if (
          checkReferenceExpression(
            left,
            qd.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access,
            qd.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access
          ) &&
          (!qc.is.kind(Identifier, left) || syntax.get.unescUnderscores(left.escapedText) !== 'exports')
        ) {
          checkTypeAssignableToAndOptionallyElaborate(valueType, leftType, left, right);
        }
      }
    }
    function isAssignmentDeclaration(kind: AssignmentDeclarationKind) {
      switch (kind) {
        case AssignmentDeclarationKind.ModuleExports:
          return true;
        case AssignmentDeclarationKind.ExportsProperty:
        case AssignmentDeclarationKind.Property:
        case AssignmentDeclarationKind.Prototype:
        case AssignmentDeclarationKind.PrototypeProperty:
        case AssignmentDeclarationKind.ThisProperty:
          const symbol = getSymbolOfNode(left);
          const init = getAssignedExpandoInitializer(right);
          return init && qc.is.kind(ObjectLiteralExpression, init) && symbol && hasEntries(symbol.exports);
        default:
          return false;
      }
    }
    function reportOperatorErrorUnless(typesAreCompatible: (left: Type, right: Type) => boolean): boolean {
      if (!typesAreCompatible(leftType, rightType)) {
        reportOperatorError(typesAreCompatible);
        return true;
      }
      return false;
    }
    function reportOperatorError(isRelated?: (left: Type, right: Type) => boolean) {
      let wouldWorkWithAwait = false;
      const errNode = errorNode || operatorToken;
      if (isRelated) {
        const awaitedLeftType = getAwaitedType(leftType);
        const awaitedRightType = getAwaitedType(rightType);
        wouldWorkWithAwait = !(awaitedLeftType === leftType && awaitedRightType === rightType) && !!(awaitedLeftType && awaitedRightType) && isRelated(awaitedLeftType, awaitedRightType);
      }
      let effectiveLeft = leftType;
      let effectiveRight = rightType;
      if (!wouldWorkWithAwait && isRelated) [effectiveLeft, effectiveRight] = getBaseTypesIfUnrelated(leftType, rightType, isRelated);
      const [leftStr, rightStr] = getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight);
      if (!tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr))
        errorAndMaybeSuggestAwait(errNode, wouldWorkWithAwait, qd.Operator_0_cannot_be_applied_to_types_1_and_2, Token.toString(operatorToken.kind), leftStr, rightStr);
    }
    function tryGiveBetterPrimaryError(errNode: Node, maybeMissingAwait: boolean, leftStr: string, rightStr: string) {
      let typeName: string | undefined;
      switch (operatorToken.kind) {
        case Syntax.Equals3Token:
        case Syntax.Equals2Token:
          typeName = 'false';
          break;
        case Syntax.ExclamationEquals2Token:
        case Syntax.ExclamationEqualsToken:
          typeName = 'true';
      }
      if (typeName) return errorAndMaybeSuggestAwait(errNode, maybeMissingAwait, qd.This_condition_will_always_return_0_since_the_types_1_and_2_have_no_overlap, typeName, leftStr, rightStr);
      return;
    }
  }
  function getBaseTypesIfUnrelated(leftType: Type, rightType: Type, isRelated: (left: Type, right: Type) => boolean): [Type, Type] {
    let effectiveLeft = leftType;
    let effectiveRight = rightType;
    const leftBase = getBaseTypeOfLiteralType(leftType);
    const rightBase = getBaseTypeOfLiteralType(rightType);
    if (!isRelated(leftBase, rightBase)) {
      effectiveLeft = leftBase;
      effectiveRight = rightBase;
    }
    return [effectiveLeft, effectiveRight];
  }
  function checkYieldExpression(node: YieldExpression): Type {
    if (produceDiagnostics) {
      if (!(node.flags & NodeFlags.YieldContext)) grammarErrorOnFirstToken(node, qd.A_yield_expression_is_only_allowed_in_a_generator_body);
      if (isInParameterInitializerBeforeContainingFunction(node)) error(node, qd.yield_expressions_cannot_be_used_in_a_parameter_initializer);
    }
    const func = qc.get.containingFunction(node);
    if (!func) return anyType;
    const functionFlags = getFunctionFlags(func);
    if (!(functionFlags & FunctionFlags.Generator)) return anyType;
    const isAsync = (functionFlags & FunctionFlags.Async) !== 0;
    if (node.asteriskToken) {
      if (isAsync && languageVersion < ScriptTarget.ESNext) checkExternalEmitHelpers(node, ExternalEmitHelpers.AsyncDelegatorIncludes);
    }
    const returnType = getReturnTypeFromAnnotation(func);
    const iterationTypes = returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync);
    const signatureYieldType = (iterationTypes && iterationTypes.yieldType) || anyType;
    const signatureNextType = (iterationTypes && iterationTypes.nextType) || anyType;
    const resolvedSignatureNextType = isAsync ? getAwaitedType(signatureNextType) || anyType : signatureNextType;
    const yieldExpressionType = node.expression ? checkExpression(node.expression) : undefinedWideningType;
    const yieldedType = getYieldedTypeOfYieldExpression(node, yieldExpressionType, resolvedSignatureNextType, isAsync);
    if (returnType && yieldedType) checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression);
    if (node.asteriskToken) {
      const use = isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar;
      return getIterationTypeOfIterable(use, IterationTypeKind.Return, yieldExpressionType, node.expression) || anyType;
    } else if (returnType) {
      return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Next, returnType, isAsync) || anyType;
    }
    return getContextualIterationType(IterationTypeKind.Next, func) || anyType;
  }
  function checkConditionalExpression(node: ConditionalExpression, checkMode?: CheckMode): Type {
    const type = checkTruthinessExpression(node.condition);
    checkTestingKnownTruthyCallableType(node.condition, node.whenTrue, type);
    const type1 = checkExpression(node.whenTrue, checkMode);
    const type2 = checkExpression(node.whenFalse, checkMode);
    return getUnionType([type1, type2], UnionReduction.Subtype);
  }
  function checkTemplateExpression(node: TemplateExpression): Type {
    forEach(node.templateSpans, (templateSpan) => {
      if (maybeTypeOfKind(checkExpression(templateSpan.expression), TypeFlags.ESSymbolLike))
        error(templateSpan.expression, qd.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String);
    });
    return stringType;
  }
  function getContextNode(node: Expression): Node {
    if (node.kind === Syntax.JsxAttributes && !qc.is.kind(JsxSelfClosingElement, node.parent)) return node.parent.parent;
    return node;
  }
  function checkExpressionWithContextualType(node: Expression, contextualType: Type, inferenceContext: InferenceContext | undefined, checkMode: CheckMode): Type {
    const context = getContextNode(node);
    const saveContextualType = context.contextualType;
    const saveInferenceContext = context.inferenceContext;
    try {
      context.contextualType = contextualType;
      context.inferenceContext = inferenceContext;
      const type = checkExpression(node, checkMode | CheckMode.Contextual | (inferenceContext ? CheckMode.Inferential : 0));
      const result = maybeTypeOfKind(type, TypeFlags.Literal) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node)) ? getRegularTypeOfLiteralType(type) : type;
      return result;
    } finally {
      context.contextualType = saveContextualType;
      context.inferenceContext = saveInferenceContext;
    }
  }
  function checkExpressionCached(node: Expression | QualifiedName, checkMode?: CheckMode): Type {
    const links = getNodeLinks(node);
    if (!links.resolvedType) {
      if (checkMode && checkMode !== CheckMode.Normal) return checkExpression(node, checkMode);
      const saveFlowLoopStart = flowLoopStart;
      const saveFlowTypeCache = flowTypeCache;
      flowLoopStart = flowLoopCount;
      flowTypeCache = undefined;
      links.resolvedType = checkExpression(node, checkMode);
      flowTypeCache = saveFlowTypeCache;
      flowLoopStart = saveFlowLoopStart;
    }
    return links.resolvedType;
  }
  function isNodekind(TypeAssertion, node: Expression) {
    node = skipParentheses(node);
    return node.kind === Syntax.TypeAssertionExpression || node.kind === Syntax.AsExpression;
  }
  function checkDeclarationInitializer(declaration: HasExpressionInitializer, contextualType?: Type | undefined) {
    const initializer = getEffectiveInitializer(declaration)!;
    const type =
      getQuickTypeOfExpression(initializer) || (contextualType ? checkExpressionWithContextualType(initializer, contextualType, undefined, CheckMode.Normal) : checkExpressionCached(initializer));
    return qc.is.kind(ParameterDeclaration, declaration) &&
      declaration.name.kind === Syntax.ArrayBindingPattern &&
      isTupleType(type) &&
      !type.target.hasRestElement &&
      getTypeReferenceArity(type) < declaration.name.elements.length
      ? padTupleType(type, declaration.name)
      : type;
  }
  function padTupleType(type: TupleTypeReference, pattern: ArrayBindingPattern) {
    const patternElements = pattern.elements;
    const arity = getTypeReferenceArity(type);
    const elementTypes = arity ? getTypeArguments(type).slice() : [];
    for (let i = arity; i < patternElements.length; i++) {
      const e = patternElements[i];
      if (i < patternElements.length - 1 || !(e.kind === Syntax.BindingElement && e.dot3Token)) {
        elementTypes.push(!qc.is.kind(OmittedExpression, e) && hasDefaultValue(e) ? getTypeFromBindingElement(e, false, false) : anyType);
        if (!qc.is.kind(OmittedExpression, e) && !hasDefaultValue(e)) reportImplicitAny(e, anyType);
      }
    }
    return createTupleType(elementTypes, type.target.minLength, false, type.target.readonly);
  }
  function widenTypeInferredFromInitializer(declaration: HasExpressionInitializer, type: Type) {
    const widened = qc.get.combinedFlagsOf(declaration) & NodeFlags.Const || isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type);
    if (isInJSFile(declaration)) {
      if (widened.flags & TypeFlags.Nullable) {
        reportImplicitAny(declaration, anyType);
        return anyType;
      } else if (isEmptyArrayLiteralType(widened)) {
        reportImplicitAny(declaration, anyArrayType);
        return anyArrayType;
      }
    }
    return widened;
  }
  function isLiteralOfContextualType(candidateType: Type, contextualType: Type | undefined): boolean {
    if (contextualType) {
      if (contextualType.flags & TypeFlags.UnionOrIntersection) {
        const types = (<UnionType>contextualType).types;
        return some(types, (t) => isLiteralOfContextualType(candidateType, t));
      }
      if (contextualType.flags & TypeFlags.InstantiableNonPrimitive) {
        const constraint = getBaseConstraintOfType(contextualType) || unknownType;
        return (
          (maybeTypeOfKind(constraint, TypeFlags.String) && maybeTypeOfKind(candidateType, TypeFlags.StringLiteral)) ||
          (maybeTypeOfKind(constraint, TypeFlags.Number) && maybeTypeOfKind(candidateType, TypeFlags.NumberLiteral)) ||
          (maybeTypeOfKind(constraint, TypeFlags.BigInt) && maybeTypeOfKind(candidateType, TypeFlags.BigIntLiteral)) ||
          (maybeTypeOfKind(constraint, TypeFlags.ESSymbol) && maybeTypeOfKind(candidateType, TypeFlags.UniqueESSymbol)) ||
          isLiteralOfContextualType(candidateType, constraint)
        );
      }
      return !!(
        (contextualType.flags & (TypeFlags.StringLiteral | TypeFlags.Index) && maybeTypeOfKind(candidateType, TypeFlags.StringLiteral)) ||
        (contextualType.flags & TypeFlags.NumberLiteral && maybeTypeOfKind(candidateType, TypeFlags.NumberLiteral)) ||
        (contextualType.flags & TypeFlags.BigIntLiteral && maybeTypeOfKind(candidateType, TypeFlags.BigIntLiteral)) ||
        (contextualType.flags & TypeFlags.BooleanLiteral && maybeTypeOfKind(candidateType, TypeFlags.BooleanLiteral)) ||
        (contextualType.flags & TypeFlags.UniqueESSymbol && maybeTypeOfKind(candidateType, TypeFlags.UniqueESSymbol))
      );
    }
    return false;
  }
  function isConstContext(node: Expression): boolean {
    const parent = node.parent;
    return (
      (qc.is.assertionExpression(parent) && qc.is.constTypeReference(parent.type)) ||
      ((qc.is.kind(ParenthesizedExpression, parent) || isArrayLiteralExpression(parent) || qc.is.kind(SpreadElement, parent)) && isConstContext(parent)) ||
      ((qc.is.kind(PropertyAssignment, parent) || qc.is.kind(ShorthandPropertyAssignment, parent)) && isConstContext(parent.parent))
    );
  }
  function checkExpressionForMutableLocation(node: Expression, checkMode: CheckMode | undefined, contextualType?: Type, forceTuple?: boolean): Type {
    const type = checkExpression(node, checkMode, forceTuple);
    return isConstContext(node)
      ? getRegularTypeOfLiteralType(type)
      : qc.is.kind(TypeAssertion, node)
      ? type
      : getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(arguments.length === 2 ? getContextualType(node) : contextualType, node));
  }
  function checkPropertyAssignment(node: PropertyAssignment, checkMode?: CheckMode): Type {
    if (node.name.kind === Syntax.ComputedPropertyName) checkComputedPropertyName(node.name);
    return checkExpressionForMutableLocation(node.initializer, checkMode);
  }
  function checkObjectLiteralMethod(node: MethodDeclaration, checkMode?: CheckMode): Type {
    checkGrammarMethod(node);
    if (node.name.kind === Syntax.ComputedPropertyName) checkComputedPropertyName(node.name);
    const uninstantiatedType = checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
    return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
  }
  function instantiateTypeWithSingleGenericCallSignature(node: Expression | MethodDeclaration | QualifiedName, type: Type, checkMode?: CheckMode) {
    if (checkMode && checkMode & (CheckMode.Inferential | CheckMode.SkipGenericFunctions)) {
      const callSignature = getSingleSignature(type, SignatureKind.Call, true);
      const constructSignature = getSingleSignature(type, SignatureKind.Construct, true);
      const signature = callSignature || constructSignature;
      if (signature && signature.typeParameters) {
        const contextualType = getApparentTypeOfContextualType(<Expression>node, ContextFlags.NoConstraints);
        if (contextualType) {
          const contextualSignature = getSingleSignature(getNonNullableType(contextualType), callSignature ? SignatureKind.Call : SignatureKind.Construct, false);
          if (contextualSignature && !contextualSignature.typeParameters) {
            if (checkMode & CheckMode.SkipGenericFunctions) {
              skippedGenericFunction(node, checkMode);
              return anyFunctionType;
            }
            const context = getInferenceContext(node)!;
            const returnType = context.signature && getReturnTypeOfSignature(context.signature);
            const returnSignature = returnType && getSingleCallOrConstructSignature(returnType);
            if (returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates)) {
              const uniqueTypeParameters = getUniqueTypeParameters(context, signature.typeParameters);
              const instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters);
              const inferences = map(context.inferences, (info) => createInferenceInfo(info.typeParameter));
              applyToParameterTypes(instantiatedSignature, contextualSignature, (source, target) => {
                inferTypes(inferences, source, target, true);
              });
              if (some(inferences, hasInferenceCandidates)) {
                applyToReturnTypes(instantiatedSignature, contextualSignature, (source, target) => {
                  inferTypes(inferences, source, target);
                });
                if (!hasOverlappingInferences(context.inferences, inferences)) {
                  mergeInferences(context.inferences, inferences);
                  context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters);
                  return getOrCreateTypeFromSignature(instantiatedSignature);
                }
              }
            }
            return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context));
          }
        }
      }
    }
    return type;
  }
  function skippedGenericFunction(node: Node, checkMode: CheckMode) {
    if (checkMode & CheckMode.Inferential) {
      const context = getInferenceContext(node)!;
      context.flags |= InferenceFlags.SkippedGenericFunction;
    }
  }
  function hasInferenceCandidates(info: InferenceInfo) {
    return !!(info.candidates || info.contraCandidates);
  }
  function hasOverlappingInferences(a: InferenceInfo[], b: InferenceInfo[]) {
    for (let i = 0; i < a.length; i++) {
      if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) return true;
    }
    return false;
  }
  function mergeInferences(target: InferenceInfo[], source: InferenceInfo[]) {
    for (let i = 0; i < target.length; i++) {
      if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) target[i] = source[i];
    }
  }
  function getUniqueTypeParameters(context: InferenceContext, typeParameters: readonly TypeParameter[]): readonly TypeParameter[] {
    const result: TypeParameter[] = [];
    let oldTypeParameters: TypeParameter[] | undefined;
    let newTypeParameters: TypeParameter[] | undefined;
    for (const tp of typeParameters) {
      const name = tp.symbol.escName;
      if (hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name)) {
        const newName = getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name);
        const symbol = new QSymbol(SymbolFlags.TypeParameter, newName);
        const newTypeParameter = createTypeParameter(symbol);
        newTypeParameter.target = tp;
        oldTypeParameters = append(oldTypeParameters, tp);
        newTypeParameters = append(newTypeParameters, newTypeParameter);
        result.push(newTypeParameter);
      } else {
        result.push(tp);
      }
    }
    if (newTypeParameters) {
      const mapper = createTypeMapper(oldTypeParameters!, newTypeParameters);
      for (const tp of newTypeParameters) {
        tp.mapper = mapper;
      }
    }
    return result;
  }
  function hasTypeParameterByName(typeParameters: readonly TypeParameter[] | undefined, name: __String) {
    return some(typeParameters, (tp) => tp.symbol.escName === name);
  }
  function getUniqueTypeParameterName(typeParameters: readonly TypeParameter[], baseName: __String) {
    let len = (<string>baseName).length;
    while (len > 1 && (<string>baseName).charCodeAt(len - 1) >= Codes._0 && (<string>baseName).charCodeAt(len - 1) <= Codes._9) len--;
    const s = (<string>baseName).slice(0, len);
    for (let index = 1; true; index++) {
      const augmentedName = <__String>(s + index);
      if (!hasTypeParameterByName(typeParameters, augmentedName)) return augmentedName;
    }
  }
  function getReturnTypeOfSingleNonGenericCallSignature(funcType: Type) {
    const signature = getSingleCallSignature(funcType);
    if (signature && !signature.typeParameters) return getReturnTypeOfSignature(signature);
  }
  function getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr: CallChain) {
    const funcType = checkExpression(expr.expression);
    const nonOptionalType = getOptionalExpressionType(funcType, expr.expression);
    const returnType = getReturnTypeOfSingleNonGenericCallSignature(funcType);
    return returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType !== funcType);
  }
  function getTypeOfExpression(node: Expression) {
    const quickType = getQuickTypeOfExpression(node);
    if (quickType) return quickType;
    if (node.flags & NodeFlags.TypeCached && flowTypeCache) {
      const cachedType = flowTypeCache[getNodeId(node)];
      if (cachedType) return cachedType;
    }
    const startInvocationCount = flowInvocationCount;
    const type = checkExpression(node);
    if (flowInvocationCount !== startInvocationCount) {
      const cache = flowTypeCache || (flowTypeCache = []);
      cache[getNodeId(node)] = type;
      node.flags |= NodeFlags.TypeCached;
    }
    return type;
  }
  function getQuickTypeOfExpression(node: Expression) {
    const expr = skipParentheses(node);
    if (qc.is.kind(CallExpression, expr) && expr.expression.kind !== Syntax.SuperKeyword && !isRequireCall(expr, true) && !isSymbolOrSymbolForCall(expr)) {
      const type = qc.is.callChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) : getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression));
      if (type) return type;
    } else if (qc.is.assertionExpression(expr) && !qc.is.constTypeReference(expr.type)) {
      return getTypeFromTypeNode((<TypeAssertion>expr).type);
    } else if (node.kind === Syntax.NumericLiteral || node.kind === Syntax.StringLiteral || node.kind === Syntax.TrueKeyword || node.kind === Syntax.FalseKeyword) {
      return checkExpression(node);
    }
    return;
  }
  function getContextFreeTypeOfExpression(node: Expression) {
    const links = getNodeLinks(node);
    if (links.contextFreeType) return links.contextFreeType;
    const saveContextualType = node.contextualType;
    node.contextualType = anyType;
    try {
      const type = (links.contextFreeType = checkExpression(node, CheckMode.SkipContextSensitive));
      return type;
    } finally {
      node.contextualType = saveContextualType;
    }
  }
  function checkExpression(node: Expression | QualifiedName, checkMode?: CheckMode, forceTuple?: boolean): Type {
    const saveCurrentNode = currentNode;
    currentNode = node;
    instantiationCount = 0;
    const uninstantiatedType = checkExpressionWorker(node, checkMode, forceTuple);
    const type = instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
    if (isConstEnumObjectType(type)) checkConstEnumAccess(node, type);
    currentNode = saveCurrentNode;
    return type;
  }
  function checkConstEnumAccess(node: Expression | QualifiedName, type: Type) {
    const ok =
      (node.parent.kind === Syntax.PropertyAccessExpression && (<PropertyAccessExpression>node.parent).expression === node) ||
      (node.parent.kind === Syntax.ElementAccessExpression && (<ElementAccessExpression>node.parent).expression === node) ||
      ((node.kind === Syntax.Identifier || node.kind === Syntax.QualifiedName) && isInRightSideOfImportOrExportAssignment(<Identifier>node)) ||
      (node.parent.kind === Syntax.TypeQuery && (<TypeQueryNode>node.parent).exprName === node) ||
      node.parent.kind === Syntax.ExportSpecifier;
    if (!ok) error(node, qd.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query);
    if (compilerOptions.isolatedModules) {
      assert(!!(type.symbol.flags & SymbolFlags.ConstEnum));
      const constEnumDeclaration = type.symbol.valueDeclaration as EnumDeclaration;
      if (constEnumDeclaration.flags & NodeFlags.Ambient) error(node, qd.Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided);
    }
  }
  function checkParenthesizedExpression(node: ParenthesizedExpression, checkMode?: CheckMode): Type {
    const tag = isInJSFile(node) ? qc.getDoc.typeTag(node) : undefined;
    if (tag) return checkAssertionWorker(tag, tag.typeExpression.type, node.expression, checkMode);
    return checkExpression(node.expression, checkMode);
  }
  function checkExpressionWorker(node: Expression | QualifiedName, checkMode: CheckMode | undefined, forceTuple?: boolean): Type {
    const kind = node.kind;
    if (cancellationToken) {
      switch (kind) {
        case Syntax.ClassExpression:
        case Syntax.FunctionExpression:
        case Syntax.ArrowFunction:
          cancellationToken.throwIfCancellationRequested();
      }
    }
    switch (kind) {
      case Syntax.Identifier:
        return checkIdentifier(<Identifier>node);
      case Syntax.ThisKeyword:
        return checkThisNodeExpression(node);
      case Syntax.SuperKeyword:
        return checkSuperExpression(node);
      case Syntax.NullKeyword:
        return nullWideningType;
      case Syntax.NoSubstitutionLiteral:
      case Syntax.StringLiteral:
        return getFreshTypeOfLiteralType(getLiteralType((node as StringLiteralLike).text));
      case Syntax.NumericLiteral:
        checkGrammarNumericLiteral(node as NumericLiteral);
        return getFreshTypeOfLiteralType(getLiteralType(+(node as NumericLiteral).text));
      case Syntax.BigIntLiteral:
        checkGrammarBigIntLiteral(node as BigIntLiteral);
        return getFreshTypeOfLiteralType(getBigIntLiteralType(node as BigIntLiteral));
      case Syntax.TrueKeyword:
        return trueType;
      case Syntax.FalseKeyword:
        return falseType;
      case Syntax.TemplateExpression:
        return checkTemplateExpression(<TemplateExpression>node);
      case Syntax.RegexLiteral:
        return globalRegExpType;
      case Syntax.ArrayLiteralExpression:
        return checkArrayLiteral(<ArrayLiteralExpression>node, checkMode, forceTuple);
      case Syntax.ObjectLiteralExpression:
        return checkObjectLiteral(<ObjectLiteralExpression>node, checkMode);
      case Syntax.PropertyAccessExpression:
        return checkPropertyAccessExpression(<PropertyAccessExpression>node);
      case Syntax.QualifiedName:
        return checkQualifiedName(<QualifiedName>node);
      case Syntax.ElementAccessExpression:
        return checkIndexedAccess(<ElementAccessExpression>node);
      case Syntax.CallExpression:
        if ((<CallExpression>node).expression.kind === Syntax.ImportKeyword) return checkImportCallExpression(<ImportCall>node);
      case Syntax.NewExpression:
        return checkCallExpression(<CallExpression>node, checkMode);
      case Syntax.TaggedTemplateExpression:
        return checkTaggedTemplateExpression(<TaggedTemplateExpression>node);
      case Syntax.ParenthesizedExpression:
        return checkParenthesizedExpression(<ParenthesizedExpression>node, checkMode);
      case Syntax.ClassExpression:
        return checkClassExpression(<ClassExpression>node);
      case Syntax.FunctionExpression:
      case Syntax.ArrowFunction:
        return checkFunctionExpressionOrObjectLiteralMethod(<FunctionExpression | ArrowFunction>node, checkMode);
      case Syntax.TypeOfExpression:
        return checkTypeOfExpression(<TypeOfExpression>node);
      case Syntax.TypeAssertionExpression:
      case Syntax.AsExpression:
        return checkAssertion(<AssertionExpression>node);
      case Syntax.NonNullExpression:
        return checkNonNullAssertion(<NonNullExpression>node);
      case Syntax.MetaProperty:
        return checkMetaProperty(<MetaProperty>node);
      case Syntax.DeleteExpression:
        return checkDeleteExpression(<DeleteExpression>node);
      case Syntax.VoidExpression:
        return checkVoidExpression(<VoidExpression>node);
      case Syntax.AwaitExpression:
        return checkAwaitExpression(<AwaitExpression>node);
      case Syntax.PrefixUnaryExpression:
        return checkPrefixUnaryExpression(<PrefixUnaryExpression>node);
      case Syntax.PostfixUnaryExpression:
        return checkPostfixUnaryExpression(<PostfixUnaryExpression>node);
      case Syntax.BinaryExpression:
        return checkBinaryExpression(<BinaryExpression>node, checkMode);
      case Syntax.ConditionalExpression:
        return checkConditionalExpression(<ConditionalExpression>node, checkMode);
      case Syntax.SpreadElement:
        return checkSpreadExpression(<SpreadElement>node, checkMode);
      case Syntax.OmittedExpression:
        return undefinedWideningType;
      case Syntax.YieldExpression:
        return checkYieldExpression(<YieldExpression>node);
      case Syntax.SyntheticExpression:
        return (<SyntheticExpression>node).type;
      case Syntax.JsxExpression:
        return checkJsxExpression(<JsxExpression>node, checkMode);
      case Syntax.JsxElement:
        return checkJsxElement(<JsxElement>node, checkMode);
      case Syntax.JsxSelfClosingElement:
        return checkJsxSelfClosingElement(<JsxSelfClosingElement>node, checkMode);
      case Syntax.JsxFragment:
        return checkJsxFragment(<JsxFragment>node);
      case Syntax.JsxAttributes:
        return checkJsxAttributes(<JsxAttributes>node, checkMode);
      case Syntax.JsxOpeningElement:
        fail("Shouldn't ever directly check a JsxOpeningElement");
    }
    return errorType;
  }
  function checkTypeParameter(node: TypeParameterDeclaration) {
    if (node.expression) grammarErrorOnFirstToken(node.expression, qd.Type_expected);
    checkSourceElement(node.constraint);
    checkSourceElement(node.default);
    const typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));
    getBaseConstraintOfType(typeParameter);
    if (!hasNonCircularTypeParameterDefault(typeParameter)) error(node.default, qd.Type_parameter_0_has_a_circular_default, typeToString(typeParameter));
    const constraintType = getConstraintOfTypeParameter(typeParameter);
    const defaultType = getDefaultFromTypeParameter(typeParameter);
    if (constraintType && defaultType) {
      checkTypeAssignableTo(
        defaultType,
        getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType),
        node.default,
        qd.Type_0_does_not_satisfy_the_constraint_1
      );
    }
    if (produceDiagnostics) checkTypeNameIsReserved(node.name, qd.Type_parameter_name_cannot_be_0);
  }
  function checkParameter(node: ParameterDeclaration) {
    checkGrammarDecoratorsAndModifiers(node);
    checkVariableLikeDeclaration(node);
    const func = qc.get.containingFunction(node)!;
    if (hasSyntacticModifier(node, ModifierFlags.ParameterPropertyModifier)) {
      if (!(func.kind === Syntax.Constructor && qc.is.present(func.body))) error(node, qd.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
      if (func.kind === Syntax.Constructor && qc.is.kind(Identifier, node.name) && node.name.escapedText === 'constructor')
        error(node.name, qd.constructor_cannot_be_used_as_a_parameter_property_name);
    }
    if (node.questionToken && qc.is.kind(BindingPattern, node.name) && (func as FunctionLikeDeclaration).body)
      error(node, qd.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature);
    if (node.name && qc.is.kind(Identifier, node.name) && (node.name.escapedText === 'this' || node.name.escapedText === 'new')) {
      if (func.parameters.indexOf(node) !== 0) error(node, qd.A_0_parameter_must_be_the_first_parameter, node.name.escapedText as string);
      if (func.kind === Syntax.Constructor || func.kind === Syntax.ConstructSignature || func.kind === Syntax.ConstructorType) error(node, qd.A_constructor_cannot_have_a_this_parameter);
      if (func.kind === Syntax.ArrowFunction) error(node, qd.An_arrow_function_cannot_have_a_this_parameter);
      if (func.kind === Syntax.GetAccessor || func.kind === Syntax.SetAccessor) error(node, qd.get_and_set_accessors_cannot_declare_this_parameters);
    }
    if (node.dot3Token && !qc.is.kind(BindingPattern, node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType))
      error(node, qd.A_rest_parameter_must_be_of_an_array_type);
  }
  function checkTypePredicate(node: TypePredicateNode): void {
    const parent = getTypePredicateParent(node);
    if (!parent) {
      error(node, qd.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
      return;
    }
    const signature = getSignatureFromDeclaration(parent);
    const typePredicate = getTypePredicateOfSignature(signature);
    if (!typePredicate) return;
    checkSourceElement(node.type);
    const { parameterName } = node;
    if (typePredicate.kind === TypePredicateKind.This || typePredicate.kind === TypePredicateKind.AssertsThis) getTypeFromThisNodeTypeNode(parameterName as ThisTypeNode);
    else {
      if (typePredicate.parameterIndex >= 0) {
        if (signatureHasRestParameter(signature) && typePredicate.parameterIndex === signature.parameters.length - 1) error(parameterName, qd.A_type_predicate_cannot_reference_a_rest_parameter);
        else {
          if (typePredicate.type) {
            const leadingError = () => chainDiagnosticMessages(undefined, qd.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type);
            checkTypeAssignableTo(typePredicate.type, getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]), node.type, undefined, leadingError);
          }
        }
      } else if (parameterName) {
        let hasReportedError = false;
        for (const { name } of parent.parameters) {
          if (qc.is.kind(BindingPattern, name) && checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName)) {
            hasReportedError = true;
            break;
          }
        }
        if (!hasReportedError) error(node.parameterName, qd.Cannot_find_parameter_0, typePredicate.parameterName);
      }
    }
  }
  function getTypePredicateParent(node: Node): SignatureDeclaration | undefined {
    switch (node.parent.kind) {
      case Syntax.ArrowFunction:
      case Syntax.CallSignature:
      case Syntax.FunctionDeclaration:
      case Syntax.FunctionExpression:
      case Syntax.FunctionType:
      case Syntax.MethodDeclaration:
      case Syntax.MethodSignature:
        const parent = <SignatureDeclaration>node.parent;
        if (node === parent.type) return parent;
    }
  }
  function checkIfTypePredicateVariableIsDeclaredInBindingPattern(pattern: BindingPattern, predicateVariableNode: Node, predicateVariableName: string) {
    for (const element of pattern.elements) {
      if (qc.is.kind(OmittedExpression, element)) continue;
      const name = element.name;
      if (name.kind === Syntax.Identifier && name.escapedText === predicateVariableName) {
        error(predicateVariableNode, qd.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName);
        return true;
      } else if (name.kind === Syntax.ArrayBindingPattern || name.kind === Syntax.ObjectBindingPattern) {
        if (checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName)) return true;
      }
    }
  }
  function checkSignatureDeclaration(node: SignatureDeclaration) {
    if (node.kind === Syntax.IndexSignature) checkGrammarIndexSignature(<SignatureDeclaration>node);
    else if (
      node.kind === Syntax.FunctionType ||
      node.kind === Syntax.FunctionDeclaration ||
      node.kind === Syntax.ConstructorType ||
      node.kind === Syntax.CallSignature ||
      node.kind === Syntax.Constructor ||
      node.kind === Syntax.ConstructSignature
    ) {
      checkGrammarFunctionLikeDeclaration(<FunctionLikeDeclaration>node);
    }
    const functionFlags = getFunctionFlags(<FunctionLikeDeclaration>node);
    if (!(functionFlags & FunctionFlags.Invalid)) {
      if ((functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.AsyncGenerator && languageVersion < ScriptTarget.ESNext)
        checkExternalEmitHelpers(node, ExternalEmitHelpers.AsyncGeneratorIncludes);
    }
    checkTypeParameters(node.typeParameters);
    forEach(node.parameters, checkParameter);
    if (node.type) checkSourceElement(node.type);
    if (produceDiagnostics) {
      checkCollisionWithArgumentsInGeneratedCode(node);
      const returnTypeNode = getEffectiveReturnTypeNode(node);
      if (noImplicitAny && !returnTypeNode) {
        switch (node.kind) {
          case Syntax.ConstructSignature:
            error(node, qd.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
            break;
          case Syntax.CallSignature:
            error(node, qd.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
            break;
        }
      }
      if (returnTypeNode) {
        const functionFlags = getFunctionFlags(<FunctionDeclaration>node);
        if ((functionFlags & (FunctionFlags.Invalid | FunctionFlags.Generator)) === FunctionFlags.Generator) {
          const returnType = getTypeFromTypeNode(returnTypeNode);
          if (returnType === voidType) error(returnTypeNode, qd.A_generator_cannot_have_a_void_type_annotation);
          else {
            const generatorYieldType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Yield, returnType, (functionFlags & FunctionFlags.Async) !== 0) || anyType;
            const generatorReturnType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, returnType, (functionFlags & FunctionFlags.Async) !== 0) || generatorYieldType;
            const generatorNextType = getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Next, returnType, (functionFlags & FunctionFlags.Async) !== 0) || unknownType;
            const generatorInstantiation = createGeneratorReturnType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags & FunctionFlags.Async));
            checkTypeAssignableTo(generatorInstantiation, returnType, returnTypeNode);
          }
        } else if ((functionFlags & FunctionFlags.AsyncGenerator) === FunctionFlags.Async) {
          checkAsyncFunctionReturnType(<FunctionLikeDeclaration>node, returnTypeNode);
        }
      }
      if (node.kind !== Syntax.IndexSignature && node.kind !== Syntax.JSDocFunctionType) registerForUnusedIdentifiersCheck(node);
    }
  }
  function checkClassForDuplicateDeclarations(node: ClassLikeDeclaration) {
    const instanceNames = createUnderscoreEscapedMap<DeclarationMeaning>();
    const staticNames = createUnderscoreEscapedMap<DeclarationMeaning>();
    const privateIdentifiers = createUnderscoreEscapedMap<DeclarationMeaning>();
    for (const member of node.members) {
      if (member.kind === Syntax.Constructor) {
        for (const param of (member as ConstructorDeclaration).parameters) {
          if (qc.is.parameterPropertyDeclaration(param, member) && !qc.is.kind(BindingPattern, param.name))
            addName(instanceNames, param.name, param.name.escapedText, DeclarationMeaning.GetOrSetAccessor);
        }
      } else {
        const isStatic = hasSyntacticModifier(member, ModifierFlags.Static);
        const name = member.name;
        if (!name) return;
        const names = qc.is.kind(PrivateIdentifier, name) ? privateIdentifiers : isStatic ? staticNames : instanceNames;
        const memberName = name && getPropertyNameForPropertyNameNode(name);
        if (memberName) {
          switch (member.kind) {
            case Syntax.GetAccessor:
              addName(names, name, memberName, DeclarationMeaning.GetAccessor);
              break;
            case Syntax.SetAccessor:
              addName(names, name, memberName, DeclarationMeaning.SetAccessor);
              break;
            case Syntax.PropertyDeclaration:
              addName(names, name, memberName, DeclarationMeaning.GetOrSetAccessor);
              break;
            case Syntax.MethodDeclaration:
              addName(names, name, memberName, DeclarationMeaning.Method);
              break;
          }
        }
      }
    }
    function addName(names: UnderscoreEscapedMap<DeclarationMeaning>, location: Node, name: __String, meaning: DeclarationMeaning) {
      const prev = names.get(name);
      if (prev) {
        if (prev & DeclarationMeaning.Method) {
          if (meaning !== DeclarationMeaning.Method) error(location, qd.Duplicate_identifier_0, qc.get.textOf(location));
        } else if (prev & meaning) {
          error(location, qd.Duplicate_identifier_0, qc.get.textOf(location));
        } else {
          names.set(name, prev | meaning);
        }
      } else {
        names.set(name, meaning);
      }
    }
  }
  function checkClassForStaticPropertyNameConflicts(node: ClassLikeDeclaration) {
    for (const member of node.members) {
      const memberNameNode = member.name;
      const isStatic = hasSyntacticModifier(member, ModifierFlags.Static);
      if (isStatic && memberNameNode) {
        const memberName = getPropertyNameForPropertyNameNode(memberNameNode);
        switch (memberName) {
          case 'name':
          case 'length':
          case 'caller':
          case 'arguments':
          case 'prototype':
            const message = qd.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;
            const className = getNameOfSymbolAsWritten(getSymbolOfNode(node));
            error(memberNameNode, message, memberName, className);
            break;
        }
      }
    }
  }
  function checkObjectTypeForDuplicateDeclarations(node: TypeLiteralNode | InterfaceDeclaration) {
    const names = new qb.QMap<boolean>();
    for (const member of node.members) {
      if (member.kind === Syntax.PropertySignature) {
        let memberName: string;
        const name = member.name!;
        switch (name.kind) {
          case Syntax.StringLiteral:
          case Syntax.NumericLiteral:
            memberName = name.text;
            break;
          case Syntax.Identifier:
            memberName = idText(name);
            break;
          default:
            continue;
        }
        if (names.get(memberName)) {
          error(getNameOfDeclaration(member.symbol.valueDeclaration), qd.Duplicate_identifier_0, memberName);
          error(member.name, qd.Duplicate_identifier_0, memberName);
        } else {
          names.set(memberName, true);
        }
      }
    }
  }
  function checkTypeForDuplicateIndexSignatures(node: Node) {
    if (node.kind === Syntax.InterfaceDeclaration) {
      const nodeSymbol = getSymbolOfNode(node as InterfaceDeclaration);
      if (nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) return;
    }
    const indexSymbol = getIndexSymbol(getSymbolOfNode(node)!);
    if (indexSymbol) {
      let seenNumericIndexer = false;
      let seenStringIndexer = false;
      for (const decl of indexSymbol.declarations) {
        const declaration = <SignatureDeclaration>decl;
        if (declaration.parameters.length === 1 && declaration.parameters[0].type) {
          switch (declaration.parameters[0].type.kind) {
            case Syntax.StringKeyword:
              if (!seenStringIndexer) seenStringIndexer = true;
              else {
                error(declaration, qd.Duplicate_string_index_signature);
              }
              break;
            case Syntax.NumberKeyword:
              if (!seenNumericIndexer) seenNumericIndexer = true;
              else {
                error(declaration, qd.Duplicate_number_index_signature);
              }
              break;
          }
        }
      }
    }
  }
  function checkPropertyDeclaration(node: PropertyDeclaration | PropertySignature) {
    if (!checkGrammarDecoratorsAndModifiers(node) && !checkGrammarProperty(node)) checkGrammarComputedPropertyName(node.name);
    checkVariableLikeDeclaration(node);
    if (qc.is.kind(PrivateIdentifier, node.name) && languageVersion < ScriptTarget.ESNext) {
      for (let lexicalScope = qc.get.enclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = qc.get.enclosingBlockScopeContainer(lexicalScope)) {
        getNodeLinks(lexicalScope).flags |= NodeCheckFlags.ContainsClassWithPrivateIdentifiers;
      }
    }
  }
  function checkPropertySignature(node: PropertySignature) {
    if (qc.is.kind(PrivateIdentifier, node.name)) error(node, qd.Private_identifiers_are_not_allowed_outside_class_bodies);
    return checkPropertyDeclaration(node);
  }
  function checkMethodDeclaration(node: MethodDeclaration | MethodSignature) {
    if (!checkGrammarMethod(node)) checkGrammarComputedPropertyName(node.name);
    if (qc.is.kind(PrivateIdentifier, node.name)) error(node, qd.A_method_cannot_be_named_with_a_private_identifier);
    checkFunctionOrMethodDeclaration(node);
    if (hasSyntacticModifier(node, ModifierFlags.Abstract) && node.kind === Syntax.MethodDeclaration && node.body)
      error(node, qd.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, declarationNameToString(node.name));
  }
  function checkConstructorDeclaration(node: ConstructorDeclaration) {
    checkSignatureDeclaration(node);
    if (!checkGrammarConstructorTypeParameters(node)) checkGrammarConstructorTypeAnnotation(node);
    checkSourceElement(node.body);
    const symbol = getSymbolOfNode(node);
    const firstDeclaration = getDeclarationOfKind(symbol, node.kind);
    if (node === firstDeclaration) checkFunctionOrConstructorSymbol(symbol);
    if (qc.is.missing(node.body)) return;
    if (!produceDiagnostics) return;
    function isInstancePropertyWithInitializerOrPrivateIdentifierProperty(n: Node) {
      if (n.isPrivateIdentifierPropertyDeclaration()) return true;
      return n.kind === Syntax.PropertyDeclaration && !hasSyntacticModifier(n, ModifierFlags.Static) && !!(<PropertyDeclaration>n).initializer;
    }
    const containingClassDecl = <ClassDeclaration>node.parent;
    if (getClassExtendsHeritageElement(containingClassDecl)) {
      captureLexicalThis(node.parent, containingClassDecl);
      const classExtendsNull = classDeclarationExtendsNull(containingClassDecl);
      const superCall = findFirstSuperCall(node.body!);
      if (superCall) {
        if (classExtendsNull) error(superCall, qd.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null);
        const superCallShouldBeFirst =
          (compilerOptions.target !== ScriptTarget.ESNext || !compilerOptions.useDefineForClassFields) &&
          (some((<ClassDeclaration>node.parent).members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) ||
            some(node.parameters, (p) => hasSyntacticModifier(p, ModifierFlags.ParameterPropertyModifier)));
        if (superCallShouldBeFirst) {
          const statements = node.body!.statements;
          let superCallStatement: ExpressionStatement | undefined;
          for (const statement of statements) {
            if (statement.kind === Syntax.ExpressionStatement && qc.is.superCall((<ExpressionStatement>statement).expression)) {
              superCallStatement = <ExpressionStatement>statement;
              break;
            }
            if (!qc.is.prologueDirective(statement)) break;
          }
          if (!superCallStatement) error(node, qd.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_parameter_properties_or_private_identifiers);
        }
      } else if (!classExtendsNull) {
        error(node, qd.Constructors_for_derived_classes_must_contain_a_super_call);
      }
    }
  }
  function checkAccessorDeclaration(node: AccessorDeclaration) {
    if (produceDiagnostics) {
      if (!checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node)) checkGrammarComputedPropertyName(node.name);
      checkDecorators(node);
      checkSignatureDeclaration(node);
      if (node.kind === Syntax.GetAccessor) {
        if (!(node.flags & NodeFlags.Ambient) && qc.is.present(node.body) && node.flags & NodeFlags.HasImplicitReturn) {
          if (!(node.flags & NodeFlags.HasExplicitReturn)) error(node.name, qd.A_get_accessor_must_return_a_value);
        }
      }
      if (node.name.kind === Syntax.ComputedPropertyName) checkComputedPropertyName(node.name);
      if (qc.is.kind(PrivateIdentifier, node.name)) error(node.name, qd.An_accessor_cannot_be_named_with_a_private_identifier);
      if (!hasNonBindableDynamicName(node)) {
        const otherKind = node.kind === Syntax.GetAccessor ? Syntax.SetAccessor : Syntax.GetAccessor;
        const otherAccessor = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfNode(node), otherKind);
        if (otherAccessor) {
          const nodeFlags = getEffectiveModifierFlags(node);
          const otherFlags = getEffectiveModifierFlags(otherAccessor);
          if ((nodeFlags & ModifierFlags.AccessibilityModifier) !== (otherFlags & ModifierFlags.AccessibilityModifier)) error(node.name, qd.Getter_and_setter_accessors_do_not_agree_in_visibility);
          if ((nodeFlags & ModifierFlags.Abstract) !== (otherFlags & ModifierFlags.Abstract)) error(node.name, qd.Accessors_must_both_be_abstract_or_non_abstract);
          checkAccessorDeclarationTypesIdentical(node, otherAccessor, getAnnotatedAccessorType, qd.get_and_set_accessor_must_have_the_same_type);
          checkAccessorDeclarationTypesIdentical(node, otherAccessor, getThisTypeOfDeclaration, qd.get_and_set_accessor_must_have_the_same_this_type);
        }
      }
      const returnType = getTypeOfAccessors(getSymbolOfNode(node));
      if (node.kind === Syntax.GetAccessor) checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
    }
    checkSourceElement(node.body);
  }
  function checkAccessorDeclarationTypesIdentical(first: AccessorDeclaration, second: AccessorDeclaration, getAnnotatedType: (a: AccessorDeclaration) => Type | undefined, message: DiagnosticMessage) {
    const firstType = getAnnotatedType(first);
    const secondType = getAnnotatedType(second);
    if (firstType && secondType && !isTypeIdenticalTo(firstType, secondType)) error(first, message);
  }
  function checkMissingDeclaration(node: Node) {
    checkDecorators(node);
  }
  function getEffectiveTypeArguments(node: TypeReferenceNode | ExpressionWithTypeArguments, typeParameters: readonly TypeParameter[]): Type[] {
    return fillMissingTypeArguments(map(node.typeArguments!, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node));
  }
  function checkTypeArgumentConstraints(node: TypeReferenceNode | ExpressionWithTypeArguments, typeParameters: readonly TypeParameter[]): boolean {
    let typeArguments: Type[] | undefined;
    let mapper: TypeMapper | undefined;
    let result = true;
    for (let i = 0; i < typeParameters.length; i++) {
      const constraint = getConstraintOfTypeParameter(typeParameters[i]);
      if (constraint) {
        if (!typeArguments) {
          typeArguments = getEffectiveTypeArguments(node, typeParameters);
          mapper = createTypeMapper(typeParameters, typeArguments);
        }
        result = result && checkTypeAssignableTo(typeArguments[i], instantiateType(constraint, mapper), node.typeArguments![i], qd.Type_0_does_not_satisfy_the_constraint_1);
      }
    }
    return result;
  }
  function getTypeParametersForTypeReference(node: TypeReferenceNode | ExpressionWithTypeArguments) {
    const type = getTypeFromTypeReference(node);
    if (type !== errorType) {
      const symbol = getNodeLinks(node).resolvedSymbol;
      if (symbol) {
        return (
          (symbol.flags & SymbolFlags.TypeAlias && s.getLinks(symbol).typeParameters) || (getObjectFlags(type) & ObjectFlags.Reference ? (<TypeReference>type).target.localTypeParameters : undefined)
        );
      }
    }
    return;
  }
  function checkTypeReferenceNode(node: TypeReferenceNode | ExpressionWithTypeArguments) {
    checkGrammarTypeArguments(node, node.typeArguments);
    if (node.kind === Syntax.TypeReference && node.typeName.jsdocDotPos !== undefined && !isInJSFile(node) && !isInJSDoc(node))
      grammarErrorAtPos(node, node.typeName.jsdocDotPos, 1, qd.JSDoc_types_can_only_be_used_inside_documentation_comments);
    forEach(node.typeArguments, checkSourceElement);
    const type = getTypeFromTypeReference(node);
    if (type !== errorType) {
      if (node.typeArguments && produceDiagnostics) {
        const typeParameters = getTypeParametersForTypeReference(node);
        if (typeParameters) checkTypeArgumentConstraints(node, typeParameters);
      }
      if (type.flags & TypeFlags.Enum && getNodeLinks(node).resolvedSymbol!.flags & SymbolFlags.EnumMember)
        error(node, qd.Enum_type_0_has_members_with_initializers_that_are_not_literals, typeToString(type));
    }
  }
  function getTypeArgumentConstraint(node: TypeNode): Type | undefined {
    const typeReferenceNode = tryCast(node.parent, isTypeReferenceType);
    if (!typeReferenceNode) return;
    const typeParameters = getTypeParametersForTypeReference(typeReferenceNode)!;
    const constraint = getConstraintOfTypeParameter(typeParameters[typeReferenceNode.typeArguments!.indexOf(node)]);
    return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters)));
  }
  function checkTypeQuery(node: TypeQueryNode) {
    getTypeFromTypeQueryNode(node);
  }
  function checkTypeLiteral(node: TypeLiteralNode) {
    forEach(node.members, checkSourceElement);
    if (produceDiagnostics) {
      const type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
      checkIndexConstraints(type);
      checkTypeForDuplicateIndexSignatures(node);
      checkObjectTypeForDuplicateDeclarations(node);
    }
  }
  function checkArrayType(node: ArrayTypeNode) {
    checkSourceElement(node.elementType);
  }
  function checkTupleType(node: TupleTypeNode) {
    const elementTypes = node.elements;
    let seenOptionalElement = false;
    let seenNamedElement = false;
    for (let i = 0; i < elementTypes.length; i++) {
      const e = elementTypes[i];
      if (e.kind === Syntax.NamedTupleMember) seenNamedElement = true;
      else if (seenNamedElement) {
        grammarErrorOnNode(e, qd.Tuple_members_must_all_have_names_or_all_not_have_names);
        break;
      }
      if (isTupleRestElement(e)) {
        if (i !== elementTypes.length - 1) {
          grammarErrorOnNode(e, qd.A_rest_element_must_be_last_in_a_tuple_type);
          break;
        }
        if (!isArrayType(getTypeFromTypeNode((<RestTypeNode>e).type))) error(e, qd.A_rest_element_type_must_be_an_array_type);
      } else if (isTupleOptionalElement(e)) {
        seenOptionalElement = true;
      } else if (seenOptionalElement) {
        grammarErrorOnNode(e, qd.A_required_element_cannot_follow_an_optional_element);
        break;
      }
    }
    forEach(node.elements, checkSourceElement);
  }
  function checkUnionOrIntersectionType(node: UnionOrIntersectionTypeNode) {
    forEach(node.types, checkSourceElement);
  }
  function checkIndexedAccessIndexType(type: Type, accessNode: IndexedAccessTypeNode | ElementAccessExpression) {
    if (!(type.flags & TypeFlags.IndexedAccess)) return type;
    const objectType = (<IndexedAccessType>type).objectType;
    const indexType = (<IndexedAccessType>type).indexType;
    if (isTypeAssignableTo(indexType, getIndexType(objectType, false))) {
      if (
        accessNode.kind === Syntax.ElementAccessExpression &&
        isAssignmentTarget(accessNode) &&
        getObjectFlags(objectType) & ObjectFlags.Mapped &&
        getMappedTypeModifiers(<MappedType>objectType) & MappedTypeModifiers.IncludeReadonly
      ) {
        error(accessNode, qd.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
      }
      return type;
    }
    const apparentObjectType = getApparentType(objectType);
    if (getIndexInfoOfType(apparentObjectType, IndexKind.Number) && isTypeAssignableToKind(indexType, TypeFlags.NumberLike)) return type;
    if (isGenericObjectType(objectType)) {
      const propertyName = getPropertyNameFromIndex(indexType, accessNode);
      if (propertyName) {
        const propertySymbol = forEachType(apparentObjectType, (t) => getPropertyOfType(t, propertyName));
        if (propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol) & ModifierFlags.NonPublicAccessibilityModifier) {
          error(accessNode, qd.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, syntax.get.unescUnderscores(propertyName));
          return errorType;
        }
      }
    }
    error(accessNode, qd.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType));
    return errorType;
  }
  function checkIndexedAccessType(node: IndexedAccessTypeNode) {
    checkSourceElement(node.objectType);
    checkSourceElement(node.indexType);
    checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node);
  }
  function checkMappedType(node: MappedTypeNode) {
    checkSourceElement(node.typeParameter);
    checkSourceElement(node.type);
    if (!node.type) reportImplicitAny(node, anyType);
    const type = <MappedType>getTypeFromMappedTypeNode(node);
    const constraintType = getConstraintTypeFromMappedType(type);
    checkTypeAssignableTo(constraintType, keyofConstraintType, getEffectiveConstraintOfTypeParameter(node.typeParameter));
  }
  function checkThisType(node: ThisTypeNode) {
    getTypeFromThisNodeTypeNode(node);
  }
  function checkTypeOperator(node: TypeOperatorNode) {
    checkGrammarTypeOperatorNode(node);
    checkSourceElement(node.type);
  }
  function checkConditionalType(node: ConditionalTypeNode) {
    qc.forEach.child(node, checkSourceElement);
  }
  function checkInferType(node: InferTypeNode) {
    if (!Node.findAncestor(node, (n) => n.parent && n.parent.kind === Syntax.ConditionalType && (<ConditionalTypeNode>n.parent).extendsType === n))
      grammarErrorOnNode(node, qd.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type);
    checkSourceElement(node.typeParameter);
    registerForUnusedIdentifiersCheck(node);
  }
  function checkImportType(node: ImportTypeNode) {
    checkSourceElement(node.argument);
    getTypeFromTypeNode(node);
  }
  function checkNamedTupleMember(node: NamedTupleMember) {
    if (node.dot3Token && node.questionToken) grammarErrorOnNode(node, qd.A_tuple_member_cannot_be_both_optional_and_rest);
    if (node.type.kind === Syntax.OptionalType)
      grammarErrorOnNode(node.type, qd.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type);
    if (node.type.kind === Syntax.RestType) grammarErrorOnNode(node.type, qd.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type);
    checkSourceElement(node.type);
    getTypeFromTypeNode(node);
  }
  function isPrivateWithinAmbient(node: Node): boolean {
    return (hasEffectiveModifier(node, ModifierFlags.Private) || node.isPrivateIdentifierPropertyDeclaration()) && !!(node.flags & NodeFlags.Ambient);
  }
  function getEffectiveDeclarationFlags(n: Declaration, flagsToCheck: ModifierFlags): ModifierFlags {
    let flags = getCombinedModifierFlags(n);
    if (n.parent.kind !== Syntax.InterfaceDeclaration && n.parent.kind !== Syntax.ClassDeclaration && n.parent.kind !== Syntax.ClassExpression && n.flags & NodeFlags.Ambient) {
      if (!(flags & ModifierFlags.Ambient) && !(qc.is.kind(ModuleBlock, n.parent) && qc.is.kind(ModuleDeclaration, n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent)))
        flags |= ModifierFlags.Export;
      flags |= ModifierFlags.Ambient;
    }
    return flags & flagsToCheck;
  }
  function checkExportsOnMergedDeclarations(node: Declaration): void {
    if (!produceDiagnostics) return;
    let symbol = node.localSymbol;
    if (!symbol) {
      symbol = getSymbolOfNode(node)!;
      if (!symbol.exportSymbol) return;
    }
    if (getDeclarationOfKind(symbol, node.kind) !== node) return;
    let exportedDeclarationSpaces = DeclarationSpaces.None;
    let nonExportedDeclarationSpaces = DeclarationSpaces.None;
    let defaultExportedDeclarationSpaces = DeclarationSpaces.None;
    for (const d of symbol.declarations) {
      const declarationSpaces = getDeclarationSpaces(d);
      const effectiveDeclarationFlags = getEffectiveDeclarationFlags(d, ModifierFlags.Export | ModifierFlags.Default);
      if (effectiveDeclarationFlags & ModifierFlags.Export) {
        if (effectiveDeclarationFlags & ModifierFlags.Default) defaultExportedDeclarationSpaces |= declarationSpaces;
        else {
          exportedDeclarationSpaces |= declarationSpaces;
        }
      } else {
        nonExportedDeclarationSpaces |= declarationSpaces;
      }
    }
    const nonDefaultExportedDeclarationSpaces = exportedDeclarationSpaces | nonExportedDeclarationSpaces;
    const commonDeclarationSpacesForExportsAndLocals = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
    const commonDeclarationSpacesForDefaultAndNonDefault = defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces;
    if (commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault) {
      for (const d of symbol.declarations) {
        const declarationSpaces = getDeclarationSpaces(d);
        const name = getNameOfDeclaration(d);
        if (declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault)
          error(name, qd.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, declarationNameToString(name));
        else if (declarationSpaces & commonDeclarationSpacesForExportsAndLocals) {
          error(name, qd.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, declarationNameToString(name));
        }
      }
    }
    function getDeclarationSpaces(decl: Declaration): DeclarationSpaces {
      let d = decl as Node;
      switch (d.kind) {
        case Syntax.InterfaceDeclaration:
        case Syntax.TypeAliasDeclaration:
        case Syntax.JSDocTypedefTag:
        case Syntax.JSDocCallbackTag:
        case Syntax.JSDocEnumTag:
          return DeclarationSpaces.ExportType;
        case Syntax.ModuleDeclaration:
          return qc.is.ambientModule(d as ModuleDeclaration) || getModuleInstanceState(d as ModuleDeclaration) !== ModuleInstanceState.NonInstantiated
            ? DeclarationSpaces.ExportNamespace | DeclarationSpaces.ExportValue
            : DeclarationSpaces.ExportNamespace;
        case Syntax.ClassDeclaration:
        case Syntax.EnumDeclaration:
        case Syntax.EnumMember:
          return DeclarationSpaces.ExportType | DeclarationSpaces.ExportValue;
        case Syntax.SourceFile:
          return DeclarationSpaces.ExportType | DeclarationSpaces.ExportValue | DeclarationSpaces.ExportNamespace;
        case Syntax.ExportAssignment:
          if (!isEntityNameExpression((d as ExportAssignment).expression)) return DeclarationSpaces.ExportValue;
          d = (d as ExportAssignment).expression;
        case Syntax.ImportEqualsDeclaration:
        case Syntax.NamespaceImport:
        case Syntax.ImportClause:
          let result = DeclarationSpaces.None;
          const target = resolveAlias(getSymbolOfNode(d)!);
          forEach(target.declarations, (d) => {
            result |= getDeclarationSpaces(d);
          });
          return result;
        case Syntax.VariableDeclaration:
        case Syntax.BindingElement:
        case Syntax.FunctionDeclaration:
        case Syntax.ImportSpecifier:
        case Syntax.Identifier:
          return DeclarationSpaces.ExportValue;
        default:
          return Debug.failBadSyntax(d);
      }
    }
  }
  function getAwaitedTypeOfPromise(type: Type, errorNode?: Node, diagnosticMessage?: DiagnosticMessage, arg0?: string | number): Type | undefined {
    const promisedType = getPromisedTypeOfPromise(type, errorNode);
    return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage, arg0);
  }
  function getPromisedTypeOfPromise(type: Type, errorNode?: Node): Type | undefined {
    if (isTypeAny(type)) return;
    const typeAsPromise = <PromiseOrAwaitableType>type;
    if (typeAsPromise.promisedTypeOfPromise) return typeAsPromise.promisedTypeOfPromise;
    if (isReferenceToType(type, getGlobalPromiseType(false))) return (typeAsPromise.promisedTypeOfPromise = getTypeArguments(<GenericType>type)[0]);
    const thenFunction = getTypeOfPropertyOfType(type, 'then' as __String)!;
    if (isTypeAny(thenFunction)) return;
    const thenSignatures = thenFunction ? getSignaturesOfType(thenFunction, SignatureKind.Call) : empty;
    if (thenSignatures.length === 0) {
      if (errorNode) error(errorNode, qd.A_promise_must_have_a_then_method);
      return;
    }
    const onfulfilledParameterType = getTypeWithFacts(getUnionType(map(thenSignatures, getTypeOfFirstParameterOfSignature)), TypeFacts.NEUndefinedOrNull);
    if (isTypeAny(onfulfilledParameterType)) return;
    const onfulfilledParameterSignatures = getSignaturesOfType(onfulfilledParameterType, SignatureKind.Call);
    if (onfulfilledParameterSignatures.length === 0) {
      if (errorNode) error(errorNode, qd.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback);
      return;
    }
    return (typeAsPromise.promisedTypeOfPromise = getUnionType(map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), UnionReduction.Subtype));
  }
  function checkAwaitedType(type: Type, errorNode: Node, diagnosticMessage: DiagnosticMessage, arg0?: string | number): Type {
    const awaitedType = getAwaitedType(type, errorNode, diagnosticMessage, arg0);
    return awaitedType || errorType;
  }
  function isThenableType(type: Type): boolean {
    const thenFunction = getTypeOfPropertyOfType(type, 'then' as __String);
    return !!thenFunction && getSignaturesOfType(getTypeWithFacts(thenFunction, TypeFacts.NEUndefinedOrNull), SignatureKind.Call).length > 0;
  }
  function getAwaitedType(type: Type, errorNode?: Node, diagnosticMessage?: DiagnosticMessage, arg0?: string | number): Type | undefined {
    if (isTypeAny(type)) return type;
    const typeAsAwaitable = <PromiseOrAwaitableType>type;
    if (typeAsAwaitable.awaitedTypeOfType) return typeAsAwaitable.awaitedTypeOfType;
    return (typeAsAwaitable.awaitedTypeOfType = mapType(type, errorNode ? (constituentType) => getAwaitedTypeWorker(constituentType, errorNode, diagnosticMessage, arg0) : getAwaitedTypeWorker));
  }
  function getAwaitedTypeWorker(type: Type, errorNode?: Node, diagnosticMessage?: DiagnosticMessage, arg0?: string | number): Type | undefined {
    const typeAsAwaitable = <PromiseOrAwaitableType>type;
    if (typeAsAwaitable.awaitedTypeOfType) return typeAsAwaitable.awaitedTypeOfType;
    const promisedType = getPromisedTypeOfPromise(type);
    if (promisedType) {
      if (type.id === promisedType.id || awaitedTypeStack.lastIndexOf(promisedType.id) >= 0) {
        if (errorNode) error(errorNode, qd.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method);
        return;
      }
      awaitedTypeStack.push(type.id);
      const awaitedType = getAwaitedType(promisedType, errorNode, diagnosticMessage, arg0);
      awaitedTypeStack.pop();
      if (!awaitedType) return;
      return (typeAsAwaitable.awaitedTypeOfType = awaitedType);
    }
    if (isThenableType(type)) {
      if (errorNode) {
        if (!diagnosticMessage) return fail();
        error(errorNode, diagnosticMessage, arg0);
      }
      return;
    }
    return (typeAsAwaitable.awaitedTypeOfType = type);
  }
  function checkAsyncFunctionReturnType(node: FunctionLikeDeclaration | MethodSignature, returnTypeNode: TypeNode) {
    const returnType = getTypeFromTypeNode(returnTypeNode);
    if (returnType === errorType) return;
    const globalPromiseType = getGlobalPromiseType(true);
    if (globalPromiseType !== emptyGenericType && !isReferenceToType(returnType, globalPromiseType)) {
      error(returnTypeNode, qd.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, typeToString(getAwaitedType(returnType) || voidType));
      return;
    }
    checkAwaitedType(returnType, node, qd.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
  }
  function checkDecorator(node: Decorator): void {
    const signature = getResolvedSignature(node);
    const returnType = getReturnTypeOfSignature(signature);
    if (returnType.flags & TypeFlags.Any) return;
    let expectedReturnType: Type;
    const headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
    let errorInfo: DiagnosticMessageChain | undefined;
    switch (node.parent.kind) {
      case Syntax.ClassDeclaration:
        const classSymbol = getSymbolOfNode(node.parent);
        const classConstructorType = getTypeOfSymbol(classSymbol);
        expectedReturnType = getUnionType([classConstructorType, voidType]);
        break;
      case Syntax.Parameter:
        expectedReturnType = voidType;
        errorInfo = chainDiagnosticMessages(undefined, qd.The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any);
        break;
      case Syntax.PropertyDeclaration:
        expectedReturnType = voidType;
        errorInfo = chainDiagnosticMessages(undefined, qd.The_return_type_of_a_property_decorator_function_must_be_either_void_or_any);
        break;
      case Syntax.MethodDeclaration:
      case Syntax.GetAccessor:
      case Syntax.SetAccessor:
        const methodType = getTypeOfNode(node.parent);
        const descriptorType = createTypedPropertyDescriptorType(methodType);
        expectedReturnType = getUnionType([descriptorType, voidType]);
        break;
      default:
        return fail();
    }
    checkTypeAssignableTo(returnType, expectedReturnType, node, headMessage, () => errorInfo);
  }
  function markTypeNodeAsReferenced(node: TypeNode) {
    markEntityNameOrEntityExpressionAsReference(node && getEntityNameFromTypeNode(node));
  }
  function markEntityNameOrEntityExpressionAsReference(typeName: EntityNameOrEntityNameExpression | undefined) {
    if (!typeName) return;
    const rootName = getFirstIdentifier(typeName);
    const meaning = (typeName.kind === Syntax.Identifier ? SymbolFlags.Type : SymbolFlags.Namespace) | SymbolFlags.Alias;
    const rootSymbol = resolveName(rootName, rootName.escapedText, meaning, undefined, undefined, true);
    if (rootSymbol && rootSymbol.flags & SymbolFlags.Alias && symbolIsValue(rootSymbol) && !isConstEnumOrConstEnumOnlyModule(rootSymbol.resolveAlias()) && !rootSymbol.getTypeOnlyAliasDeclaration())
      rootSymbol.markAliasSymbolAsReferenced();
  }
  function markDecoratorMedataDataTypeNodeAsReferenced(node: TypeNode | undefined): void {
    const entityName = getEntityNameForDecoratorMetadata(node);
    if (entityName && qc.is.entityName(entityName)) markEntityNameOrEntityExpressionAsReference(entityName);
  }
  function getEntityNameForDecoratorMetadata(node: TypeNode | undefined): EntityName | undefined {
    if (node) {
      switch (node.kind) {
        case Syntax.IntersectionType:
        case Syntax.UnionType:
          return getEntityNameForDecoratorMetadataFromTypeList((<UnionOrIntersectionTypeNode>node).types);
        case Syntax.ConditionalType:
          return getEntityNameForDecoratorMetadataFromTypeList([(<ConditionalTypeNode>node).trueType, (<ConditionalTypeNode>node).falseType]);
        case Syntax.ParenthesizedType:
        case Syntax.NamedTupleMember:
          return getEntityNameForDecoratorMetadata((<ParenthesizedTypeNode>node).type);
        case Syntax.TypeReference:
          return (<TypeReferenceNode>node).typeName;
      }
    }
  }
  function getEntityNameForDecoratorMetadataFromTypeList(types: readonly TypeNode[]): EntityName | undefined {
    let commonEntityName: EntityName | undefined;
    for (let typeNode of types) {
      while (typeNode.kind === Syntax.ParenthesizedType || typeNode.kind === Syntax.NamedTupleMember) {
        typeNode = (typeNode as ParenthesizedTypeNode | NamedTupleMember).type;
      }
      if (typeNode.kind === Syntax.NeverKeyword) continue;
      if (!strictNullChecks && (typeNode.kind === Syntax.NullKeyword || typeNode.kind === Syntax.UndefinedKeyword)) continue;
      const individualEntityName = getEntityNameForDecoratorMetadata(typeNode);
      if (!individualEntityName) return;
      if (commonEntityName) {
        if (!qc.is.kind(Identifier, commonEntityName) || !qc.is.kind(Identifier, individualEntityName) || commonEntityName.escapedText !== individualEntityName.escapedText) return;
      } else {
        commonEntityName = individualEntityName;
      }
    }
    return commonEntityName;
  }
  function getParameterTypeNodeForDecoratorCheck(node: ParameterDeclaration): TypeNode | undefined {
    const typeNode = getEffectiveTypeAnnotationNode(node);
    return isRestParameter(node) ? getRestParameterElementType(typeNode) : typeNode;
  }
  function checkDecorators(node: Node): void {
    if (!node.decorators) return;
    if (!nodeCanBeDecorated(node, node.parent, node.parent.parent)) return;
    if (!compilerOptions.experimentalDecorators) {
      error(
        node,
        qd.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_in_your_tsconfig_or_jsconfig_to_remove_this_warning
      );
    }
    const firstDecorator = node.decorators[0];
    checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Decorate);
    if (node.kind === Syntax.Parameter) checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Param);
    if (compilerOptions.emitDecoratorMetadata) {
      checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpers.Metadata);
      switch (node.kind) {
        case Syntax.ClassDeclaration:
          const constructor = getFirstConstructorWithBody(<ClassDeclaration>node);
          if (constructor) {
            for (const parameter of constructor.parameters) {
              markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
            }
          }
          break;
        case Syntax.GetAccessor:
        case Syntax.SetAccessor:
          const otherKind = node.kind === Syntax.GetAccessor ? Syntax.SetAccessor : Syntax.GetAccessor;
          const otherAccessor = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfNode(node as AccessorDeclaration), otherKind);
          markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node as AccessorDeclaration) || (otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor)));
          break;
        case Syntax.MethodDeclaration:
          for (const parameter of (<FunctionLikeDeclaration>node).parameters) {
            markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
          }
          markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(<FunctionLikeDeclaration>node));
          break;
        case Syntax.PropertyDeclaration:
          markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(<ParameterDeclaration>node));
          break;
        case Syntax.Parameter:
          markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(<ParameterDeclaration>node));
          const containingSignature = (node as ParameterDeclaration).parent;
          for (const parameter of containingSignature.parameters) {
            markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
          }
          break;
      }
    }
    forEach(node.decorators, checkDecorator);
  }
  function checkFunctionDeclaration(node: FunctionDeclaration): void {
    if (produceDiagnostics) {
      checkFunctionOrMethodDeclaration(node);
      checkGrammarForGenerator(node);
      checkCollisionWithRequireExportsInGeneratedCode(node, node.name!);
      checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name!);
    }
  }
  function checkJSDocTypeAliasTag(node: JSDocTypedefTag | JSDocCallbackTag) {
    if (!node.typeExpression) error(node.name, qd.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags);
    if (node.name) checkTypeNameIsReserved(node.name, qd.Type_alias_name_cannot_be_0);
    checkSourceElement(node.typeExpression);
  }
  function checkJSDocTemplateTag(node: JSDocTemplateTag): void {
    checkSourceElement(node.constraint);
    for (const tp of node.typeParameters) {
      checkSourceElement(tp);
    }
  }
  function checkJSDocTypeTag(node: JSDocTypeTag) {
    checkSourceElement(node.typeExpression);
  }
  function checkJSDocParameterTag(node: JSDocParameterTag) {
    checkSourceElement(node.typeExpression);
    if (!getParameterSymbolFromJSDoc(node)) {
      const decl = getHostSignatureFromJSDoc(node);
      if (decl) {
        const i = qc.getDoc.tags(decl).filter(isJSDocParameterTag).indexOf(node);
        if (i > -1 && i < decl.parameters.length && qc.is.kind(BindingPattern, decl.parameters[i].name)) return;
        if (!containsArgumentsReference(decl)) {
          if (qc.is.kind(QualifiedName, node.name))
            error(node.name, qd.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(node.name), entityNameToString(node.name.left));
          else {
            error(node.name, qd.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(node.name));
          }
        } else if (findLast(qc.getDoc.tags(decl), isJSDocParameterTag) === node && node.typeExpression && node.typeExpression.type && !isArrayType(getTypeFromTypeNode(node.typeExpression.type))) {
          error(
            node.name,
            qd.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type,
            idText(node.name.kind === Syntax.QualifiedName ? node.name.right : node.name)
          );
        }
      }
    }
  }
  function checkJSDocPropertyTag(node: JSDocPropertyTag) {
    checkSourceElement(node.typeExpression);
  }
  function checkJSDocFunctionType(node: JSDocFunctionType): void {
    if (produceDiagnostics && !node.type && !qc.isDoc.constructSignature(node)) reportImplicitAny(node, anyType);
    checkSignatureDeclaration(node);
  }
  function checkJSDocImplementsTag(node: JSDocImplementsTag): void {
    const classLike = getEffectiveJSDocHost(node);
    if (!classLike || (!qc.is.kind(ClassDeclaration, classLike) && !qc.is.kind(ClassExpression, classLike))) error(classLike, qd.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName));
  }
  function checkJSDocAugmentsTag(node: JSDocAugmentsTag): void {
    const classLike = getEffectiveJSDocHost(node);
    if (!classLike || (!qc.is.kind(ClassDeclaration, classLike) && !qc.is.kind(ClassExpression, classLike))) {
      error(classLike, qd.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName));
      return;
    }
    const augmentsTags = qc.getDoc.tags(classLike).filter(isJSDocAugmentsTag);
    assert(augmentsTags.length > 0);
    if (augmentsTags.length > 1) error(augmentsTags[1], qd.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag);
    const name = getIdentifierFromEntityNameExpression(node.class.expression);
    const extend = getClassExtendsHeritageElement(classLike);
    if (extend) {
      const className = getIdentifierFromEntityNameExpression(extend.expression);
      if (className && name.escapedText !== className.escapedText) error(name, qd.JSDoc_0_1_does_not_match_the_extends_2_clause, idText(node.tagName), idText(name), idText(className));
    }
  }
  function getIdentifierFromEntityNameExpression(node: Identifier | PropertyAccessExpression): Identifier | PrivateIdentifier;
  function getIdentifierFromEntityNameExpression(node: Expression): Identifier | PrivateIdentifier | undefined;
  function getIdentifierFromEntityNameExpression(node: Expression): Identifier | PrivateIdentifier | undefined {
    switch (node.kind) {
      case Syntax.Identifier:
        return node as Identifier;
      case Syntax.PropertyAccessExpression:
        return (node as PropertyAccessExpression).name;
      default:
        return;
    }
  }
  function checkFunctionOrMethodDeclaration(node: FunctionDeclaration | MethodDeclaration | MethodSignature): void {
    checkDecorators(node);
    checkSignatureDeclaration(node);
    const functionFlags = getFunctionFlags(node);
    if (node.name && node.name.kind === Syntax.ComputedPropertyName) checkComputedPropertyName(node.name);
    if (!hasNonBindableDynamicName(node)) {
      const symbol = getSymbolOfNode(node);
      const localSymbol = node.localSymbol || symbol;
      const firstDeclaration = find(localSymbol.declarations, (declaration) => declaration.kind === node.kind && !(declaration.flags & NodeFlags.JavaScriptFile));
      if (node === firstDeclaration) checkFunctionOrConstructorSymbol(localSymbol);
      if (symbol.parent) {
        if (getDeclarationOfKind(symbol, node.kind) === node) checkFunctionOrConstructorSymbol(symbol);
      }
    }
    const body = node.kind === Syntax.MethodSignature ? undefined : node.body;
    checkSourceElement(body);
    checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node));
    if (produceDiagnostics && !getEffectiveReturnTypeNode(node)) {
      if (qc.is.missing(body) && !isPrivateWithinAmbient(node)) reportImplicitAny(node, anyType);
      if (functionFlags & FunctionFlags.Generator && qc.is.present(body)) getReturnTypeOfSignature(getSignatureFromDeclaration(node));
    }
    if (isInJSFile(node)) {
      const typeTag = qc.getDoc.typeTag(node);
      if (typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node))
        error(typeTag, qd.The_type_of_a_function_declaration_must_match_the_function_s_signature);
    }
  }
  function registerForUnusedIdentifiersCheck(node: PotentiallyUnusedIdentifier): void {
    if (produceDiagnostics) {
      const sourceFile = qc.get.sourceFileOf(node);
      let potentiallyUnusedIdentifiers = allPotentiallyUnusedIdentifiers.get(sourceFile.path);
      if (!potentiallyUnusedIdentifiers) {
        potentiallyUnusedIdentifiers = [];
        allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers);
      }
      potentiallyUnusedIdentifiers.push(node);
    }
  }
  type PotentiallyUnusedIdentifier =
    | SourceFile
    | ModuleDeclaration
    | ClassLikeDeclaration
    | InterfaceDeclaration
    | Block
    | CaseBlock
    | ForStatement
    | ForInStatement
    | ForOfStatement
    | Exclude<SignatureDeclaration, IndexSignatureDeclaration | JSDocFunctionType>
    | TypeAliasDeclaration
    | InferTypeNode;
  function checkUnusedIdentifiers(potentiallyUnusedIdentifiers: readonly PotentiallyUnusedIdentifier[], addDiagnostic: AddUnusedDiagnostic) {
    for (const node of potentiallyUnusedIdentifiers) {
      switch (node.kind) {
        case Syntax.ClassDeclaration:
        case Syntax.ClassExpression:
          checkUnusedClassMembers(node, addDiagnostic);
          checkUnusedTypeParameters(node, addDiagnostic);
          break;
        case Syntax.SourceFile:
        case Syntax.ModuleDeclaration:
        case Syntax.Block:
        case Syntax.CaseBlock:
        case Syntax.ForStatement:
        case Syntax.ForInStatement:
        case Syntax.ForOfStatement:
          checkUnusedLocalsAndParameters(node, addDiagnostic);
          break;
        case Syntax.Constructor:
        case Syntax.FunctionExpression:
        case Syntax.FunctionDeclaration:
        case Syntax.ArrowFunction:
        case Syntax.MethodDeclaration:
        case Syntax.GetAccessor:
        case Syntax.SetAccessor:
          if (node.body) checkUnusedLocalsAndParameters(node, addDiagnostic);
          checkUnusedTypeParameters(node, addDiagnostic);
          break;
        case Syntax.MethodSignature:
        case Syntax.CallSignature:
        case Syntax.ConstructSignature:
        case Syntax.FunctionType:
        case Syntax.ConstructorType:
        case Syntax.TypeAliasDeclaration:
        case Syntax.InterfaceDeclaration:
          checkUnusedTypeParameters(node, addDiagnostic);
          break;
        case Syntax.InferType:
          checkUnusedInferTypeParameter(node, addDiagnostic);
          break;
        default:
          Debug.assertNever(node, 'Node should not have been registered for unused identifiers check');
      }
    }
  }
  function errorUnusedLocal(declaration: Declaration, name: string, addDiagnostic: AddUnusedDiagnostic) {
    const node = getNameOfDeclaration(declaration) || declaration;
    const message = isTypeDeclaration(declaration) ? qd._0_is_declared_but_never_used : qd._0_is_declared_but_its_value_is_never_read;
    addDiagnostic(declaration, UnusedKind.Local, createDiagnosticForNode(node, message, name));
  }
  function isIdentifierThatStartsWithUnderscore(node: Node) {
    return qc.is.kind(Identifier, node) && idText(node).charCodeAt(0) === Codes._;
  }
  function checkUnusedClassMembers(node: ClassDeclaration | ClassExpression, addDiagnostic: AddUnusedDiagnostic): void {
    for (const member of node.members) {
      switch (member.kind) {
        case Syntax.MethodDeclaration:
        case Syntax.PropertyDeclaration:
        case Syntax.GetAccessor:
        case Syntax.SetAccessor:
          if (member.kind === Syntax.SetAccessor && member.symbol.flags & SymbolFlags.GetAccessor) break;
          const symbol = getSymbolOfNode(member);
          if (
            !symbol.isReferenced &&
            (hasEffectiveModifier(member, ModifierFlags.Private) || (qc.is.namedDeclaration(member) && qc.is.kind(PrivateIdentifier, member.name))) &&
            !(member.flags & NodeFlags.Ambient)
          ) {
            addDiagnostic(member, UnusedKind.Local, createDiagnosticForNode(member.name!, qd._0_is_declared_but_its_value_is_never_read, symbol.symbolToString()));
          }
          break;
        case Syntax.Constructor:
          for (const parameter of (<ConstructorDeclaration>member).parameters) {
            if (!parameter.symbol.isReferenced && hasSyntacticModifier(parameter, ModifierFlags.Private))
              addDiagnostic(parameter, UnusedKind.Local, createDiagnosticForNode(parameter.name, qd.Property_0_is_declared_but_its_value_is_never_read, parameter.symbol.name));
          }
          break;
        case Syntax.IndexSignature:
        case Syntax.SemicolonClassElement:
          break;
        default:
          fail();
      }
    }
  }
  function checkUnusedInferTypeParameter(node: InferTypeNode, addDiagnostic: AddUnusedDiagnostic): void {
    const { typeParameter } = node;
    if (isTypeParameterUnused(typeParameter)) addDiagnostic(node, UnusedKind.Parameter, createDiagnosticForNode(node, qd._0_is_declared_but_its_value_is_never_read, idText(typeParameter.name)));
  }
  function checkUnusedTypeParameters(node: ClassLikeDeclaration | SignatureDeclaration | InterfaceDeclaration | TypeAliasDeclaration, addDiagnostic: AddUnusedDiagnostic): void {
    if (last(getSymbolOfNode(node).declarations) !== node) return;
    const typeParameters = getEffectiveTypeParameterDeclarations(node);
    const seenParentsWithEveryUnused = new NodeSet<DeclarationWithTypeParameterChildren>();
    for (const typeParameter of typeParameters) {
      if (!isTypeParameterUnused(typeParameter)) continue;
      const name = idText(typeParameter.name);
      const { parent } = typeParameter;
      if (parent.kind !== Syntax.InferType && parent.typeParameters!.every(isTypeParameterUnused)) {
        if (seenParentsWithEveryUnused.tryAdd(parent)) {
          const range = qc.is.kind(JSDocTemplateTag, parent) ? rangeOfNode(parent) : rangeOfTypeParameters(parent.typeParameters!);
          const only = parent.typeParameters!.length === 1;
          const message = only ? qd._0_is_declared_but_its_value_is_never_read : qd.All_type_parameters_are_unused;
          const arg0 = only ? name : undefined;
          addDiagnostic(typeParameter, UnusedKind.Parameter, createFileDiagnostic(qc.get.sourceFileOf(parent), range.pos, range.end - range.pos, message, arg0));
        }
      } else {
        addDiagnostic(typeParameter, UnusedKind.Parameter, createDiagnosticForNode(typeParameter, qd._0_is_declared_but_its_value_is_never_read, name));
      }
    }
  }
  function isTypeParameterUnused(typeParameter: TypeParameterDeclaration): boolean {
    return !(getMergedSymbol(typeParameter.symbol).isReferenced! & SymbolFlags.TypeParameter) && !isIdentifierThatStartsWithUnderscore(typeParameter.name);
  }
  function addToGroup<K, V>(map: qb.QMap<string, [K, V[]]>, key: K, value: V, getKey: (key: K) => number | string): void {
    const keyString = String(getKey(key));
    const group = map.get(keyString);
    if (group) group[1].push(value);
    else {
      map.set(keyString, [key, [value]]);
    }
  }
  function tryGetRootParameterDeclaration(node: Node): ParameterDeclaration | undefined {
    return tryCast(getRootDeclaration(node), isParameter);
  }
  function isValidUnusedLocalDeclaration(declaration: Declaration): boolean {
    if (qc.is.kind(BindingElement, declaration) && isIdentifierThatStartsWithUnderscore(declaration.name)) {
      return !!Node.findAncestor(declaration.parent, (ancestor) =>
        qc.is.kind(ArrayBindingPattern, ancestor) || qc.is.kind(VariableDeclaration, ancestor) || qc.is.kind(VariableDeclarationList, ancestor)
          ? false
          : qc.is.kind(ForOfStatement, ancestor)
          ? true
          : 'quit'
      );
    }
    return (
      qc.is.ambientModule(declaration) ||
      (((qc.is.kind(VariableDeclaration, declaration) && qc.is.forInOrOfStatement(declaration.parent.parent)) || isImportedDeclaration(declaration)) &&
        isIdentifierThatStartsWithUnderscore(declaration.name!))
    );
  }
  function checkUnusedLocalsAndParameters(nodeWithLocals: Node, addDiagnostic: AddUnusedDiagnostic): void {
    const unusedImports = new qb.QMap<[ImportClause, ImportedDeclaration[]]>();
    const unusedDestructures = new qb.QMap<[ObjectBindingPattern, BindingElement[]]>();
    const unusedVariables = new qb.QMap<[VariableDeclarationList, VariableDeclaration[]]>();
    nodeWithLocals.locals!.forEach((local) => {
      if (local.flags & SymbolFlags.TypeParameter ? !(local.flags & SymbolFlags.Variable && !(local.isReferenced! & SymbolFlags.Variable)) : local.isReferenced || local.exportSymbol) return;
      for (const declaration of local.declarations) {
        if (isValidUnusedLocalDeclaration(declaration)) continue;
        if (isImportedDeclaration(declaration)) addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId);
        else if (qc.is.kind(BindingElement, declaration) && qc.is.kind(ObjectBindingPattern, declaration.parent)) {
          const lastElement = last(declaration.parent.elements);
          if (declaration === lastElement || !last(declaration.parent.elements).dot3Token) addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
        } else if (qc.is.kind(VariableDeclaration, declaration)) {
          addToGroup(unusedVariables, declaration.parent, declaration, getNodeId);
        } else {
          const parameter = local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration);
          const name = local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration);
          if (parameter && name) {
            if (!qc.is.parameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThsyntax.is.keyword(parameter) && !isIdentifierThatStartsWithUnderscore(name))
              addDiagnostic(parameter, UnusedKind.Parameter, createDiagnosticForNode(name, qd._0_is_declared_but_its_value_is_never_read, local.name));
          } else {
            errorUnusedLocal(declaration, local.name, addDiagnostic);
          }
        }
      }
    });
    unusedImports.forEach(([importClause, unuseds]) => {
      const importDecl = importClause.parent;
      const nDeclarations =
        (importClause.name ? 1 : 0) + (importClause.namedBindings ? (importClause.namedBindings.kind === Syntax.NamespaceImport ? 1 : importClause.namedBindings.elements.length) : 0);
      if (nDeclarations === unuseds.length) {
        addDiagnostic(
          importDecl,
          UnusedKind.Local,
          unuseds.length === 1
            ? createDiagnosticForNode(importDecl, qd._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name!))
            : createDiagnosticForNode(importDecl, qd.All_imports_in_import_declaration_are_unused)
        );
      } else {
        for (const unused of unuseds) errorUnusedLocal(unused, idText(unused.name!), addDiagnostic);
      }
    });
    unusedDestructures.forEach(([bindingPattern, bindingElements]) => {
      const kind = tryGetRootParameterDeclaration(bindingPattern.parent) ? UnusedKind.Parameter : UnusedKind.Local;
      if (bindingPattern.elements.length === bindingElements.length) {
        if (bindingElements.length === 1 && bindingPattern.parent.kind === Syntax.VariableDeclaration && bindingPattern.parent.parent.kind === Syntax.VariableDeclarationList)
          addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId);
        else {
          addDiagnostic(
            bindingPattern,
            kind,
            bindingElements.length === 1
              ? createDiagnosticForNode(bindingPattern, qd._0_is_declared_but_its_value_is_never_read, bindingNameText(first(bindingElements).name))
              : createDiagnosticForNode(bindingPattern, qd.All_destructured_elements_are_unused)
          );
        }
      } else {
        for (const e of bindingElements) {
          addDiagnostic(e, kind, createDiagnosticForNode(e, qd._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)));
        }
      }
    });
    unusedVariables.forEach(([declarationList, declarations]) => {
      if (declarationList.declarations.length === declarations.length) {
        addDiagnostic(
          declarationList,
          UnusedKind.Local,
          declarations.length === 1
            ? createDiagnosticForNode(first(declarations).name, qd._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name))
            : createDiagnosticForNode(declarationList.parent.kind === Syntax.VariableStatement ? declarationList.parent : declarationList, qd.All_variables_are_unused)
        );
      } else {
        for (const decl of declarations) {
          addDiagnostic(decl, UnusedKind.Local, createDiagnosticForNode(decl, qd._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)));
        }
      }
    });
  }
  function bindingNameText(name: BindingName): string {
    switch (name.kind) {
      case Syntax.Identifier:
        return idText(name);
      case Syntax.ArrayBindingPattern:
      case Syntax.ObjectBindingPattern:
        return bindingNameText(cast(first(name.elements), BindingElement.kind).name);
      default:
        return Debug.assertNever(name);
    }
  }
  type ImportedDeclaration = ImportClause | ImportSpecifier | NamespaceImport;
  function isImportedDeclaration(node: Node): node is ImportedDeclaration {
    return node.kind === Syntax.ImportClause || node.kind === Syntax.ImportSpecifier || node.kind === Syntax.NamespaceImport;
  }
  function importClauseFromImported(decl: ImportedDeclaration): ImportClause {
    return decl.kind === Syntax.ImportClause ? decl : decl.kind === Syntax.NamespaceImport ? decl.parent : decl.parent.parent;
  }
  function checkBlock(node: Block) {
    if (node.kind === Syntax.Block) checkGrammarStatementInAmbientContext(node);
    if (qc.is.functionOrModuleBlock(node)) {
      const saveFlowAnalysisDisabled = flowAnalysisDisabled;
      forEach(node.statements, checkSourceElement);
      flowAnalysisDisabled = saveFlowAnalysisDisabled;
    } else {
      forEach(node.statements, checkSourceElement);
    }
    if (node.locals) registerForUnusedIdentifiersCheck(node);
  }
  function checkCollisionWithArgumentsInGeneratedCode(node: SignatureDeclaration) {
    return;
  }
  function needCollisionCheckForIdentifier(node: Node, identifier: Identifier | undefined, name: string): boolean {
    if (!(identifier && identifier.escapedText === name)) return false;
    if (
      node.kind === Syntax.PropertyDeclaration ||
      node.kind === Syntax.PropertySignature ||
      node.kind === Syntax.MethodDeclaration ||
      node.kind === Syntax.MethodSignature ||
      node.kind === Syntax.GetAccessor ||
      node.kind === Syntax.SetAccessor
    ) {
      return false;
    }
    if (node.flags & NodeFlags.Ambient) return false;
    const root = getRootDeclaration(node);
    if (root.kind === Syntax.Parameter && qc.is.missing((<FunctionLikeDeclaration>root.parent).body)) return false;
    return true;
  }
  function checkIfThisIsCapturedInEnclosingScope(node: Node): void {
    Node.findAncestor(node, (current) => {
      if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureThis) {
        const isDeclaration = node.kind !== Syntax.Identifier;
        if (isDeclaration) error(getNameOfDeclaration(<Declaration>node), qd.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
        else {
          error(node, qd.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
        }
        return true;
      }
      return false;
    });
  }
  function checkIfNewTargetIsCapturedInEnclosingScope(node: Node): void {
    Node.findAncestor(node, (current) => {
      if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureNewTarget) {
        const isDeclaration = node.kind !== Syntax.Identifier;
        if (isDeclaration) error(getNameOfDeclaration(<Declaration>node), qd.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference);
        else {
          error(node, qd.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference);
        }
        return true;
      }
      return false;
    });
  }
  function checkWeakMapCollision(node: Node) {
    const enclosingBlockScope = qc.get.enclosingBlockScopeContainer(node);
    if (getNodeCheckFlags(enclosingBlockScope) & NodeCheckFlags.ContainsClassWithPrivateIdentifiers) error(node, qd.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, 'WeakMap');
  }
  function checkCollisionWithRequireExportsInGeneratedCode(node: Node, name: Identifier) {
    if (moduleKind >= ModuleKind.ES2015 || compilerOptions.noEmit) return;
    if (!needCollisionCheckForIdentifier(node, name, 'require') && !needCollisionCheckForIdentifier(node, name, 'exports')) return;
    if (qc.is.kind(ModuleDeclaration, node) && getModuleInstanceState(node) !== ModuleInstanceState.Instantiated) return;
    const parent = getDeclarationContainer(node);
    if (parent.kind === Syntax.SourceFile && isExternalOrCommonJsModule(<SourceFile>parent))
      error(name, qd.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, declarationNameToString(name), declarationNameToString(name));
  }
  function checkCollisionWithGlobalPromiseInGeneratedCode(node: Node, name: Identifier): void {
    return;
  }
  function checkVarDeclaredNamesNotShadowed(node: VariableDeclaration | BindingElement) {
    if ((qc.get.combinedFlagsOf(node) & NodeFlags.BlockScoped) !== 0 || isParameterDeclaration(node)) return;
    if (node.kind === Syntax.VariableDeclaration && !node.initializer) return;
    const symbol = getSymbolOfNode(node);
    if (symbol.flags & SymbolFlags.FunctionScopedVariable) {
      if (!qc.is.kind(Identifier, node.name)) return fail();
      const localDeclarationSymbol = resolveName(node, node.name.escapedText, SymbolFlags.Variable, undefined, undefined, false);
      if (localDeclarationSymbol && localDeclarationSymbol !== symbol && localDeclarationSymbol.flags & SymbolFlags.BlockScopedVariable) {
        if (getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlags.BlockScoped) {
          const varDeclList = getAncestor(localDeclarationSymbol.valueDeclaration, Syntax.VariableDeclarationList)!;
          const container = varDeclList.parent.kind === Syntax.VariableStatement && varDeclList.parent.parent ? varDeclList.parent.parent : undefined;
          const namesShareScope =
            container &&
            ((container.kind === Syntax.Block && qc.is.functionLike(container.parent)) ||
              container.kind === Syntax.ModuleBlock ||
              container.kind === Syntax.ModuleDeclaration ||
              container.kind === Syntax.SourceFile);
          if (!namesShareScope) {
            const name = localDeclarationSymbol.symbolToString();
            error(node, qd.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name);
          }
        }
      }
    }
  }
  function convertAutoToAny(type: Type) {
    return type === autoType ? anyType : type === autoArrayType ? anyArrayType : type;
  }
  function checkVariableLikeDeclaration(node: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement) {
    checkDecorators(node);
    if (!qc.is.kind(BindingElement, node)) checkSourceElement(node.type);
    if (!node.name) return;
    if (node.name.kind === Syntax.ComputedPropertyName) {
      checkComputedPropertyName(node.name);
      if (node.initializer) checkExpressionCached(node.initializer);
    }
    if (node.kind === Syntax.BindingElement) {
      if (node.parent.kind === Syntax.ObjectBindingPattern && languageVersion < ScriptTarget.ESNext) checkExternalEmitHelpers(node, ExternalEmitHelpers.Rest);
      if (node.propertyName && node.propertyName.kind === Syntax.ComputedPropertyName) checkComputedPropertyName(node.propertyName);
      const parent = node.parent.parent;
      const parentType = getTypeForBindingElementParent(parent);
      const name = node.propertyName || node.name;
      if (parentType && !qc.is.kind(BindingPattern, name)) {
        const exprType = getLiteralTypeFromPropertyName(name);
        if (isTypeUsableAsPropertyName(exprType)) {
          const nameText = getPropertyNameFromType(exprType);
          const property = getPropertyOfType(parentType, nameText);
          if (property) {
            markPropertyAsReferenced(property, false);
            checkPropertyAccessibility(parent, !!parent.initializer && parent.initializer.kind === Syntax.SuperKeyword, parentType, property);
          }
        }
      }
    }
    if (qc.is.kind(BindingPattern, node.name)) forEach(node.name.elements, checkSourceElement);
    if (node.initializer && getRootDeclaration(node).kind === Syntax.Parameter && qc.is.missing((qc.get.containingFunction(node) as FunctionLikeDeclaration).body)) {
      error(node, qd.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
      return;
    }
    if (qc.is.kind(BindingPattern, node.name)) {
      const needCheckInitializer = node.initializer && node.parent.parent.kind !== Syntax.ForInStatement;
      const needCheckWidenedType = node.name.elements.length === 0;
      if (needCheckInitializer || needCheckWidenedType) {
        const widenedType = getWidenedTypeForVariableLikeDeclaration(node);
        if (needCheckInitializer) {
          const initializerType = checkExpressionCached(node.initializer!);
          if (strictNullChecks && needCheckWidenedType) checkNonNullNonVoidType(initializerType, node);
          else {
            checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer);
          }
        }
        if (needCheckWidenedType) {
          if (qc.is.kind(ArrayBindingPattern, node.name)) checkIteratedTypeOrElementType(IterationUse.Destructuring, widenedType, undefinedType, node);
          else if (strictNullChecks) {
            checkNonNullNonVoidType(widenedType, node);
          }
        }
      }
      return;
    }
    const symbol = getSymbolOfNode(node);
    const type = convertAutoToAny(this.getTypeOfSymbol());
    if (node === symbol.valueDeclaration) {
      const initializer = getEffectiveInitializer(node);
      if (initializer) {
        const isJSObjectLiteralInitializer =
          isInJSFile(node) && qc.is.kind(ObjectLiteralExpression, initializer) && (initializer.properties.length === 0 || isPrototypeAccess(node.name)) && hasEntries(symbol.exports);
        if (!isJSObjectLiteralInitializer && node.parent.parent.kind !== Syntax.ForInStatement)
          checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(initializer), type, node, initializer, undefined);
      }
      if (symbol.declarations.length > 1) {
        if (some(symbol.declarations, (d) => d !== node && qc.is.variableLike(d) && !areDeclarationFlagsIdentical(d, node)))
          error(node.name, qd.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name));
      }
    } else {
      const declarationType = convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node));
      if (type !== errorType && declarationType !== errorType && !isTypeIdenticalTo(type, declarationType) && !(symbol.flags & SymbolFlags.Assignment))
        errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type, node, declarationType);
      if (node.initializer) checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer, undefined);
      if (!areDeclarationFlagsIdentical(node, symbol.valueDeclaration)) error(node.name, qd.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name));
    }
    if (node.kind !== Syntax.PropertyDeclaration && node.kind !== Syntax.PropertySignature) {
      checkExportsOnMergedDeclarations(node);
      if (node.kind === Syntax.VariableDeclaration || node.kind === Syntax.BindingElement) checkVarDeclaredNamesNotShadowed(node);
      checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
      checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
      if (!compilerOptions.noEmit && languageVersion < ScriptTarget.ESNext && needCollisionCheckForIdentifier(node, node.name, 'WeakMap')) potentialWeakMapCollisions.push(node);
    }
  }
  function errorNextVariableOrPropertyDeclarationMustHaveSameType(firstDeclaration: Declaration | undefined, firstType: Type, nextDeclaration: Declaration, nextType: Type): void {
    const nextDeclarationName = getNameOfDeclaration(nextDeclaration);
    const message =
      nextDeclaration.kind === Syntax.PropertyDeclaration || nextDeclaration.kind === Syntax.PropertySignature
        ? qd.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2
        : qd.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2;
    const declName = declarationNameToString(nextDeclarationName);
    const err = error(nextDeclarationName, message, declName, typeToString(firstType), typeToString(nextType));
    if (firstDeclaration) addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, qd._0_was_also_declared_here, declName));
  }
  function areDeclarationFlagsIdentical(left: Declaration, right: Declaration) {
    if ((left.kind === Syntax.Parameter && right.kind === Syntax.VariableDeclaration) || (left.kind === Syntax.VariableDeclaration && right.kind === Syntax.Parameter)) return true;
    if (hasQuestionToken(left) !== hasQuestionToken(right)) return false;
    const interestingFlags = ModifierFlags.Private | ModifierFlags.Protected | ModifierFlags.Async | ModifierFlags.Abstract | ModifierFlags.Readonly | ModifierFlags.Static;
    return getSelectedEffectiveModifierFlags(left, interestingFlags) === getSelectedEffectiveModifierFlags(right, interestingFlags);
  }
  function checkVariableDeclaration(node: VariableDeclaration) {
    checkGrammarVariableDeclaration(node);
    return checkVariableLikeDeclaration(node);
  }
  function checkBindingElement(node: BindingElement) {
    checkGrammarBindingElement(node);
    return checkVariableLikeDeclaration(node);
  }
  function checkVariableStatement(node: VariableStatement) {
    if (!checkGrammarDecoratorsAndModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList)) checkGrammarForDisallowedLetOrConstStatement(node);
    forEach(node.declarationList.declarations, checkSourceElement);
  }
  function checkExpressionStatement(node: ExpressionStatement) {
    checkGrammarStatementInAmbientContext(node);
    checkExpression(node.expression);
  }
  function checkIfStatement(node: IfStatement) {
    checkGrammarStatementInAmbientContext(node);
    const type = checkTruthinessExpression(node.expression);
    checkTestingKnownTruthyCallableType(node.expression, node.thenStatement, type);
    checkSourceElement(node.thenStatement);
    if (node.thenStatement.kind === Syntax.EmptyStatement) error(node.thenStatement, qd.The_body_of_an_if_statement_cannot_be_the_empty_statement);
    checkSourceElement(node.elseStatement);
  }
  function checkTestingKnownTruthyCallableType(condExpr: Expression, body: Statement | Expression, type: Type) {
    if (!strictNullChecks) return;
    const testedNode = qc.is.kind(Identifier, condExpr) ? condExpr : qc.is.kind(PropertyAccessExpression, condExpr) ? condExpr.name : undefined;
    if (!testedNode) return;
    const possiblyFalsy = getFalsyFlags(type);
    if (possiblyFalsy) return;
    const callSignatures = getSignaturesOfType(type, SignatureKind.Call);
    if (callSignatures.length === 0) return;
    const testedFunctionSymbol = getSymbolAtLocation(testedNode);
    if (!testedFunctionSymbol) return;
    const functionIsUsedInBody = qc.forEach.child(body, function check(childNode): boolean | undefined {
      if (qc.is.kind(Identifier, childNode)) {
        const childSymbol = getSymbolAtLocation(childNode);
        if (childSymbol && childSymbol === testedFunctionSymbol) {
          if (qc.is.kind(Identifier, condExpr)) return true;
          let testedExpression = testedNode.parent;
          let childExpression = childNode.parent;
          while (testedExpression && childExpression) {
            if (
              (qc.is.kind(Identifier, testedExpression) && qc.is.kind(Identifier, childExpression)) ||
              (testedExpression.kind === Syntax.ThisKeyword && childExpression.kind === Syntax.ThisKeyword)
            ) {
              return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);
            }
            if (qc.is.kind(PropertyAccessExpression, testedExpression) && qc.is.kind(PropertyAccessExpression, childExpression)) {
              if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) return false;
              childExpression = childExpression.expression;
              testedExpression = testedExpression.expression;
            }
            return false;
          }
        }
      }
      return qc.forEach.child(childNode, check);
    });
    if (!functionIsUsedInBody) error(condExpr, qd.This_condition_will_always_return_true_since_the_function_is_always_defined_Did_you_mean_to_call_it_instead);
  }
  function checkDoStatement(node: DoStatement) {
    checkGrammarStatementInAmbientContext(node);
    checkSourceElement(node.statement);
    checkTruthinessExpression(node.expression);
  }
  function checkWhileStatement(node: WhileStatement) {
    checkGrammarStatementInAmbientContext(node);
    checkTruthinessExpression(node.expression);
    checkSourceElement(node.statement);
  }
  function checkTruthinessOfType(type: Type, node: Node) {
    if (type.flags & TypeFlags.Void) error(node, qd.An_expression_of_type_void_cannot_be_tested_for_truthiness);
    return type;
  }
  function checkTruthinessExpression(node: Expression, checkMode?: CheckMode) {
    return checkTruthinessOfType(checkExpression(node, checkMode), node);
  }
  function checkForStatement(node: ForStatement) {
    if (!checkGrammarStatementInAmbientContext(node)) {
      if (node.initializer && node.initializer.kind === Syntax.VariableDeclarationList) checkGrammarVariableDeclarationList(<VariableDeclarationList>node.initializer);
    }
    if (node.initializer) {
      if (node.initializer.kind === Syntax.VariableDeclarationList) forEach((<VariableDeclarationList>node.initializer).declarations, checkVariableDeclaration);
      else {
        checkExpression(node.initializer);
      }
    }
    if (node.condition) checkTruthinessExpression(node.condition);
    if (node.incrementor) checkExpression(node.incrementor);
    checkSourceElement(node.statement);
    if (node.locals) registerForUnusedIdentifiersCheck(node);
  }
  function checkForOfStatement(node: ForOfStatement): void {
    checkGrammarForInOrForOfStatement(node);
    if (node.awaitModifier) {
      const functionFlags = getFunctionFlags(qc.get.containingFunction(node));
      if ((functionFlags & (FunctionFlags.Invalid | FunctionFlags.Async)) === FunctionFlags.Async && languageVersion < ScriptTarget.ESNext)
        checkExternalEmitHelpers(node, ExternalEmitHelpers.ForAwaitOfIncludes);
    }
    if (node.initializer.kind === Syntax.VariableDeclarationList) checkForInOrForOfVariableDeclaration(node);
    else {
      const varExpr = node.initializer;
      const iteratedType = checkRightHandSideOfForOf(node);
      if (varExpr.kind === Syntax.ArrayLiteralExpression || varExpr.kind === Syntax.ObjectLiteralExpression) checkDestructuringAssignment(varExpr, iteratedType || errorType);
      else {
        const leftType = checkExpression(varExpr);
        checkReferenceExpression(
          varExpr,
          qd.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access,
          qd.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access
        );
        if (iteratedType) checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression);
      }
    }
    checkSourceElement(node.statement);
    if (node.locals) registerForUnusedIdentifiersCheck(node);
  }
  function checkForInStatement(node: ForInStatement) {
    checkGrammarForInOrForOfStatement(node);
    const rightType = getNonNullableTypeIfNeeded(checkExpression(node.expression));
    if (node.initializer.kind === Syntax.VariableDeclarationList) {
      const variable = (<VariableDeclarationList>node.initializer).declarations[0];
      if (variable && qc.is.kind(BindingPattern, variable.name)) error(variable.name, qd.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
      checkForInOrForOfVariableDeclaration(node);
    } else {
      const varExpr = node.initializer;
      const leftType = checkExpression(varExpr);
      if (varExpr.kind === Syntax.ArrayLiteralExpression || varExpr.kind === Syntax.ObjectLiteralExpression)
        error(varExpr, qd.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
      else if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
        error(varExpr, qd.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
      } else {
        checkReferenceExpression(
          varExpr,
          qd.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access,
          qd.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access
        );
      }
    }
    if (rightType === neverType || !isTypeAssignableToKind(rightType, TypeFlags.NonPrimitive | TypeFlags.InstantiableNonPrimitive))
      error(node.expression, qd.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType));
    checkSourceElement(node.statement);
    if (node.locals) registerForUnusedIdentifiersCheck(node);
  }
  function checkForInOrForOfVariableDeclaration(iterationStatement: ForInOrOfStatement): void {
    const variableDeclarationList = <VariableDeclarationList>iterationStatement.initializer;
    if (variableDeclarationList.declarations.length >= 1) {
      const decl = variableDeclarationList.declarations[0];
      checkVariableDeclaration(decl);
    }
  }
  function checkRightHandSideOfForOf(statement: ForOfStatement): Type {
    const use = statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf;
    return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression);
  }
  function checkIteratedTypeOrElementType(use: IterationUse, inputType: Type, sentType: Type, errorNode: Node | undefined): Type {
    if (isTypeAny(inputType)) return inputType;
    return getIteratedTypeOrElementType(use, inputType, sentType, errorNode, true) || anyType;
  }
  function getIteratedTypeOrElementType(use: IterationUse, inputType: Type, sentType: Type, errorNode: Node | undefined, checkAssignability: boolean): Type | undefined {
    const allowAsyncIterables = (use & IterationUse.AllowsAsyncIterablesFlag) !== 0;
    if (inputType === neverType) {
      reportTypeNotIterableError(errorNode!, inputType, allowAsyncIterables);
      return;
    }
    const uplevelIteration = true;
    const downlevelIteration = !uplevelIteration && compilerOptions.downlevelIteration;
    if (uplevelIteration || downlevelIteration || allowAsyncIterables) {
      const iterationTypes = getIterationTypesOfIterable(inputType, use, uplevelIteration ? errorNode : undefined);
      if (checkAssignability) {
        if (iterationTypes) {
          const diagnostic =
            use & IterationUse.ForOfFlag
              ? qd.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0
              : use & IterationUse.SpreadFlag
              ? qd.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0
              : use & IterationUse.DestructuringFlag
              ? qd.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0
              : use & IterationUse.YieldStarFlag
              ? qd.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0
              : undefined;
          if (diagnostic) checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic);
        }
      }
      if (iterationTypes || uplevelIteration) return iterationTypes && iterationTypes.yieldType;
    }
    let arrayType = inputType;
    let reportedError = false;
    let hasStringConstituent = false;
    if (use & IterationUse.AllowsStringInputFlag) {
      if (arrayType.flags & TypeFlags.Union) {
        const arrayTypes = (<UnionType>inputType).types;
        const filteredTypes = filter(arrayTypes, (t) => !(t.flags & TypeFlags.StringLike));
        if (filteredTypes !== arrayTypes) arrayType = getUnionType(filteredTypes, UnionReduction.Subtype);
      } else if (arrayType.flags & TypeFlags.StringLike) {
        arrayType = neverType;
      }
      hasStringConstituent = arrayType !== inputType;
      if (hasStringConstituent) {
        if (arrayType.flags & TypeFlags.Never) return stringType;
      }
    }
    if (!isArrayLikeType(arrayType)) {
      if (errorNode && !reportedError) {
        const yieldType = getIterationTypeOfIterable(use, IterationTypeKind.Yield, inputType, undefined);
        const [defaultDiagnostic, maybeMissingAwait]: [DiagnosticMessage, boolean] =
          !(use & IterationUse.AllowsStringInputFlag) || hasStringConstituent
            ? downlevelIteration
              ? [qd.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]
              : yieldType
              ? [qd.Type_0_is_not_an_array_type_or_a_string_type_Use_compiler_option_downlevelIteration_to_allow_iterating_of_iterators, false]
              : [qd.Type_0_is_not_an_array_type, true]
            : downlevelIteration
            ? [qd.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]
            : yieldType
            ? [qd.Type_0_is_not_an_array_type_or_a_string_type_Use_compiler_option_downlevelIteration_to_allow_iterating_of_iterators, false]
            : [qd.Type_0_is_not_an_array_type_or_a_string_type, true];
        errorAndMaybeSuggestAwait(errorNode, maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType), defaultDiagnostic, typeToString(arrayType));
      }
      return hasStringConstituent ? stringType : undefined;
    }
    const arrayElementType = getIndexTypeOfType(arrayType, IndexKind.Number);
    if (hasStringConstituent && arrayElementType) {
      if (arrayElementType.flags & TypeFlags.StringLike) return stringType;
      return getUnionType([arrayElementType, stringType], UnionReduction.Subtype);
    }
    return arrayElementType;
  }
  function getIterationTypeOfIterable(use: IterationUse, typeKind: IterationTypeKind, inputType: Type, errorNode: Node | undefined): Type | undefined {
    if (isTypeAny(inputType)) return;
    const iterationTypes = getIterationTypesOfIterable(inputType, use, errorNode);
    return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)];
  }
  function createIterationTypes(yieldType: Type = neverType, returnType: Type = neverType, nextType: Type = unknownType): IterationTypes {
    if (
      yieldType.flags & TypeFlags.Intrinsic &&
      returnType.flags & (TypeFlags.Any | TypeFlags.Never | TypeFlags.Unknown | TypeFlags.Void | TypeFlags.Undefined) &&
      nextType.flags & (TypeFlags.Any | TypeFlags.Never | TypeFlags.Unknown | TypeFlags.Void | TypeFlags.Undefined)
    ) {
      const id = getTypeListId([yieldType, returnType, nextType]);
      let iterationTypes = iterationTypesCache.get(id);
      if (!iterationTypes) {
        iterationTypes = { yieldType, returnType, nextType };
        iterationTypesCache.set(id, iterationTypes);
      }
      return iterationTypes;
    }
    return { yieldType, returnType, nextType };
  }
  function combineIterationTypes(array: (IterationTypes | undefined)[]) {
    let yieldTypes: Type[] | undefined;
    let returnTypes: Type[] | undefined;
    let nextTypes: Type[] | undefined;
    for (const iterationTypes of array) {
      if (iterationTypes === undefined || iterationTypes === noIterationTypes) continue;
      if (iterationTypes === anyIterationTypes) return anyIterationTypes;
      yieldTypes = append(yieldTypes, iterationTypes.yieldType);
      returnTypes = append(returnTypes, iterationTypes.returnType);
      nextTypes = append(nextTypes, iterationTypes.nextType);
    }
    if (yieldTypes || returnTypes || nextTypes)
      return createIterationTypes(yieldTypes && getUnionType(yieldTypes), returnTypes && getUnionType(returnTypes), nextTypes && getIntersectionType(nextTypes));
    return noIterationTypes;
  }
  function getCachedIterationTypes(type: Type, cacheKey: MatchingKeys<IterableOrIteratorType, IterationTypes | undefined>) {
    return (type as IterableOrIteratorType)[cacheKey];
  }
  function setCachedIterationTypes(type: Type, cacheKey: MatchingKeys<IterableOrIteratorType, IterationTypes | undefined>, cachedTypes: IterationTypes) {
    return ((type as IterableOrIteratorType)[cacheKey] = cachedTypes);
  }
  function getIterationTypesOfIterable(type: Type, use: IterationUse, errorNode: Node | undefined) {
    if (isTypeAny(type)) return anyIterationTypes;
    if (!(type.flags & TypeFlags.Union)) {
      const iterationTypes = getIterationTypesOfIterableWorker(type, use, errorNode);
      if (iterationTypes === noIterationTypes) {
        if (errorNode) reportTypeNotIterableError(errorNode, type, !!(use & IterationUse.AllowsAsyncIterablesFlag));
        return;
      }
      return iterationTypes;
    }
    const cacheKey = use & IterationUse.AllowsAsyncIterablesFlag ? 'iterationTypesOfAsyncIterable' : 'iterationTypesOfIterable';
    const cachedTypes = getCachedIterationTypes(type, cacheKey);
    if (cachedTypes) return cachedTypes === noIterationTypes ? undefined : cachedTypes;
    let allIterationTypes: IterationTypes[] | undefined;
    for (const constituent of (type as UnionType).types) {
      const iterationTypes = getIterationTypesOfIterableWorker(constituent, use, errorNode);
      if (iterationTypes === noIterationTypes) {
        if (errorNode) {
          reportTypeNotIterableError(errorNode, type, !!(use & IterationUse.AllowsAsyncIterablesFlag));
          errorNode = undefined;
        }
      } else {
        allIterationTypes = append(allIterationTypes, iterationTypes);
      }
    }
    const iterationTypes = allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes;
    setCachedIterationTypes(type, cacheKey, iterationTypes);
    return iterationTypes === noIterationTypes ? undefined : iterationTypes;
  }
  function getAsyncFromSyncIterationTypes(iterationTypes: IterationTypes, errorNode: Node | undefined) {
    if (iterationTypes === noIterationTypes) return noIterationTypes;
    if (iterationTypes === anyIterationTypes) return anyIterationTypes;
    const { yieldType, returnType, nextType } = iterationTypes;
    return createIterationTypes(getAwaitedType(yieldType, errorNode) || anyType, getAwaitedType(returnType, errorNode) || anyType, nextType);
  }
  function getIterationTypesOfIterableWorker(type: Type, use: IterationUse, errorNode: Node | undefined) {
    if (isTypeAny(type)) return anyIterationTypes;
    if (use & IterationUse.AllowsAsyncIterablesFlag) {
      const iterationTypes = getIterationTypesOfIterableCached(type, asyncIterationTypesResolver) || getIterationTypesOfIterableFast(type, asyncIterationTypesResolver);
      if (iterationTypes) return iterationTypes;
    }
    if (use & IterationUse.AllowsSyncIterablesFlag) {
      const iterationTypes = getIterationTypesOfIterableCached(type, syncIterationTypesResolver) || getIterationTypesOfIterableFast(type, syncIterationTypesResolver);
      if (iterationTypes) {
        if (use & IterationUse.AllowsAsyncIterablesFlag) {
          if (iterationTypes !== noIterationTypes) return setCachedIterationTypes(type, 'iterationTypesOfAsyncIterable', getAsyncFromSyncIterationTypes(iterationTypes, errorNode));
        }
        return iterationTypes;
      }
    }
    if (use & IterationUse.AllowsAsyncIterablesFlag) {
      const iterationTypes = getIterationTypesOfIterableSlow(type, asyncIterationTypesResolver, errorNode);
      if (iterationTypes !== noIterationTypes) return iterationTypes;
    }
    if (use & IterationUse.AllowsSyncIterablesFlag) {
      const iterationTypes = getIterationTypesOfIterableSlow(type, syncIterationTypesResolver, errorNode);
      if (iterationTypes !== noIterationTypes) {
        if (use & IterationUse.AllowsAsyncIterablesFlag)
          return setCachedIterationTypes(type, 'iterationTypesOfAsyncIterable', iterationTypes ? getAsyncFromSyncIterationTypes(iterationTypes, errorNode) : noIterationTypes);
        return iterationTypes;
      }
    }
    return noIterationTypes;
  }
  function getIterationTypesOfIterableCached(type: Type, resolver: IterationTypesResolver) {
    return getCachedIterationTypes(type, resolver.iterableCacheKey);
  }
  function getIterationTypesOfGlobalIterableType(globalType: Type, resolver: IterationTypesResolver) {
    const globalIterationTypes = getIterationTypesOfIterableCached(globalType, resolver) || getIterationTypesOfIterableSlow(globalType, resolver, undefined);
    return globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes;
  }
  function getIterationTypesOfIterableFast(type: Type, resolver: IterationTypesResolver) {
    let globalType: Type;
    if (isReferenceToType(type, (globalType = resolver.getGlobalIterableType(false))) || isReferenceToType(type, (globalType = resolver.getGlobalIterableIteratorType(false)))) {
      const [yieldType] = getTypeArguments(type as GenericType);
      const { returnType, nextType } = getIterationTypesOfGlobalIterableType(globalType, resolver);
      return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(yieldType, returnType, nextType));
    }
    if (isReferenceToType(type, resolver.getGlobalGeneratorType(false))) {
      const [yieldType, returnType, nextType] = getTypeArguments(type as GenericType);
      return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(yieldType, returnType, nextType));
    }
  }
  function getIterationTypesOfIterableSlow(type: Type, resolver: IterationTypesResolver, errorNode: Node | undefined) {
    const method = getPropertyOfType(type, getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName));
    const methodType = method && !(method.flags & SymbolFlags.Optional) ? getTypeOfSymbol(method) : undefined;
    if (isTypeAny(methodType)) return setCachedIterationTypes(type, resolver.iterableCacheKey, anyIterationTypes);
    const signatures = methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : undefined;
    if (!some(signatures)) return setCachedIterationTypes(type, resolver.iterableCacheKey, noIterationTypes);
    const iteratorType = getUnionType(map(signatures, getReturnTypeOfSignature), UnionReduction.Subtype);
    const iterationTypes = getIterationTypesOfIterator(iteratorType, resolver, errorNode) ?? noIterationTypes;
    return setCachedIterationTypes(type, resolver.iterableCacheKey, iterationTypes);
  }
  function reportTypeNotIterableError(errorNode: Node, type: Type, allowAsyncIterables: boolean): void {
    const message = allowAsyncIterables ? qd.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator : qd.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator;
    errorAndMaybeSuggestAwait(errorNode, !!getAwaitedTypeOfPromise(type), message, typeToString(type));
  }
  function getIterationTypesOfIterator(type: Type, resolver: IterationTypesResolver, errorNode: Node | undefined) {
    if (isTypeAny(type)) return anyIterationTypes;
    const iterationTypes = getIterationTypesOfIteratorCached(type, resolver) || getIterationTypesOfIteratorFast(type, resolver) || getIterationTypesOfIteratorSlow(type, resolver, errorNode);
    return iterationTypes === noIterationTypes ? undefined : iterationTypes;
  }
  function getIterationTypesOfIteratorCached(type: Type, resolver: IterationTypesResolver) {
    return getCachedIterationTypes(type, resolver.iteratorCacheKey);
  }
  function getIterationTypesOfIteratorFast(type: Type, resolver: IterationTypesResolver) {
    const globalType = resolver.getGlobalIterableIteratorType(false);
    if (isReferenceToType(type, globalType)) {
      const [yieldType] = getTypeArguments(type as GenericType);
      const globalIterationTypes = getIterationTypesOfIteratorCached(globalType, resolver) || getIterationTypesOfIteratorSlow(globalType, resolver, undefined);
      const { returnType, nextType } = globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes;
      return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
    }
    if (isReferenceToType(type, resolver.getGlobalIteratorType(false)) || isReferenceToType(type, resolver.getGlobalGeneratorType(false))) {
      const [yieldType, returnType, nextType] = getTypeArguments(type as GenericType);
      return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
    }
  }
  function isIteratorResult(type: Type, kind: IterationTypeKind.Yield | IterationTypeKind.Return) {
    const doneType = getTypeOfPropertyOfType(type, 'done' as __String) || falseType;
    return isTypeAssignableTo(kind === IterationTypeKind.Yield ? falseType : trueType, doneType);
  }
  function isYieldIteratorResult(type: Type) {
    return isIteratorResult(type, IterationTypeKind.Yield);
  }
  function isReturnIteratorResult(type: Type) {
    return isIteratorResult(type, IterationTypeKind.Return);
  }
  function getIterationTypesOfIteratorResult(type: Type) {
    if (isTypeAny(type)) return anyIterationTypes;
    const cachedTypes = getCachedIterationTypes(type, 'iterationTypesOfIteratorResult');
    if (cachedTypes) return cachedTypes;
    if (isReferenceToType(type, getGlobalIteratorYieldResultType(false))) {
      const yieldType = getTypeArguments(type as GenericType)[0];
      return setCachedIterationTypes(type, 'iterationTypesOfIteratorResult', createIterationTypes(yieldType, undefined));
    }
    if (isReferenceToType(type, getGlobalIteratorReturnResultType(false))) {
      const returnType = getTypeArguments(type as GenericType)[0];
      return setCachedIterationTypes(type, 'iterationTypesOfIteratorResult', createIterationTypes(undefined));
    }
    const yieldIteratorResult = filterType(type, isYieldIteratorResult);
    const yieldType = yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, 'value' as __String) : undefined;
    const returnIteratorResult = filterType(type, isReturnIteratorResult);
    const returnType = returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, 'value' as __String) : undefined;
    if (!yieldType && !returnType) return setCachedIterationTypes(type, 'iterationTypesOfIteratorResult', noIterationTypes);
    return setCachedIterationTypes(type, 'iterationTypesOfIteratorResult', createIterationTypes(yieldType, returnType || voidType, undefined));
  }
  function getIterationTypesOfMethod(type: Type, resolver: IterationTypesResolver, methodName: 'next' | 'return' | 'throw', errorNode: Node | undefined): IterationTypes | undefined {
    const method = getPropertyOfType(type, methodName as __String);
    if (!method && methodName !== 'next') return;
    const methodType =
      method && !(methodName === 'next' && method.flags & SymbolFlags.Optional)
        ? methodName === 'next'
          ? getTypeOfSymbol(method)
          : getTypeWithFacts(getTypeOfSymbol(method), TypeFacts.NEUndefinedOrNull)
        : undefined;
    if (isTypeAny(methodType)) return methodName === 'next' ? anyIterationTypes : anyIterationTypesExceptNext;
    const methodSignatures = methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : empty;
    if (methodSignatures.length === 0) {
      if (errorNode) {
        const diagnostic = methodName === 'next' ? resolver.mustHaveANextMethodDiagnostic : resolver.mustBeAMethodDiagnostic;
        error(errorNode, diagnostic, methodName);
      }
      return methodName === 'next' ? anyIterationTypes : undefined;
    }
    let methodParameterTypes: Type[] | undefined;
    let methodReturnTypes: Type[] | undefined;
    for (const signature of methodSignatures) {
      if (methodName !== 'throw' && some(signature.parameters)) methodParameterTypes = append(methodParameterTypes, getTypeAtPosition(signature, 0));
      methodReturnTypes = append(methodReturnTypes, getReturnTypeOfSignature(signature));
    }
    let returnTypes: Type[] | undefined;
    let nextType: Type | undefined;
    if (methodName !== 'throw') {
      const methodParameterType = methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType;
      if (methodName === 'next') nextType = methodParameterType;
      else if (methodName === 'return') {
        const resolvedMethodParameterType = resolver.resolveIterationType(methodParameterType, errorNode) || anyType;
        returnTypes = append(returnTypes, resolvedMethodParameterType);
      }
    }
    let yieldType: Type;
    const methodReturnType = methodReturnTypes ? getUnionType(methodReturnTypes, UnionReduction.Subtype) : neverType;
    const resolvedMethodReturnType = resolver.resolveIterationType(methodReturnType, errorNode) || anyType;
    const iterationTypes = getIterationTypesOfIteratorResult(resolvedMethodReturnType);
    if (iterationTypes === noIterationTypes) {
      if (errorNode) error(errorNode, resolver.mustHaveAValueDiagnostic, methodName);
      yieldType = anyType;
      returnTypes = append(returnTypes, anyType);
    } else {
      yieldType = iterationTypes.yieldType;
      returnTypes = append(returnTypes, iterationTypes.returnType);
    }
    return createIterationTypes(yieldType, getUnionType(returnTypes), nextType);
  }
  function getIterationTypesOfIteratorSlow(type: Type, resolver: IterationTypesResolver, errorNode: Node | undefined) {
    const iterationTypes = combineIterationTypes([
      getIterationTypesOfMethod(type, resolver, 'next', errorNode),
      getIterationTypesOfMethod(type, resolver, 'return', errorNode),
      getIterationTypesOfMethod(type, resolver, 'throw', errorNode),
    ]);
    return setCachedIterationTypes(type, resolver.iteratorCacheKey, iterationTypes);
  }
  function getIterationTypeOfGeneratorFunctionReturnType(kind: IterationTypeKind, returnType: Type, isAsyncGenerator: boolean): Type | undefined {
    if (isTypeAny(returnType)) return;
    const iterationTypes = getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator);
    return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)];
  }
  function getIterationTypesOfGeneratorFunctionReturnType(type: Type, isAsyncGenerator: boolean) {
    if (isTypeAny(type)) return anyIterationTypes;
    const use = isAsyncGenerator ? IterationUse.AsyncGeneratorReturnType : IterationUse.GeneratorReturnType;
    const resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
    return getIterationTypesOfIterable(type, use, undefined) || getIterationTypesOfIterator(type, resolver, undefined);
  }
  function checkBreakOrContinueStatement(node: BreakOrContinueStatement) {
    if (!checkGrammarStatementInAmbientContext(node)) checkGrammarBreakOrContinueStatement(node);
  }
  function unwrapReturnType(returnType: Type, functionFlags: FunctionFlags) {
    const isGenerator = !!(functionFlags & FunctionFlags.Generator);
    const isAsync = !!(functionFlags & FunctionFlags.Async);
    return isGenerator ? getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, returnType, isAsync) ?? errorType : isAsync ? getAwaitedType(returnType) ?? errorType : returnType;
  }
  function isUnwrappedReturnTypeVoidOrAny(func: SignatureDeclaration, returnType: Type): boolean {
    const unwrappedReturnType = unwrapReturnType(returnType, getFunctionFlags(func));
    return !!unwrappedReturnType && maybeTypeOfKind(unwrappedReturnType, TypeFlags.Void | TypeFlags.AnyOrUnknown);
  }
  function checkReturnStatement(node: ReturnStatement) {
    if (checkGrammarStatementInAmbientContext(node)) return;
    const func = qc.get.containingFunction(node);
    if (!func) {
      grammarErrorOnFirstToken(node, qd.A_return_statement_can_only_be_used_within_a_function_body);
      return;
    }
    const signature = getSignatureFromDeclaration(func);
    const returnType = getReturnTypeOfSignature(signature);
    const functionFlags = getFunctionFlags(func);
    if (strictNullChecks || node.expression || returnType.flags & TypeFlags.Never) {
      const exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;
      if (func.kind === Syntax.SetAccessor) {
        if (node.expression) error(node, qd.Setters_cannot_return_a_value);
      } else if (func.kind === Syntax.Constructor) {
        if (node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression))
          error(node, qd.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
      } else if (getReturnTypeFromAnnotation(func)) {
        const unwrappedReturnType = unwrapReturnType(returnType, functionFlags) ?? returnType;
        const unwrappedExprType =
          functionFlags & FunctionFlags.Async
            ? checkAwaitedType(exprType, node, qd.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
            : exprType;
        if (unwrappedReturnType) checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression);
      }
    } else if (func.kind !== Syntax.Constructor && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeVoidOrAny(func, returnType)) {
      error(node, qd.Not_all_code_paths_return_a_value);
    }
  }
  function checkWithStatement(node: WithStatement) {
    if (!checkGrammarStatementInAmbientContext(node)) {
      if (node.flags & NodeFlags.AwaitContext) grammarErrorOnFirstToken(node, qd.with_statements_are_not_allowed_in_an_async_function_block);
    }
    checkExpression(node.expression);
    const sourceFile = qc.get.sourceFileOf(node);
    if (!hasParseDiagnostics(sourceFile)) {
      const start = getSpanOfTokenAtPosition(sourceFile, node.pos).start;
      const end = node.statement.pos;
      grammarErrorAtPos(sourceFile, start, end - start, qd.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any);
    }
  }
  function checkSwitchStatement(node: SwitchStatement) {
    checkGrammarStatementInAmbientContext(node);
    let firstDefaultClause: CaseOrDefaultClause;
    let hasDuplicateDefaultClause = false;
    const expressionType = checkExpression(node.expression);
    const expressionIsLiteral = isLiteralType(expressionType);
    forEach(node.caseBlock.clauses, (clause) => {
      if (clause.kind === Syntax.DefaultClause && !hasDuplicateDefaultClause) {
        if (firstDefaultClause === undefined) firstDefaultClause = clause;
        else {
          grammarErrorOnNode(clause, qd.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
          hasDuplicateDefaultClause = true;
        }
      }
      if (produceDiagnostics && clause.kind === Syntax.CaseClause) {
        let caseType = checkExpression(clause.expression);
        const caseIsLiteral = isLiteralType(caseType);
        let comparedExpressionType = expressionType;
        if (!caseIsLiteral || !expressionIsLiteral) {
          caseType = caseIsLiteral ? getBaseTypeOfLiteralType(caseType) : caseType;
          comparedExpressionType = getBaseTypeOfLiteralType(expressionType);
        }
        if (!isTypeEqualityComparableTo(comparedExpressionType, caseType)) checkTypeComparableTo(caseType, comparedExpressionType, clause.expression, undefined);
      }
      forEach(clause.statements, checkSourceElement);
      if (compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode)) error(clause, qd.Fallthrough_case_in_switch);
    });
    if (node.caseBlock.locals) registerForUnusedIdentifiersCheck(node.caseBlock);
  }
  function checkLabeledStatement(node: LabeledStatement) {
    if (!checkGrammarStatementInAmbientContext(node)) {
      Node.findAncestor(node.parent, (current) => {
        if (qc.is.functionLike(current)) return 'quit';
        if (current.kind === Syntax.LabeledStatement && (<LabeledStatement>current).label.escapedText === node.label.escapedText) {
          grammarErrorOnNode(node.label, qd.Duplicate_label_0, qc.get.textOf(node.label));
          return true;
        }
        return false;
      });
    }
    checkSourceElement(node.statement);
  }
  function checkThrowStatement(node: ThrowStatement) {
    if (!checkGrammarStatementInAmbientContext(node)) {
      if (node.expression === undefined) grammarErrorAfterFirstToken(node, qd.Line_break_not_permitted_here);
    }
    if (node.expression) checkExpression(node.expression);
  }
  function checkTryStatement(node: TryStatement) {
    checkGrammarStatementInAmbientContext(node);
    checkBlock(node.tryBlock);
    const catchClause = node.catchClause;
    if (catchClause) {
      if (catchClause.variableDeclaration) {
        if (catchClause.variableDeclaration.type) grammarErrorOnFirstToken(catchClause.variableDeclaration.type, qd.Catch_clause_variable_cannot_have_a_type_annotation);
        else if (catchClause.variableDeclaration.initializer) {
          grammarErrorOnFirstToken(catchClause.variableDeclaration.initializer, qd.Catch_clause_variable_cannot_have_an_initializer);
        } else {
          const blockLocals = catchClause.block.locals;
          if (blockLocals) {
            forEachKey(catchClause.locals!, (caughtName) => {
              const blockLocal = blockLocals.get(caughtName);
              if (blockLocal && (blockLocal.flags & SymbolFlags.BlockScopedVariable) !== 0)
                grammarErrorOnNode(blockLocal.valueDeclaration, qd.Cannot_redeclare_identifier_0_in_catch_clause, caughtName);
            });
          }
        }
      }
      checkBlock(catchClause.block);
    }
    if (node.finallyBlock) checkBlock(node.finallyBlock);
  }
  function checkIndexConstraints(type: Type) {
    const declaredNumberIndexer = getIndexDeclarationOfSymbol(type.symbol, IndexKind.Number);
    const declaredStringIndexer = getIndexDeclarationOfSymbol(type.symbol, IndexKind.String);
    const stringIndexType = getIndexTypeOfType(type, IndexKind.String);
    const numberIndexType = getIndexTypeOfType(type, IndexKind.Number);
    if (stringIndexType || numberIndexType) {
      forEach(getPropertiesOfObjectType(type), (prop) => {
        const propType = getTypeOfSymbol(prop);
        checkIndexConstraintForProperty(prop, propType, type, declaredStringIndexer, stringIndexType, IndexKind.String);
        checkIndexConstraintForProperty(prop, propType, type, declaredNumberIndexer, numberIndexType, IndexKind.Number);
      });
      const classDeclaration = type.symbol.valueDeclaration;
      if (getObjectFlags(type) & ObjectFlags.Class && qc.is.classLike(classDeclaration)) {
        for (const member of classDeclaration.members) {
          if (!hasSyntacticModifier(member, ModifierFlags.Static) && hasNonBindableDynamicName(member)) {
            const symbol = getSymbolOfNode(member);
            const propType = this.getTypeOfSymbol();
            checkIndexConstraintForProperty(symbol, propType, type, declaredStringIndexer, stringIndexType, IndexKind.String);
            checkIndexConstraintForProperty(symbol, propType, type, declaredNumberIndexer, numberIndexType, IndexKind.Number);
          }
        }
      }
    }
    let errorNode: Node | undefined;
    if (stringIndexType && numberIndexType) {
      errorNode = declaredNumberIndexer || declaredStringIndexer;
      if (!errorNode && getObjectFlags(type) & ObjectFlags.Interface) {
        const someBaseTypeHasBothIndexers = forEach(getBaseTypes(<InterfaceType>type), (base) => getIndexTypeOfType(base, IndexKind.String) && getIndexTypeOfType(base, IndexKind.Number));
        errorNode = someBaseTypeHasBothIndexers ? undefined : type.symbol.declarations[0];
      }
    }
    if (errorNode && !isTypeAssignableTo(numberIndexType!, stringIndexType!))
      error(errorNode, qd.Numeric_index_type_0_is_not_assignable_to_string_index_type_1, typeToString(numberIndexType!), typeToString(stringIndexType!));
    function checkIndexConstraintForProperty(
      prop: Symbol,
      propertyType: Type,
      containingType: Type,
      indexDeclaration: Declaration | undefined,
      indexType: Type | undefined,
      indexKind: IndexKind
    ): void {
      if (!indexType || isKnownSymbol(prop)) return;
      const propDeclaration = prop.valueDeclaration;
      const name = propDeclaration && getNameOfDeclaration(propDeclaration);
      if (name && qc.is.kind(PrivateIdentifier, name)) return;
      if (indexKind === IndexKind.Number && !(name ? isNumericName(name) : NumericLiteral.name(prop.escName))) return;
      let errorNode: Node | undefined;
      if (propDeclaration && name && (propDeclaration.kind === Syntax.BinaryExpression || name.kind === Syntax.ComputedPropertyName || prop.parent === containingType.symbol))
        errorNode = propDeclaration;
      else if (indexDeclaration) {
        errorNode = indexDeclaration;
      } else if (getObjectFlags(containingType) & ObjectFlags.Interface) {
        const someBaseClassHasBothPropertyAndIndexer = forEach(
          getBaseTypes(<InterfaceType>containingType),
          (base) => getPropertyOfObjectType(base, prop.escName) && getIndexTypeOfType(base, indexKind)
        );
        errorNode = someBaseClassHasBothPropertyAndIndexer ? undefined : containingType.symbol.declarations[0];
      }
      if (errorNode && !isTypeAssignableTo(propertyType, indexType)) {
        const errorMessage = indexKind === IndexKind.String ? qd.Property_0_of_type_1_is_not_assignable_to_string_index_type_2 : qd.Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2;
        error(errorNode, errorMessage, prop.symbolToString(), typeToString(propertyType), typeToString(indexType));
      }
    }
  }
  function checkTypeNameIsReserved(name: Identifier, message: DiagnosticMessage): void {
    switch (name.escapedText) {
      case 'any':
      case 'unknown':
      case 'number':
      case 'bigint':
      case 'boolean':
      case 'string':
      case 'symbol':
      case 'void':
      case 'object':
        error(name, message, name.escapedText as string);
    }
  }
  function checkClassNameCollisionWithObject(name: Identifier): void {}
  function checkTypeParameters(typeParameterDeclarations: readonly TypeParameterDeclaration[] | undefined) {
    if (typeParameterDeclarations) {
      let seenDefault = false;
      for (let i = 0; i < typeParameterDeclarations.length; i++) {
        const node = typeParameterDeclarations[i];
        checkTypeParameter(node);
        if (produceDiagnostics) {
          if (node.default) {
            seenDefault = true;
            checkTypeParametersNotReferenced(node.default, typeParameterDeclarations, i);
          } else if (seenDefault) {
            error(node, qd.Required_type_parameters_may_not_follow_optional_type_parameters);
          }
          for (let j = 0; j < i; j++) {
            if (typeParameterDeclarations[j].symbol === node.symbol) error(node.name, qd.Duplicate_identifier_0, declarationNameToString(node.name));
          }
        }
      }
    }
  }
  function checkTypeParametersNotReferenced(root: TypeNode, typeParameters: readonly TypeParameterDeclaration[], index: number) {
    visit(root);
    function visit(node: Node) {
      if (node.kind === Syntax.TypeReference) {
        const type = getTypeFromTypeReference(<TypeReferenceNode>node);
        if (type.flags & TypeFlags.TypeParameter) {
          for (let i = index; i < typeParameters.length; i++) {
            if (type.symbol === getSymbolOfNode(typeParameters[i])) error(node, qd.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);
          }
        }
      }
      qc.forEach.child(node, visit);
    }
  }
  function areTypeParametersIdentical(declarations: readonly (ClassDeclaration | InterfaceDeclaration)[], targetParameters: TypeParameter[]) {
    const maxTypeArgumentCount = length(targetParameters);
    const minTypeArgumentCount = getMinTypeArgumentCount(targetParameters);
    for (const declaration of declarations) {
      const sourceParameters = getEffectiveTypeParameterDeclarations(declaration);
      const numTypeParameters = sourceParameters.length;
      if (numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount) return false;
      for (let i = 0; i < numTypeParameters; i++) {
        const source = sourceParameters[i];
        const target = targetParameters[i];
        if (source.name.escapedText !== target.symbol.escName) return false;
        const constraint = getEffectiveConstraintOfTypeParameter(source);
        const sourceConstraint = constraint && getTypeFromTypeNode(constraint);
        const targetConstraint = getConstraintOfTypeParameter(target);
        if (sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint)) return false;
        const sourceDefault = source.default && getTypeFromTypeNode(source.default);
        const targetDefault = getDefaultFromTypeParameter(target);
        if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) return false;
      }
    }
    return true;
  }
  function checkClassExpression(node: ClassExpression): Type {
    checkClassLikeDeclaration(node);
    checkNodeDeferred(node);
    return getTypeOfSymbol(getSymbolOfNode(node));
  }
  function checkClassExpressionDeferred(node: ClassExpression) {
    forEach(node.members, checkSourceElement);
    registerForUnusedIdentifiersCheck(node);
  }
  function checkClassDeclaration(node: ClassDeclaration) {
    if (!node.name && !hasSyntacticModifier(node, ModifierFlags.Default)) grammarErrorOnFirstToken(node, qd.A_class_declaration_without_the_default_modifier_must_have_a_name);
    checkClassLikeDeclaration(node);
    forEach(node.members, checkSourceElement);
    registerForUnusedIdentifiersCheck(node);
  }
  function checkClassLikeDeclaration(node: ClassLikeDeclaration) {
    checkGrammarClassLikeDeclaration(node);
    checkDecorators(node);
    if (node.name) {
      checkTypeNameIsReserved(node.name, qd.Class_name_cannot_be_0);
      checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
      checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
      if (!(node.flags & NodeFlags.Ambient)) checkClassNameCollisionWithObject(node.name);
    }
    checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
    checkExportsOnMergedDeclarations(node);
    const symbol = getSymbolOfNode(node);
    const type = <InterfaceType>getDeclaredTypeOfSymbol(symbol);
    const typeWithThis = getTypeWithThisArgument(type);
    const staticType = <ObjectType>this.getTypeOfSymbol();
    checkTypeParameterListsIdentical(symbol);
    checkClassForDuplicateDeclarations(node);
    if (!(node.flags & NodeFlags.Ambient)) checkClassForStaticPropertyNameConflicts(node);
    const baseTypeNode = getEffectiveBaseTypeNode(node);
    if (baseTypeNode) {
      forEach(baseTypeNode.typeArguments, checkSourceElement);
      const extendsNode = getClassExtendsHeritageElement(node);
      if (extendsNode && extendsNode !== baseTypeNode) checkExpression(extendsNode.expression);
      const baseTypes = getBaseTypes(type);
      if (baseTypes.length && produceDiagnostics) {
        const baseType = baseTypes[0];
        const baseConstructorType = getBaseConstructorTypeOfClass(type);
        const staticBaseType = getApparentType(baseConstructorType);
        checkBaseTypeAccessibility(staticBaseType, baseTypeNode);
        checkSourceElement(baseTypeNode.expression);
        if (some(baseTypeNode.typeArguments)) {
          forEach(baseTypeNode.typeArguments, checkSourceElement);
          for (const constructor of getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)) {
            if (!checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters!)) break;
          }
        }
        const baseWithThis = getTypeWithThisArgument(baseType, type.thisType);
        if (!checkTypeAssignableTo(typeWithThis, baseWithThis, undefined)) issueMemberSpecificError(node, typeWithThis, baseWithThis, qd.Class_0_incorrectly_extends_base_class_1);
        else {
          checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, qd.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
        }
        if (baseConstructorType.flags & TypeFlags.TypeVariable && !isMixinConstructorType(staticType))
          error(node.name || node, qd.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);
        if (!(staticBaseType.symbol && staticBaseType.symbol.flags & SymbolFlags.Class) && !(baseConstructorType.flags & TypeFlags.TypeVariable)) {
          const constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);
          if (forEach(constructors, (sig) => !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType)))
            error(baseTypeNode.expression, qd.Base_constructors_must_all_have_the_same_return_type);
        }
        checkKindsOfPropertyMemberOverrides(type, baseType);
      }
    }
    const implementedTypeNodes = getEffectiveImplementsTypeNodes(node);
    if (implementedTypeNodes) {
      for (const typeRefNode of implementedTypeNodes) {
        if (!isEntityNameExpression(typeRefNode.expression)) error(typeRefNode.expression, qd.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments);
        checkTypeReferenceNode(typeRefNode);
        if (produceDiagnostics) {
          const t = getReducedType(getTypeFromTypeNode(typeRefNode));
          if (t !== errorType) {
            if (isValidBaseType(t)) {
              const genericDiag =
                t.symbol && t.symbol.flags & SymbolFlags.Class
                  ? qd.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass
                  : qd.Class_0_incorrectly_implements_interface_1;
              const baseWithThis = getTypeWithThisArgument(t, type.thisType);
              if (!checkTypeAssignableTo(typeWithThis, baseWithThis, undefined)) issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag);
            } else {
              error(typeRefNode, qd.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members);
            }
          }
        }
      }
    }
    if (produceDiagnostics) {
      checkIndexConstraints(type);
      checkTypeForDuplicateIndexSignatures(node);
      checkPropertyInitialization(node);
    }
  }
  function issueMemberSpecificError(node: ClassLikeDeclaration, typeWithThis: Type, baseWithThis: Type, broadDiag: DiagnosticMessage) {
    let issuedMemberError = false;
    for (const member of node.members) {
      if (hasStaticModifier(member)) continue;
      const declaredProp = (member.name && getSymbolAtLocation(member.name)) || getSymbolAtLocation(member);
      if (declaredProp) {
        const prop = getPropertyOfType(typeWithThis, declaredProp.escName);
        const baseProp = getPropertyOfType(baseWithThis, declaredProp.escName);
        if (prop && baseProp) {
          const rootChain = () =>
            chainDiagnosticMessages(
              undefined,
              qd.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,
              declaredProp.symbolToString(),
              typeToString(typeWithThis),
              typeToString(baseWithThis)
            );
          if (!checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp), member.name || member, undefined, rootChain)) issuedMemberError = true;
        }
      }
    }
    if (!issuedMemberError) checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag);
  }
  function checkBaseTypeAccessibility(type: Type, node: ExpressionWithTypeArguments) {
    const signatures = getSignaturesOfType(type, SignatureKind.Construct);
    if (signatures.length) {
      const declaration = signatures[0].declaration;
      if (declaration && hasEffectiveModifier(declaration, ModifierFlags.Private)) {
        const typeClassDeclaration = getClassLikeDeclarationOfSymbol(type.symbol)!;
        if (!isNodeWithinClass(node, typeClassDeclaration)) error(node, qd.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type.symbol));
      }
    }
  }
  function checkKindsOfPropertyMemberOverrides(type: InterfaceType, baseType: BaseType): void {
    const baseProperties = getPropertiesOfType(baseType);
    basePropertyCheck: for (const baseProperty of baseProperties) {
      const base = getTargetSymbol(baseProperty);
      if (base.flags & SymbolFlags.Prototype) continue;
      const baseSymbol = getPropertyOfObjectType(type, base.escName);
      if (!baseSymbol) continue;
      const derived = getTargetSymbol(baseSymbol);
      const baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base);
      assert(!!derived, "derived should point to something, even if it is the base class' declaration.");
      if (derived === base) {
        const derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol)!;
        if (baseDeclarationFlags & ModifierFlags.Abstract && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, ModifierFlags.Abstract))) {
          for (const otherBaseType of getBaseTypes(type)) {
            if (otherBaseType === baseType) continue;
            const baseSymbol = getPropertyOfObjectType(otherBaseType, base.escName);
            const derivedElsewhere = baseSymbol && getTargetSymbol(baseSymbol);
            if (derivedElsewhere && derivedElsewhere !== base) continue basePropertyCheck;
          }
          if (derivedClassDecl.kind === Syntax.ClassExpression)
            error(derivedClassDecl, qd.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, baseProperty.symbolToString(), typeToString(baseType));
          else {
            error(derivedClassDecl, qd.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, typeToString(type), baseProperty.symbolToString(), typeToString(baseType));
          }
        }
      } else {
        const derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(derived);
        if (baseDeclarationFlags & ModifierFlags.Private || derivedDeclarationFlags & ModifierFlags.Private) continue;
        let errorMessage: DiagnosticMessage;
        const basePropertyFlags = base.flags & SymbolFlags.PropertyOrAccessor;
        const derivedPropertyFlags = derived.flags & SymbolFlags.PropertyOrAccessor;
        if (basePropertyFlags && derivedPropertyFlags) {
          if (
            (baseDeclarationFlags & ModifierFlags.Abstract && !(base.valueDeclaration && qc.is.kind(PropertyDeclaration, base.valueDeclaration) && base.valueDeclaration.initializer)) ||
            (base.valueDeclaration && base.valueDeclaration.parent.kind === Syntax.InterfaceDeclaration) ||
            (derived.valueDeclaration && qc.is.kind(BinaryExpression, derived.valueDeclaration))
          ) {
            continue;
          }
          const overriddenInstanceProperty = basePropertyFlags !== SymbolFlags.Property && derivedPropertyFlags === SymbolFlags.Property;
          const overriddenInstanceAccessor = basePropertyFlags === SymbolFlags.Property && derivedPropertyFlags !== SymbolFlags.Property;
          if (overriddenInstanceProperty || overriddenInstanceAccessor) {
            const errorMessage = overriddenInstanceProperty
              ? qd._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property
              : qd._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor;
            error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, base.symbolToString(), typeToString(baseType), typeToString(type));
          } else if (compilerOptions.useDefineForClassFields) {
            const uninitialized = find(derived.declarations, (d) => d.kind === Syntax.PropertyDeclaration && !(d as PropertyDeclaration).initializer);
            if (
              uninitialized &&
              !(derived.flags & SymbolFlags.Transient) &&
              !(baseDeclarationFlags & ModifierFlags.Abstract) &&
              !(derivedDeclarationFlags & ModifierFlags.Abstract) &&
              !derived.declarations.some((d) => !!(d.flags & NodeFlags.Ambient))
            ) {
              const constructor = findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type.symbol)!);
              const propName = (uninitialized as PropertyDeclaration).name;
              if (
                (uninitialized as PropertyDeclaration).exclamationToken ||
                !constructor ||
                !qc.is.kind(Identifier, propName) ||
                !strictNullChecks ||
                !isPropertyInitializedInConstructor(propName, type, constructor)
              ) {
                const errorMessage = qd.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration;
                error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, base.symbolToString(), typeToString(baseType));
              }
            }
          }
          continue;
        } else if (isPrototypeProperty(base)) {
          if (isPrototypeProperty(derived) || derived.flags & SymbolFlags.Property) continue;
          else {
            assert(!!(derived.flags & SymbolFlags.Accessor));
            errorMessage = qd.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
          }
        } else if (base.flags & SymbolFlags.Accessor) {
          errorMessage = qd.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
        } else {
          errorMessage = qd.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
        }
        error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), base.symbolToString(), typeToString(type));
      }
    }
  }
  function getNonInterhitedProperties(type: InterfaceType, baseTypes: BaseType[], properties: Symbol[]) {
    if (!length(baseTypes)) return properties;
    const seen = createUnderscoreEscapedMap<Symbol>();
    forEach(properties, (p) => {
      seen.set(p.escName, p);
    });
    for (const base of baseTypes) {
      const properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
      for (const prop of properties) {
        const existing = seen.get(prop.escName);
        if (existing && !isPropertyIdenticalTo(existing, prop)) seen.delete(prop.escName);
      }
    }
    return arrayFrom(seen.values());
  }
  function checkInheritedPropertiesAreIdentical(type: InterfaceType, typeNode: Node): boolean {
    const baseTypes = getBaseTypes(type);
    if (baseTypes.length < 2) return true;
    interface InheritanceInfoMap {
      prop: Symbol;
      containingType: Type;
    }
    const seen = createUnderscoreEscapedMap<InheritanceInfoMap>();
    forEach(resolveDeclaredMembers(type).declaredProperties, (p) => {
      seen.set(p.escName, { prop: p, containingType: type });
    });
    let ok = true;
    for (const base of baseTypes) {
      const properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
      for (const prop of properties) {
        const existing = seen.get(prop.escName);
        if (!existing) seen.set(prop.escName, { prop, containingType: base });
        else {
          const isInheritedProperty = existing.containingType !== type;
          if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {
            ok = false;
            const typeName1 = typeToString(existing.containingType);
            const typeName2 = typeToString(base);
            let errorInfo = chainDiagnosticMessages(undefined, qd.Named_property_0_of_types_1_and_2_are_not_identical, prop.symbolToString(), typeName1, typeName2);
            errorInfo = chainDiagnosticMessages(errorInfo, qd.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2);
            diagnostics.add(createDiagnosticForNodeFromMessageChain(typeNode, errorInfo));
          }
        }
      }
    }
    return ok;
  }
  function checkPropertyInitialization(node: ClassLikeDeclaration) {
    if (!strictNullChecks || !strictPropertyInitialization || node.flags & NodeFlags.Ambient) return;
    const constructor = findConstructorDeclaration(node);
    for (const member of node.members) {
      if (getEffectiveModifierFlags(member) & ModifierFlags.Ambient) continue;
      if (isInstancePropertyWithoutInitializer(member)) {
        const propName = (<PropertyDeclaration>member).name;
        if (qc.is.kind(Identifier, propName) || qc.is.kind(PrivateIdentifier, propName)) {
          const type = getTypeOfSymbol(getSymbolOfNode(member));
          if (!(type.flags & TypeFlags.AnyOrUnknown || getFalsyFlags(type) & TypeFlags.Undefined)) {
            if (!constructor || !isPropertyInitializedInConstructor(propName, type, constructor))
              error(member.name, qd.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, declarationNameToString(propName));
          }
        }
      }
    }
  }
  function isInstancePropertyWithoutInitializer(node: Node) {
    return (
      node.kind === Syntax.PropertyDeclaration &&
      !hasSyntacticModifier(node, ModifierFlags.Static | ModifierFlags.Abstract) &&
      !(<PropertyDeclaration>node).exclamationToken &&
      !(<PropertyDeclaration>node).initializer
    );
  }
  function isPropertyInitializedInConstructor(propName: Identifier | PrivateIdentifier, propType: Type, constructor: ConstructorDeclaration) {
    const reference = new qc.PropertyAccessExpression(new qc.ThisExpression(), propName);
    reference.expression.parent = reference;
    reference.parent = constructor;
    reference.flowNode = constructor.returnFlowNode;
    const flowType = getFlowTypeOfReference(reference, propType, getOptionalType(propType));
    return !(getFalsyFlags(flowType) & TypeFlags.Undefined);
  }
  function checkInterfaceDeclaration(node: InterfaceDeclaration) {
    if (!checkGrammarDecoratorsAndModifiers(node)) checkGrammarInterfaceDeclaration(node);
    checkTypeParameters(node.typeParameters);
    if (produceDiagnostics) {
      checkTypeNameIsReserved(node.name, qd.Interface_name_cannot_be_0);
      checkExportsOnMergedDeclarations(node);
      const symbol = getSymbolOfNode(node);
      checkTypeParameterListsIdentical(symbol);
      const firstInterfaceDecl = getDeclarationOfKind<InterfaceDeclaration>(symbol, Syntax.InterfaceDeclaration);
      if (node === firstInterfaceDecl) {
        const type = <InterfaceType>getDeclaredTypeOfSymbol(symbol);
        const typeWithThis = getTypeWithThisArgument(type);
        if (checkInheritedPropertiesAreIdentical(type, node.name)) {
          for (const baseType of getBaseTypes(type)) {
            checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type.thisType), node.name, qd.Interface_0_incorrectly_extends_interface_1);
          }
          checkIndexConstraints(type);
        }
      }
      checkObjectTypeForDuplicateDeclarations(node);
    }
    forEach(getInterfaceBaseTypeNodes(node), (heritageElement) => {
      if (!isEntityNameExpression(heritageElement.expression)) error(heritageElement.expression, qd.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments);
      checkTypeReferenceNode(heritageElement);
    });
    forEach(node.members, checkSourceElement);
    if (produceDiagnostics) {
      checkTypeForDuplicateIndexSignatures(node);
      registerForUnusedIdentifiersCheck(node);
    }
  }
  function checkTypeAliasDeclaration(node: TypeAliasDeclaration) {
    checkGrammarDecoratorsAndModifiers(node);
    checkTypeNameIsReserved(node.name, qd.Type_alias_name_cannot_be_0);
    checkExportsOnMergedDeclarations(node);
    checkTypeParameters(node.typeParameters);
    checkSourceElement(node.type);
    registerForUnusedIdentifiersCheck(node);
  }
  function computeEnumMemberValues(node: EnumDeclaration) {
    const nodeLinks = getNodeLinks(node);
    if (!(nodeLinks.flags & NodeCheckFlags.EnumValuesComputed)) {
      nodeLinks.flags |= NodeCheckFlags.EnumValuesComputed;
      let autoValue: number | undefined = 0;
      for (const member of node.members) {
        const value = computeMemberValue(member, autoValue);
        getNodeLinks(member).enumMemberValue = value;
        autoValue = typeof value === 'number' ? value + 1 : undefined;
      }
    }
  }
  function computeMemberValue(member: EnumMember, autoValue: number | undefined) {
    if (isComputedNonLiteralName(member.name)) error(member.name, qd.Computed_property_names_are_not_allowed_in_enums);
    else {
      const text = getTextOfPropertyName(member.name);
      if (NumericLiteral.name(text) && !isInfinityOrNaNString(text)) error(member.name, qd.An_enum_member_cannot_have_a_numeric_name);
    }
    if (member.initializer) return computeConstantValue(member);
    if (member.parent.flags & NodeFlags.Ambient && !isEnumConst(member.parent) && getEnumKind(getSymbolOfNode(member.parent)) === EnumKind.Numeric) return;
    if (autoValue !== undefined) return autoValue;
    error(member.name, qd.Enum_member_must_have_initializer);
    return;
  }
  function computeConstantValue(member: EnumMember): string | number | undefined {
    const enumKind = getEnumKind(getSymbolOfNode(member.parent));
    const isConstEnum = isEnumConst(member.parent);
    const initializer = member.initializer!;
    const value = enumKind === EnumKind.Literal && !isLiteralEnumMember(member) ? undefined : evaluate(initializer);
    if (value !== undefined) {
      if (isConstEnum && typeof value === 'number' && !isFinite(value)) {
        error(initializer, isNaN(value) ? qd.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN : qd.const_enum_member_initializer_was_evaluated_to_a_non_finite_value);
      }
    } else if (enumKind === EnumKind.Literal) {
      error(initializer, qd.Computed_values_are_not_permitted_in_an_enum_with_string_valued_members);
      return 0;
    } else if (isConstEnum) {
      error(initializer, qd.const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values);
    } else if (member.parent.flags & NodeFlags.Ambient) {
      error(initializer, qd.In_ambient_enum_declarations_member_initializer_must_be_constant_expression);
    } else {
      const source = checkExpression(initializer);
      if (!isTypeAssignableToKind(source, TypeFlags.NumberLike)) {
        error(
          initializer,
          qd.Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhaustiveness_checks_consider_using_an_object_literal_instead,
          typeToString(source)
        );
      } else {
        checkTypeAssignableTo(source, getDeclaredTypeOfSymbol(getSymbolOfNode(member.parent)), initializer, undefined);
      }
    }
    return value;
    function evaluate(expr: Expression): string | number | undefined {
      switch (expr.kind) {
        case Syntax.PrefixUnaryExpression:
          const value = evaluate((<PrefixUnaryExpression>expr).operand);
          if (typeof value === 'number') {
            switch ((<PrefixUnaryExpression>expr).operator) {
              case Syntax.PlusToken:
                return value;
              case Syntax.MinusToken:
                return -value;
              case Syntax.TildeToken:
                return ~value;
            }
          }
          break;
        case Syntax.BinaryExpression:
          const left = evaluate((<BinaryExpression>expr).left);
          const right = evaluate((<BinaryExpression>expr).right);
          if (typeof left === 'number' && typeof right === 'number') {
            switch ((<BinaryExpression>expr).operatorToken.kind) {
              case Syntax.BarToken:
                return left | right;
              case Syntax.AmpersandToken:
                return left & right;
              case Syntax.GreaterThan2Token:
                return left >> right;
              case Syntax.GreaterThan3Token:
                return left >>> right;
              case Syntax.LessThan2Token:
                return left << right;
              case Syntax.CaretToken:
                return left ^ right;
              case Syntax.AsteriskToken:
                return left * right;
              case Syntax.SlashToken:
                return left / right;
              case Syntax.PlusToken:
                return left + right;
              case Syntax.MinusToken:
                return left - right;
              case Syntax.PercentToken:
                return left % right;
              case Syntax.Asterisk2Token:
                return left ** right;
            }
          } else if (typeof left === 'string' && typeof right === 'string' && (<BinaryExpression>expr).operatorToken.kind === Syntax.PlusToken) {
            return left + right;
          }
          break;
        case Syntax.StringLiteral:
        case Syntax.NoSubstitutionLiteral:
          return (<StringLiteralLike>expr).text;
        case Syntax.NumericLiteral:
          checkGrammarNumericLiteral(<NumericLiteral>expr);
          return +(<NumericLiteral>expr).text;
        case Syntax.ParenthesizedExpression:
          return evaluate((<ParenthesizedExpression>expr).expression);
        case Syntax.Identifier:
          const identifier = <Identifier>expr;
          if (isInfinityOrNaNString(identifier.escapedText)) return +identifier.escapedText;
          return qc.is.missing(expr) ? 0 : evaluateEnumMember(expr, getSymbolOfNode(member.parent), identifier.escapedText);
        case Syntax.ElementAccessExpression:
        case Syntax.PropertyAccessExpression:
          const ex = <AccessExpression>expr;
          if (isConstantMemberAccess(ex)) {
            const type = getTypeOfExpression(ex.expression);
            if (type.symbol && type.symbol.flags & SymbolFlags.Enum) {
              let name: __String;
              if (ex.kind === Syntax.PropertyAccessExpression) name = ex.name.escapedText;
              else {
                name = syntax.get.escUnderscores(cast(ex.argumentExpression, isLiteralExpression).text);
              }
              return evaluateEnumMember(expr, type.symbol, name);
            }
          }
          break;
      }
      return;
    }
    function evaluateEnumMember(expr: Expression, enumSymbol: Symbol, name: __String) {
      const memberSymbol = enumSymbol.exports!.get(name);
      if (memberSymbol) {
        const declaration = memberSymbol.valueDeclaration;
        if (declaration !== member) {
          if (isBlockScopedNameDeclaredBeforeUse(declaration, member)) return getEnumMemberValue(declaration as EnumMember);
          error(expr, qd.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums);
          return 0;
        } else {
          error(expr, qd.Property_0_is_used_before_being_assigned, memberSymbol.symbolToString());
        }
      }
      return;
    }
  }
  function isConstantMemberAccess(node: Expression): boolean {
    return (
      node.kind === Syntax.Identifier ||
      (node.kind === Syntax.PropertyAccessExpression && isConstantMemberAccess((<PropertyAccessExpression>node).expression)) ||
      (node.kind === Syntax.ElementAccessExpression && isConstantMemberAccess((<ElementAccessExpression>node).expression) && StringLiteral.like((<ElementAccessExpression>node).argumentExpression))
    );
  }
  function checkEnumDeclaration(node: EnumDeclaration) {
    if (!produceDiagnostics) return;
    checkGrammarDecoratorsAndModifiers(node);
    checkTypeNameIsReserved(node.name, qd.Enum_name_cannot_be_0);
    checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
    checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
    checkExportsOnMergedDeclarations(node);
    node.members.forEach(checkEnumMember);
    computeEnumMemberValues(node);
    const enumSymbol = getSymbolOfNode(node);
    const firstDeclaration = getDeclarationOfKind(enumSymbol, node.kind);
    if (node === firstDeclaration) {
      if (enumSymbol.declarations.length > 1) {
        const enumIsConst = isEnumConst(node);
        forEach(enumSymbol.declarations, (decl) => {
          if (qc.is.kind(EnumDeclaration, decl) && isEnumConst(decl) !== enumIsConst) error(getNameOfDeclaration(decl), qd.Enum_declarations_must_all_be_const_or_non_const);
        });
      }
      let seenEnumMissingInitialInitializer = false;
      forEach(enumSymbol.declarations, (declaration) => {
        if (declaration.kind !== Syntax.EnumDeclaration) return false;
        const enumDeclaration = <EnumDeclaration>declaration;
        if (!enumDeclaration.members.length) return false;
        const firstEnumMember = enumDeclaration.members[0];
        if (!firstEnumMember.initializer) {
          if (seenEnumMissingInitialInitializer) error(firstEnumMember.name, qd.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
          else {
            seenEnumMissingInitialInitializer = true;
          }
        }
      });
    }
  }
  function checkEnumMember(node: EnumMember) {
    if (qc.is.kind(PrivateIdentifier, node.name)) error(node, qd.An_enum_member_cannot_be_named_with_a_private_identifier);
  }
  function inSameLexicalScope(node1: Node, node2: Node) {
    const container1 = qc.get.enclosingBlockScopeContainer(node1);
    const container2 = qc.get.enclosingBlockScopeContainer(node2);
    if (isGlobalSourceFile(container1)) return isGlobalSourceFile(container2);
    else if (isGlobalSourceFile(container2)) return false;
    return container1 === container2;
  }
  function checkModuleDeclaration(node: ModuleDeclaration) {
    if (produceDiagnostics) {
      const isGlobalAugmentation = isGlobalScopeAugmentation(node);
      const inAmbientContext = node.flags & NodeFlags.Ambient;
      if (isGlobalAugmentation && !inAmbientContext) error(node.name, qd.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context);
      const isAmbientExternalModule = qc.is.ambientModule(node);
      const contextErrorMessage = isAmbientExternalModule
        ? qd.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file
        : qd.A_namespace_declaration_is_only_allowed_in_a_namespace_or_module;
      if (checkGrammarModuleElementContext(node, contextErrorMessage)) return;
      if (!checkGrammarDecoratorsAndModifiers(node)) {
        if (!inAmbientContext && node.name.kind === Syntax.StringLiteral) grammarErrorOnNode(node.name, qd.Only_ambient_modules_can_use_quoted_names);
      }
      if (qc.is.kind(Identifier, node.name)) {
        checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
        checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
      }
      checkExportsOnMergedDeclarations(node);
      const symbol = getSymbolOfNode(node);
      if (
        symbol.flags & SymbolFlags.ValueModule &&
        !inAmbientContext &&
        symbol.declarations.length > 1 &&
        isInstantiatedModule(node, !!compilerOptions.preserveConstEnums || !!compilerOptions.isolatedModules)
      ) {
        const firstNonAmbientClassOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);
        if (firstNonAmbientClassOrFunc) {
          if (qc.get.sourceFileOf(node) !== qc.get.sourceFileOf(firstNonAmbientClassOrFunc))
            error(node.name, qd.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
          else if (node.pos < firstNonAmbientClassOrFunc.pos) {
            error(node.name, qd.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
          }
        }
        const mergedClass = getDeclarationOfKind(symbol, Syntax.ClassDeclaration);
        if (mergedClass && inSameLexicalScope(node, mergedClass)) getNodeLinks(node).flags |= NodeCheckFlags.LexicalModuleMergesWithClass;
      }
      if (isAmbientExternalModule) {
        if (qc.is.externalModuleAugmentation(node)) {
          const checkBody = isGlobalAugmentation || getSymbolOfNode(node).flags & SymbolFlags.Transient;
          if (checkBody && node.body) {
            for (const statement of node.body.statements) {
              checkModuleAugmentationElement(statement, isGlobalAugmentation);
            }
          }
        } else if (isGlobalSourceFile(node.parent)) {
          if (isGlobalAugmentation) error(node.name, qd.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
          else if (qp_isExternalModuleNameRelative(getTextOfIdentifierOrLiteral(node.name))) {
            error(node.name, qd.Ambient_module_declaration_cannot_specify_relative_module_name);
          }
        } else {
          if (isGlobalAugmentation) error(node.name, qd.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
          else {
            error(node.name, qd.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces);
          }
        }
      }
    }
    if (node.body) {
      checkSourceElement(node.body);
      if (!isGlobalScopeAugmentation(node)) registerForUnusedIdentifiersCheck(node);
    }
  }
  function checkModuleAugmentationElement(node: Node, isGlobalAugmentation: boolean): void {
    switch (node.kind) {
      case Syntax.VariableStatement:
        for (const decl of (<VariableStatement>node).declarationList.declarations) {
          checkModuleAugmentationElement(decl, isGlobalAugmentation);
        }
        break;
      case Syntax.ExportAssignment:
      case Syntax.ExportDeclaration:
        grammarErrorOnFirstToken(node, qd.Exports_and_export_assignments_are_not_permitted_in_module_augmentations);
        break;
      case Syntax.ImportEqualsDeclaration:
      case Syntax.ImportDeclaration:
        grammarErrorOnFirstToken(node, qd.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module);
        break;
      case Syntax.BindingElement:
      case Syntax.VariableDeclaration:
        const name = (<VariableDeclaration | BindingElement>node).name;
        if (qc.is.kind(BindingPattern, name)) {
          for (const el of name.elements) {
            checkModuleAugmentationElement(el, isGlobalAugmentation);
          }
          break;
        }
      case Syntax.ClassDeclaration:
      case Syntax.EnumDeclaration:
      case Syntax.FunctionDeclaration:
      case Syntax.InterfaceDeclaration:
      case Syntax.ModuleDeclaration:
      case Syntax.TypeAliasDeclaration:
        if (isGlobalAugmentation) return;
        const symbol = getSymbolOfNode(node);
        if (symbol) {
          let reportError = !(symbol.flags & SymbolFlags.Transient);
          if (!reportError) reportError = !!symbol.parent && qc.is.externalModuleAugmentation(symbol.parent.declarations[0]);
        }
        break;
    }
  }
  function getFirstNonModuleExportsIdentifier(node: EntityNameOrEntityNameExpression): Identifier {
    switch (node.kind) {
      case Syntax.Identifier:
        return node;
      case Syntax.QualifiedName:
        do {
          node = node.left;
        } while (node.kind !== Syntax.Identifier);
        return node;
      case Syntax.PropertyAccessExpression:
        do {
          if (qc.is.moduleExportsAccessExpression(node.expression) && !qc.is.kind(PrivateIdentifier, node.name)) return node.name;
          node = node.expression;
        } while (node.kind !== Syntax.Identifier);
        return node;
    }
  }
  function checkExternalImportOrExportDeclaration(node: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration): boolean {
    const moduleName = getExternalModuleName(node);
    if (!moduleName || qc.is.missing(moduleName)) return false;
    if (!qc.is.kind(StringLiteral, moduleName)) {
      error(moduleName, qd.String_literal_expected);
      return false;
    }
    const inAmbientExternalModule = node.parent.kind === Syntax.ModuleBlock && qc.is.ambientModule(node.parent.parent);
    if (node.parent.kind !== Syntax.SourceFile && !inAmbientExternalModule) {
      error(moduleName, node.kind === Syntax.ExportDeclaration ? qd.Export_declarations_are_not_permitted_in_a_namespace : qd.Import_declarations_in_a_namespace_cannot_reference_a_module);
      return false;
    }
    if (inAmbientExternalModule && qp_isExternalModuleNameRelative(moduleName.text)) {
      if (!isTopLevelInExternalModuleAugmentation(node)) {
        error(node, qd.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name);
        return false;
      }
    }
    return true;
  }
  function checkAliasSymbol(node: ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportSpecifier | ExportSpecifier | NamespaceExport) {
    let symbol = getSymbolOfNode(node);
    const target = this.resolveAlias();
    const shouldSkipWithJSExpandoTargets = symbol.flags & SymbolFlags.Assignment;
    if (!shouldSkipWithJSExpandoTargets && target !== unknownSymbol) {
      symbol = getMergedSymbol(symbol.exportSymbol || symbol);
      const excludedMeanings =
        (symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) ? SymbolFlags.Value : 0) |
        (symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0) |
        (symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0);
      if (target.flags & excludedMeanings) {
        const message = node.kind === Syntax.ExportSpecifier ? qd.Export_declaration_conflicts_with_exported_declaration_of_0 : qd.Import_declaration_conflicts_with_local_declaration_of_0;
        error(node, message, symbol.symbolToString());
      }
      if (compilerOptions.isolatedModules && node.kind === Syntax.ExportSpecifier && !node.parent.parent.isTypeOnly && !(target.flags & SymbolFlags.Value) && !(node.flags & NodeFlags.Ambient))
        error(node, qd.Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type);
    }
  }
  function checkImportBinding(node: ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportSpecifier) {
    checkCollisionWithRequireExportsInGeneratedCode(node, node.name!);
    checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name!);
    checkAliasSymbol(node);
  }
  function checkImportDeclaration(node: ImportDeclaration) {
    if (checkGrammarModuleElementContext(node, qd.An_import_declaration_can_only_be_used_in_a_namespace_or_module)) return;
    if (!checkGrammarDecoratorsAndModifiers(node) && hasEffectiveModifiers(node)) grammarErrorOnFirstToken(node, qd.An_import_declaration_cannot_have_modifiers);
    if (checkExternalImportOrExportDeclaration(node)) {
      const importClause = node.importClause;
      if (importClause && !checkGrammarImportClause(importClause)) {
        if (importClause.name) checkImportBinding(importClause);
        if (importClause.namedBindings) {
          if (importClause.namedBindings.kind === Syntax.NamespaceImport) checkImportBinding(importClause.namedBindings);
          else {
            const moduleExisted = resolveExternalModuleName(node, node.moduleSpecifier);
            if (moduleExisted) forEach(importClause.namedBindings.elements, checkImportBinding);
          }
        }
      }
    }
  }
  function checkImportEqualsDeclaration(node: ImportEqualsDeclaration) {
    if (checkGrammarModuleElementContext(node, qd.An_import_declaration_can_only_be_used_in_a_namespace_or_module)) return;
    checkGrammarDecoratorsAndModifiers(node);
    if (isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node)) {
      checkImportBinding(node);
      if (hasSyntacticModifier(node, ModifierFlags.Export)) markExportAsReferenced(node);
      if (node.moduleReference.kind !== Syntax.ExternalModuleReference) {
        const target = getSymbolOfNode(node).resolveAlias();
        if (target !== unknownSymbol) {
          if (target.flags & SymbolFlags.Value) {
            const moduleName = getFirstIdentifier(node.moduleReference);
            if (!(resolveEntityName(moduleName, SymbolFlags.Value | SymbolFlags.Namespace)!.flags & SymbolFlags.Namespace))
              error(moduleName, qd.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, declarationNameToString(moduleName));
          }
          if (target.flags & SymbolFlags.Type) checkTypeNameIsReserved(node.name, qd.Import_name_cannot_be_0);
        }
      } else {
        if (moduleKind >= ModuleKind.ES2015 && !(node.flags & NodeFlags.Ambient)) {
          grammarErrorOnNode(
            node,
            qd.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead
          );
        }
      }
    }
  }
  function checkExportDeclaration(node: ExportDeclaration) {
    if (checkGrammarModuleElementContext(node, qd.An_export_declaration_can_only_be_used_in_a_module)) return;
    if (!checkGrammarDecoratorsAndModifiers(node) && hasEffectiveModifiers(node)) grammarErrorOnFirstToken(node, qd.An_export_declaration_cannot_have_modifiers);
    checkGrammarExportDeclaration(node);
    if (!node.moduleSpecifier || checkExternalImportOrExportDeclaration(node)) {
      if (node.exportClause && !qc.is.kind(NamespaceExport, node.exportClause)) {
        forEach(node.exportClause.elements, checkExportSpecifier);
        const inAmbientExternalModule = node.parent.kind === Syntax.ModuleBlock && qc.is.ambientModule(node.parent.parent);
        const inAmbientNamespaceDeclaration = !inAmbientExternalModule && node.parent.kind === Syntax.ModuleBlock && !node.moduleSpecifier && node.flags & NodeFlags.Ambient;
        if (node.parent.kind !== Syntax.SourceFile && !inAmbientExternalModule && !inAmbientNamespaceDeclaration) error(node, qd.Export_declarations_are_not_permitted_in_a_namespace);
      } else {
        const moduleSymbol = resolveExternalModuleName(node, node.moduleSpecifier!);
        if (moduleSymbol && hasExportAssignmentSymbol(moduleSymbol)) error(node.moduleSpecifier, qd.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, moduleSymbol.symbolToString());
        else if (node.exportClause) {
          checkAliasSymbol(node.exportClause);
        }
        if (moduleKind !== ModuleKind.System && moduleKind < ModuleKind.ES2015) checkExternalEmitHelpers(node, ExternalEmitHelpers.ExportStar);
      }
    }
  }
  function checkGrammarExportDeclaration(node: ExportDeclaration): boolean {
    const isTypeOnlyExportStar = node.isTypeOnly && node.exportClause?.kind !== Syntax.NamedExports;
    if (isTypeOnlyExportStar) grammarErrorOnNode(node, qd.Only_named_exports_may_use_export_type);
    return !isTypeOnlyExportStar;
  }
  function checkGrammarModuleElementContext(node: Statement, errorMessage: DiagnosticMessage): boolean {
    const isInAppropriateContext = node.parent.kind === Syntax.SourceFile || node.parent.kind === Syntax.ModuleBlock || node.parent.kind === Syntax.ModuleDeclaration;
    if (!isInAppropriateContext) grammarErrorOnFirstToken(node, errorMessage);
    return !isInAppropriateContext;
  }
  function importClauseContainsReferencedImport(importClause: ImportClause) {
    return forEachImportClauseDeclaration(importClause, (declaration) => {
      return !!getSymbolOfNode(declaration).isReferenced;
    });
  }
  function importClauseContainsConstEnumUsedAsValue(importClause: ImportClause) {
    return forEachImportClauseDeclaration(importClause, (declaration) => {
      return !!s.getLinks(getSymbolOfNode(declaration)).constEnumReferenced;
    });
  }
  function checkImportsForTypeOnlyConversion(sourceFile: SourceFile) {
    for (const statement of sourceFile.statements) {
      if (
        qc.is.kind(ImportDeclaration, statement) &&
        statement.importClause &&
        !statement.importClause.isTypeOnly &&
        importClauseContainsReferencedImport(statement.importClause) &&
        !isReferencedAliasDeclaration(statement.importClause, true) &&
        !importClauseContainsConstEnumUsedAsValue(statement.importClause)
      ) {
        error(statement, qd.This_import_is_never_used_as_a_value_and_must_use_import_type_because_the_importsNotUsedAsValues_is_set_to_error);
      }
    }
  }
  function checkExportSpecifier(node: ExportSpecifier) {
    checkAliasSymbol(node);
    if (getEmitDeclarations(compilerOptions)) collectLinkedAliases(node.propertyName || node.name, true);
    if (!node.parent.parent.moduleSpecifier) {
      const exportedName = node.propertyName || node.name;
      const symbol = resolveName(exportedName, exportedName.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, undefined, undefined, true);
      if (symbol && (symbol === undefinedSymbol || symbol === globalThisSymbol || isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0]))))
        error(exportedName, qd.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, idText(exportedName));
      else {
        markExportAsReferenced(node);
        const target = symbol && (symbol.flags & SymbolFlags.Alias ? this.resolveAlias() : symbol);
        if (!target || target === unknownSymbol || target.flags & SymbolFlags.Value) checkExpressionCached(node.propertyName || node.name);
      }
    }
  }
  function checkExportAssignment(node: ExportAssignment) {
    if (checkGrammarModuleElementContext(node, qd.An_export_assignment_can_only_be_used_in_a_module)) return;
    const container = node.parent.kind === Syntax.SourceFile ? node.parent : <ModuleDeclaration>node.parent.parent;
    if (container.kind === Syntax.ModuleDeclaration && !qc.is.ambientModule(container)) {
      if (node.isExportEquals) error(node, qd.An_export_assignment_cannot_be_used_in_a_namespace);
      else {
        error(node, qd.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
      }
      return;
    }
    if (!checkGrammarDecoratorsAndModifiers(node) && hasEffectiveModifiers(node)) grammarErrorOnFirstToken(node, qd.An_export_assignment_cannot_have_modifiers);
    if (node.expression.kind === Syntax.Identifier) {
      const id = node.expression as Identifier;
      const sym = resolveEntityName(id, SymbolFlags.All, true, true, node);
      if (sym) {
        markAliasReferenced(sym, id);
        const target = sym.flags & SymbolFlags.Alias ? sym.resolveAlias() : sym;
        if (target === unknownSymbol || target.flags & SymbolFlags.Value) checkExpressionCached(node.expression);
      }
      if (getEmitDeclarations(compilerOptions)) collectLinkedAliases(node.expression as Identifier, true);
    } else {
      checkExpressionCached(node.expression);
    }
    checkExternalModuleExports(container);
    if (node.flags & NodeFlags.Ambient && !isEntityNameExpression(node.expression))
      grammarErrorOnNode(node.expression, qd.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context);
    if (node.isExportEquals && !(node.flags & NodeFlags.Ambient)) {
      if (moduleKind >= ModuleKind.ES2015)
        grammarErrorOnNode(node, qd.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead);
      else if (moduleKind === ModuleKind.System) {
        grammarErrorOnNode(node, qd.Export_assignment_is_not_supported_when_module_flag_is_system);
      }
    }
  }
  function hasExportedMembers(moduleSymbol: Symbol) {
    return forEachEntry(moduleSymbol.exports!, (_, id) => id !== 'export=');
  }
  function checkExternalModuleExports(node: SourceFile | ModuleDeclaration) {
    const moduleSymbol = getSymbolOfNode(node);
    const links = s.getLinks(moduleSymbol);
    if (!links.exportsChecked) {
      const exportEqualsSymbol = moduleSymbol.exports!.get('export=' as __String);
      if (exportEqualsSymbol && hasExportedMembers(moduleSymbol)) {
        const declaration = exportEqualsSymbol.getDeclarationOfAliasSymbol() || exportEqualsSymbol.valueDeclaration;
        if (!isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(declaration)) error(declaration, qd.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);
      }
      const exports = getExportsOfModule(moduleSymbol);
      if (exports) {
        exports.forEach(({ declarations, flags }, id) => {
          if (id === '__export') return;
          if (flags & (SymbolFlags.Namespace | SymbolFlags.Interface | SymbolFlags.Enum)) return;
          const exportedDeclarationsCount = countWhere(declarations, isNotOverloadAndNotAccessor);
          if (flags & SymbolFlags.TypeAlias && exportedDeclarationsCount <= 2) return;
          if (exportedDeclarationsCount > 1) {
            for (const declaration of declarations) {
              if (isNotOverload(declaration)) diagnostics.add(createDiagnosticForNode(declaration, qd.Cannot_redeclare_exported_variable_0, syntax.get.unescUnderscores(id)));
            }
          }
        });
      }
      links.exportsChecked = true;
    }
  }
  function checkSourceElement(node: Node | undefined): void {
    if (node) {
      const saveCurrentNode = currentNode;
      currentNode = node;
      instantiationCount = 0;
      checkSourceElementWorker(node);
      currentNode = saveCurrentNode;
    }
  }
  function checkSourceElementWorker(node: Node): void {
    if (isInJSFile(node)) forEach((node as JSDocContainer).jsDoc, ({ tags }) => forEach(tags, checkSourceElement));
    const kind = node.kind;
    if (cancellationToken) {
      switch (kind) {
        case Syntax.ModuleDeclaration:
        case Syntax.ClassDeclaration:
        case Syntax.InterfaceDeclaration:
        case Syntax.FunctionDeclaration:
          cancellationToken.throwIfCancellationRequested();
      }
    }
    if (kind >= Syntax.FirstStatement && kind <= Syntax.LastStatement && node.flowNode && !isReachableFlowNode(node.flowNode))
      errorOrSuggestion(compilerOptions.allowUnreachableCode === false, node, qd.Unreachable_code_detected);
    switch (kind) {
      case Syntax.TypeParameter:
        return checkTypeParameter(<TypeParameterDeclaration>node);
      case Syntax.Parameter:
        return checkParameter(<ParameterDeclaration>node);
      case Syntax.PropertyDeclaration:
        return checkPropertyDeclaration(<PropertyDeclaration>node);
      case Syntax.PropertySignature:
        return checkPropertySignature(<PropertySignature>node);
      case Syntax.FunctionType:
      case Syntax.ConstructorType:
      case Syntax.CallSignature:
      case Syntax.ConstructSignature:
      case Syntax.IndexSignature:
        return checkSignatureDeclaration(<SignatureDeclaration>node);
      case Syntax.MethodDeclaration:
      case Syntax.MethodSignature:
        return checkMethodDeclaration(<MethodDeclaration | MethodSignature>node);
      case Syntax.Constructor:
        return checkConstructorDeclaration(<ConstructorDeclaration>node);
      case Syntax.GetAccessor:
      case Syntax.SetAccessor:
        return checkAccessorDeclaration(<AccessorDeclaration>node);
      case Syntax.TypeReference:
        return checkTypeReferenceNode(<TypeReferenceNode>node);
      case Syntax.TypePredicate:
        return checkTypePredicate(<TypePredicateNode>node);
      case Syntax.TypeQuery:
        return checkTypeQuery(<TypeQueryNode>node);
      case Syntax.TypeLiteral:
        return checkTypeLiteral(<TypeLiteralNode>node);
      case Syntax.ArrayType:
        return checkArrayType(<ArrayTypeNode>node);
      case Syntax.TupleType:
        return checkTupleType(<TupleTypeNode>node);
      case Syntax.UnionType:
      case Syntax.IntersectionType:
        return checkUnionOrIntersectionType(<UnionOrIntersectionTypeNode>node);
      case Syntax.ParenthesizedType:
      case Syntax.OptionalType:
      case Syntax.RestType:
        return checkSourceElement((<ParenthesizedTypeNode | OptionalTypeNode | RestTypeNode>node).type);
      case Syntax.ThisType:
        return checkThisType(<ThisTypeNode>node);
      case Syntax.TypeOperator:
        return checkTypeOperator(<TypeOperatorNode>node);
      case Syntax.ConditionalType:
        return checkConditionalType(<ConditionalTypeNode>node);
      case Syntax.InferType:
        return checkInferType(<InferTypeNode>node);
      case Syntax.ImportType:
        return checkImportType(<ImportTypeNode>node);
      case Syntax.NamedTupleMember:
        return checkNamedTupleMember(<NamedTupleMember>node);
      case Syntax.JSDocAugmentsTag:
        return checkJSDocAugmentsTag(node as JSDocAugmentsTag);
      case Syntax.JSDocImplementsTag:
        return checkJSDocImplementsTag(node as JSDocImplementsTag);
      case Syntax.JSDocTypedefTag:
      case Syntax.JSDocCallbackTag:
      case Syntax.JSDocEnumTag:
        return checkJSDocTypeAliasTag(node as JSDocTypedefTag);
      case Syntax.JSDocTemplateTag:
        return checkJSDocTemplateTag(node as JSDocTemplateTag);
      case Syntax.JSDocTypeTag:
        return checkJSDocTypeTag(node as JSDocTypeTag);
      case Syntax.JSDocParameterTag:
        return checkJSDocParameterTag(node as JSDocParameterTag);
      case Syntax.JSDocPropertyTag:
        return checkJSDocPropertyTag(node as JSDocPropertyTag);
      case Syntax.JSDocFunctionType:
        checkJSDocFunctionType(node as JSDocFunctionType);
      case Syntax.JSDocNonNullableType:
      case Syntax.JSDocNullableType:
      case Syntax.JSDocAllType:
      case Syntax.JSDocUnknownType:
      case Syntax.JSDocTypeLiteral:
        checkJSDocTypeIsInJsFile(node);
        qc.forEach.child(node, checkSourceElement);
        return;
      case Syntax.JSDocVariadicType:
        checkJSDocVariadicType(node as JSDocVariadicType);
        return;
      case Syntax.JSDocTypeExpression:
        return checkSourceElement((node as JSDocTypeExpression).type);
      case Syntax.IndexedAccessType:
        return checkIndexedAccessType(<IndexedAccessTypeNode>node);
      case Syntax.MappedType:
        return checkMappedType(<MappedTypeNode>node);
      case Syntax.FunctionDeclaration:
        return checkFunctionDeclaration(<FunctionDeclaration>node);
      case Syntax.Block:
      case Syntax.ModuleBlock:
        return checkBlock(<Block>node);
      case Syntax.VariableStatement:
        return checkVariableStatement(<VariableStatement>node);
      case Syntax.ExpressionStatement:
        return checkExpressionStatement(<ExpressionStatement>node);
      case Syntax.IfStatement:
        return checkIfStatement(<IfStatement>node);
      case Syntax.DoStatement:
        return checkDoStatement(<DoStatement>node);
      case Syntax.WhileStatement:
        return checkWhileStatement(<WhileStatement>node);
      case Syntax.ForStatement:
        return checkForStatement(<ForStatement>node);
      case Syntax.ForInStatement:
        return checkForInStatement(<ForInStatement>node);
      case Syntax.ForOfStatement:
        return checkForOfStatement(<ForOfStatement>node);
      case Syntax.ContinueStatement:
      case Syntax.BreakStatement:
        return checkBreakOrContinueStatement(<BreakOrContinueStatement>node);
      case Syntax.ReturnStatement:
        return checkReturnStatement(<ReturnStatement>node);
      case Syntax.WithStatement:
        return checkWithStatement(<WithStatement>node);
      case Syntax.SwitchStatement:
        return checkSwitchStatement(<SwitchStatement>node);
      case Syntax.LabeledStatement:
        return checkLabeledStatement(<LabeledStatement>node);
      case Syntax.ThrowStatement:
        return checkThrowStatement(<ThrowStatement>node);
      case Syntax.TryStatement:
        return checkTryStatement(<TryStatement>node);
      case Syntax.VariableDeclaration:
        return checkVariableDeclaration(<VariableDeclaration>node);
      case Syntax.BindingElement:
        return checkBindingElement(<BindingElement>node);
      case Syntax.ClassDeclaration:
        return checkClassDeclaration(<ClassDeclaration>node);
      case Syntax.InterfaceDeclaration:
        return checkInterfaceDeclaration(<InterfaceDeclaration>node);
      case Syntax.TypeAliasDeclaration:
        return checkTypeAliasDeclaration(<TypeAliasDeclaration>node);
      case Syntax.EnumDeclaration:
        return checkEnumDeclaration(<EnumDeclaration>node);
      case Syntax.ModuleDeclaration:
        return checkModuleDeclaration(<ModuleDeclaration>node);
      case Syntax.ImportDeclaration:
        return checkImportDeclaration(<ImportDeclaration>node);
      case Syntax.ImportEqualsDeclaration:
        return checkImportEqualsDeclaration(<ImportEqualsDeclaration>node);
      case Syntax.ExportDeclaration:
        return checkExportDeclaration(<ExportDeclaration>node);
      case Syntax.ExportAssignment:
        return checkExportAssignment(<ExportAssignment>node);
      case Syntax.EmptyStatement:
      case Syntax.DebuggerStatement:
        checkGrammarStatementInAmbientContext(node);
        return;
      case Syntax.MissingDeclaration:
        return checkMissingDeclaration(node);
    }
  }
  function checkJSDocTypeIsInJsFile(node: Node): void {
    if (!isInJSFile(node)) grammarErrorOnNode(node, qd.JSDoc_types_can_only_be_used_inside_documentation_comments);
  }
  function checkJSDocVariadicType(node: JSDocVariadicType): void {
    checkJSDocTypeIsInJsFile(node);
    checkSourceElement(node.type);
    const { parent } = node;
    if (qc.is.kind(ParameterDeclaration, parent) && qc.is.kind(JSDocFunctionType, parent.parent)) {
      if (last(parent.parent.parameters) !== parent) error(node, qd.A_rest_parameter_must_be_last_in_a_parameter_list);
      return;
    }
    if (!qc.is.kind(JSDocTypeExpression, parent)) error(node, qd.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature);
    const paramTag = node.parent.parent;
    if (!qc.is.kind(JSDocParameterTag, paramTag)) {
      error(node, qd.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature);
      return;
    }
    const param = getParameterSymbolFromJSDoc(paramTag);
    if (!param) return;
    const host = getHostSignatureFromJSDoc(paramTag);
    if (!host || last(host.parameters).symbol !== param) error(node, qd.A_rest_parameter_must_be_last_in_a_parameter_list);
  }
  function getTypeFromJSDocVariadicType(node: JSDocVariadicType): Type {
    const type = getTypeFromTypeNode(node.type);
    const { parent } = node;
    const paramTag = node.parent.parent;
    if (qc.is.kind(JSDocTypeExpression, node.parent) && qc.is.kind(JSDocParameterTag, paramTag)) {
      const host = getHostSignatureFromJSDoc(paramTag);
      if (host) {
        const lastParamDeclaration = lastOrUndefined(host.parameters);
        const symbol = getParameterSymbolFromJSDoc(paramTag);
        if (!lastParamDeclaration || (symbol && lastParamDeclaration.symbol === symbol && isRestParameter(lastParamDeclaration))) return createArrayType(type);
      }
    }
    if (qc.is.kind(ParameterDeclaration, parent) && qc.is.kind(JSDocFunctionType, parent.parent)) return createArrayType(type);
    return addOptionality(type);
  }
  function checkNodeDeferred(node: Node) {
    const enclosingFile = qc.get.sourceFileOf(node);
    const links = getNodeLinks(enclosingFile);
    if (!(links.flags & NodeCheckFlags.TypeChecked)) {
      links.deferredNodes = links.deferredNodes || new qb.QMap();
      const id = '' + getNodeId(node);
      links.deferredNodes.set(id, node);
    }
  }
  function checkDeferredNodes(context: SourceFile) {
    const links = getNodeLinks(context);
    if (links.deferredNodes) links.deferredNodes.forEach(checkDeferredNode);
  }
  function checkDeferredNode(node: Node) {
    const saveCurrentNode = currentNode;
    currentNode = node;
    instantiationCount = 0;
    switch (node.kind) {
      case Syntax.CallExpression:
      case Syntax.NewExpression:
      case Syntax.TaggedTemplateExpression:
      case Syntax.Decorator:
      case Syntax.JsxOpeningElement:
        resolveUntypedCall(node as CallLikeExpression);
        break;
      case Syntax.FunctionExpression:
      case Syntax.ArrowFunction:
      case Syntax.MethodDeclaration:
      case Syntax.MethodSignature:
        checkFunctionExpressionOrObjectLiteralMethodDeferred(<FunctionExpression>node);
        break;
      case Syntax.GetAccessor:
      case Syntax.SetAccessor:
        checkAccessorDeclaration(<AccessorDeclaration>node);
        break;
      case Syntax.ClassExpression:
        checkClassExpressionDeferred(<ClassExpression>node);
        break;
      case Syntax.JsxSelfClosingElement:
        checkJsxSelfClosingElementDeferred(<JsxSelfClosingElement>node);
        break;
      case Syntax.JsxElement:
        checkJsxElementDeferred(<JsxElement>node);
        break;
    }
    currentNode = saveCurrentNode;
  }
  function checkSourceFile(node: SourceFile) {
    performance.mark('beforeCheck');
    checkSourceFileWorker(node);
    performance.mark('afterCheck');
    performance.measure('Check', 'beforeCheck', 'afterCheck');
  }
  function unusedIsError(kind: UnusedKind, isAmbient: boolean): boolean {
    if (isAmbient) return false;
    switch (kind) {
      case UnusedKind.Local:
        return !!compilerOptions.noUnusedLocals;
      case UnusedKind.Parameter:
        return !!compilerOptions.noUnusedParameters;
      default:
        return Debug.assertNever(kind);
    }
  }
  function getPotentiallyUnusedIdentifiers(sourceFile: SourceFile): readonly PotentiallyUnusedIdentifier[] {
    return allPotentiallyUnusedIdentifiers.get(sourceFile.path) || empty;
  }
  function checkSourceFileWorker(node: SourceFile) {
    const links = getNodeLinks(node);
    if (!(links.flags & NodeCheckFlags.TypeChecked)) {
      if (skipTypeChecking(node, compilerOptions, host)) return;
      checkGrammarSourceFile(node);
      clear(potentialThisCollisions);
      clear(potentialNewTargetCollisions);
      clear(potentialWeakMapCollisions);
      forEach(node.statements, checkSourceElement);
      checkSourceElement(node.endOfFileToken);
      checkDeferredNodes(node);
      if (isExternalOrCommonJsModule(node)) registerForUnusedIdentifiersCheck(node);
      if (!node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters)) {
        checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), (containingNode, kind, diag) => {
          if (!containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) diagnostics.add(diag);
        });
      }
      if (compilerOptions.importsNotUsedAsValues === ImportsNotUsedAsValues.Error && !node.isDeclarationFile && qp_isExternalModule(node)) checkImportsForTypeOnlyConversion(node);
      if (isExternalOrCommonJsModule(node)) checkExternalModuleExports(node);
      if (potentialThisCollisions.length) {
        forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);
        clear(potentialThisCollisions);
      }
      if (potentialNewTargetCollisions.length) {
        forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope);
        clear(potentialNewTargetCollisions);
      }
      if (potentialWeakMapCollisions.length) {
        forEach(potentialWeakMapCollisions, checkWeakMapCollision);
        clear(potentialWeakMapCollisions);
      }
      links.flags |= NodeCheckFlags.TypeChecked;
    }
  }
  function getDiagnostics(sourceFile: SourceFile, ct: CancellationToken): Diagnostic[] {
    try {
      cancellationToken = ct;
      return getDiagnosticsWorker(sourceFile);
    } finally {
      cancellationToken = undefined;
    }
  }
  function getDiagnosticsWorker(sourceFile: SourceFile): Diagnostic[] {
    throwIfNonDiagnosticsProducing();
    if (sourceFile) {
      const previousGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
      const previousGlobalDiagnosticsSize = previousGlobalqd.length;
      checkSourceFile(sourceFile);
      const semanticDiagnostics = diagnostics.getDiagnostics(sourceFile.fileName);
      const currentGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
      if (currentGlobalDiagnostics !== previousGlobalDiagnostics) {
        const deferredGlobalDiagnostics = relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics);
        return concatenate(deferredGlobalDiagnostics, semanticDiagnostics);
      } else if (previousGlobalDiagnosticsSize === 0 && currentGlobalqd.length > 0) {
        return concatenate(currentGlobalDiagnostics, semanticDiagnostics);
      }
      return semanticDiagnostics;
    }
    forEach(host.getSourceFiles(), checkSourceFile);
    return diagnostics.getDiagnostics();
  }
  function getGlobalDiagnostics(): Diagnostic[] {
    throwIfNonDiagnosticsProducing();
    return diagnostics.getGlobalDiagnostics();
  }
  function throwIfNonDiagnosticsProducing() {
    if (!produceDiagnostics) throw new Error('Trying to get diagnostics from a type checker that does not produce them.');
  }
  function getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[] {
    if (location.flags & NodeFlags.InWithStatement) return [];
    const symbols = new SymbolTable();
    let isStatic = false;
    populateSymbols();
    symbols.delete(InternalSymbolName.This);
    return symbolsToArray(symbols);
    function populateSymbols() {
      while (location) {
        if (location.locals && !isGlobalSourceFile(location)) location.locals.copy(symbols, meaning);
        switch (location.kind) {
          case Syntax.SourceFile:
            if (!isExternalOrCommonJsModule(<SourceFile>location)) break;
          case Syntax.ModuleDeclaration:
            getSymbolOfNode(location as ModuleDeclaration | SourceFile).exports!.copy(symbols, meaning & SymbolFlags.ModuleMember);
            break;
          case Syntax.EnumDeclaration:
            getSymbolOfNode(location as EnumDeclaration).exports!.copy(symbols, meaning & SymbolFlags.EnumMember);
            break;
          case Syntax.ClassExpression:
            const className = (location as ClassExpression).name;
            if (className) copySymbol(location.symbol, symbols, meaning);
          case Syntax.ClassDeclaration:
          case Syntax.InterfaceDeclaration:
            if (!isStatic) getMembersOfSymbol(getSymbolOfNode(location as ClassDeclaration | InterfaceDeclaration)).copy(symbols, meaning & SymbolFlags.Type);
            break;
          case Syntax.FunctionExpression:
            const funcName = (location as FunctionExpression).name;
            if (funcName) copySymbol(location.symbol, symbols, meaning);
            break;
        }
        if (introducesArgumentsExoticObject(location)) copySymbol(argumentsSymbol, symbols, meaning);
        isStatic = hasSyntacticModifier(location, ModifierFlags.Static);
        location = location.parent;
      }
      globals.copy(symbols, meaning);
    }
    function copySymbol(symbol: Symbol, to: SymbolTable, meaning: SymbolFlags) {
      if (getCombinedLocalAndExportSymbolFlags(symbol) & meaning) {
        const id = symbol.escName;
        if (!to.has(id)) to.set(id, symbol);
      }
    }
  }
  function isTypeReferenceIdentifier(node: EntityName): boolean {
    while (node.parent.kind === Syntax.QualifiedName) {
      node = node.parent as QualifiedName;
    }
    return node.parent.kind === Syntax.TypeReference;
  }
  function isHeritageClauseElementIdentifier(node: Node): boolean {
    while (node.parent.kind === Syntax.PropertyAccessExpression) {
      node = node.parent;
    }
    return node.parent.kind === Syntax.ExpressionWithTypeArguments;
  }
  function forEachEnclosingClass<T>(node: Node, callback: (node: Node) => T | undefined): T | undefined {
    let result: T | undefined;
    while (true) {
      node = qc.get.containingClass(node)!;
      if (!node) break;
      if ((result = callback(node))) break;
    }
    return result;
  }
  function isNodeUsedDuringClassInitialization(node: Node) {
    return !!Node.findAncestor(node, (element) => {
      if ((qc.is.kind(ConstructorDeclaration, element) && qc.is.present(element.body)) || qc.is.kind(PropertyDeclaration, element)) return true;
      else if (qc.is.classLike(element) || qc.is.functionLikeDeclaration(element)) return 'quit';
      return false;
    });
  }
  function isNodeWithinClass(node: Node, classDeclaration: ClassLikeDeclaration) {
    return !!forEachEnclosingClass(node, (n) => n === classDeclaration);
  }
  function getLeftSideOfImportEqualsOrExportAssignment(nodeOnRightSide: EntityName): ImportEqualsDeclaration | ExportAssignment | undefined {
    while (nodeOnRightSide.parent.kind === Syntax.QualifiedName) {
      nodeOnRightSide = <QualifiedName>nodeOnRightSide.parent;
    }
    if (nodeOnRightSide.parent.kind === Syntax.ImportEqualsDeclaration)
      return (<ImportEqualsDeclaration>nodeOnRightSide.parent).moduleReference === nodeOnRightSide ? <ImportEqualsDeclaration>nodeOnRightSide.parent : undefined;
    if (nodeOnRightSide.parent.kind === Syntax.ExportAssignment)
      return (<ExportAssignment>nodeOnRightSide.parent).expression === <Node>nodeOnRightSide ? <ExportAssignment>nodeOnRightSide.parent : undefined;
    return;
  }
  function isInRightSideOfImportOrExportAssignment(node: EntityName) {
    return getLeftSideOfImportEqualsOrExportAssignment(node) !== undefined;
  }
  function getSpecialPropertyAssignmentSymbolFromEntityName(entityName: EntityName | PropertyAccessExpression) {
    const specialPropertyAssignmentKind = getAssignmentDeclarationKind(entityName.parent.parent as BinaryExpression);
    switch (specialPropertyAssignmentKind) {
      case AssignmentDeclarationKind.ExportsProperty:
      case AssignmentDeclarationKind.PrototypeProperty:
        return getSymbolOfNode(entityName.parent);
      case AssignmentDeclarationKind.ThisProperty:
      case AssignmentDeclarationKind.ModuleExports:
      case AssignmentDeclarationKind.Property:
        return getSymbolOfNode(entityName.parent.parent);
    }
  }
  function isImportTypeQualifierPart(node: EntityName): ImportTypeNode | undefined {
    let parent = node.parent;
    while (qc.is.kind(QualifiedName, parent)) {
      node = parent;
      parent = parent.parent;
    }
    if (parent && parent.kind === Syntax.ImportType && (parent as ImportTypeNode).qualifier === node) return parent as ImportTypeNode;
    return;
  }
  function getSymbolOfNameOrPropertyAccessExpression(name: EntityName | PrivateIdentifier | PropertyAccessExpression): Symbol | undefined {
    if (qc.is.declarationName(name)) return getSymbolOfNode(name.parent);
    if (isInJSFile(name) && name.parent.kind === Syntax.PropertyAccessExpression && name.parent === (name.parent.parent as BinaryExpression).left) {
      if (!qc.is.kind(PrivateIdentifier, name)) {
        const specialPropertyAssignmentSymbol = getSpecialPropertyAssignmentSymbolFromEntityName(name);
        if (specialPropertyAssignmentSymbol) return specialPropertyAssignmentSymbol;
      }
    }
    if (name.parent.kind === Syntax.ExportAssignment && isEntityNameExpression(name)) {
      const success = resolveEntityName(name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, true);
      if (success && success !== unknownSymbol) return success;
    } else if (!qc.is.kind(PropertyAccessExpression, name) && !qc.is.kind(PrivateIdentifier, name) && isInRightSideOfImportOrExportAssignment(name)) {
      const importEqualsDeclaration = getAncestor(name, Syntax.ImportEqualsDeclaration);
      assert(importEqualsDeclaration !== undefined);
      return getSymbolOfPartOfRightHandSideOfImportEquals(name, true);
    }
    if (!qc.is.kind(PropertyAccessExpression, name) && !qc.is.kind(PrivateIdentifier, name)) {
      const possibleImportNode = isImportTypeQualifierPart(name);
      if (possibleImportNode) {
        getTypeFromTypeNode(possibleImportNode);
        const sym = getNodeLinks(name).resolvedSymbol;
        return sym === unknownSymbol ? undefined : sym;
      }
    }
    while (isRightSideOfQualifiedNameOrPropertyAccess(name)) {
      name = <QualifiedName | PropertyAccessEntityNameExpression>name.parent;
    }
    if (isHeritageClauseElementIdentifier(name)) {
      let meaning = SymbolFlags.None;
      if (name.parent.kind === Syntax.ExpressionWithTypeArguments) {
        meaning = SymbolFlags.Type;
        if (isExpressionWithTypeArgumentsInClassExtendsClause(name.parent)) meaning |= SymbolFlags.Value;
      } else {
        meaning = SymbolFlags.Namespace;
      }
      meaning |= SymbolFlags.Alias;
      const entityNameSymbol = isEntityNameExpression(name) ? resolveEntityName(name, meaning) : undefined;
      if (entityNameSymbol) return entityNameSymbol;
    }
    if (name.parent.kind === Syntax.JSDocParameterTag) return getParameterSymbolFromJSDoc(name.parent as JSDocParameterTag);
    if (name.parent.kind === Syntax.TypeParameter && name.parent.parent.kind === Syntax.JSDocTemplateTag) {
      assert(!isInJSFile(name));
      const typeParameter = getTypeParameterFromJsDoc(name.parent as TypeParameterDeclaration & { parent: JSDocTemplateTag });
      return typeParameter && typeParameter.symbol;
    }
    if (qc.is.expressionNode(name)) {
      if (qc.is.missing(name)) return;
      if (name.kind === Syntax.Identifier) {
        if (qc.isJsx.tagName(name) && isJsxIntrinsicIdentifier(name)) {
          const symbol = getIntrinsicTagSymbol(<JsxOpeningLikeElement>name.parent);
          return symbol === unknownSymbol ? undefined : symbol;
        }
        return resolveEntityName(name, SymbolFlags.Value, false, true);
      } else if (name.kind === Syntax.PropertyAccessExpression || name.kind === Syntax.QualifiedName) {
        const links = getNodeLinks(name);
        if (links.resolvedSymbol) return links.resolvedSymbol;
        if (name.kind === Syntax.PropertyAccessExpression) checkPropertyAccessExpression(name);
        else {
          checkQualifiedName(name);
        }
        return links.resolvedSymbol;
      }
    } else if (isTypeReferenceIdentifier(<EntityName>name)) {
      const meaning = name.parent.kind === Syntax.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace;
      return resolveEntityName(<EntityName>name, meaning, false, true);
    }
    if (name.parent.kind === Syntax.TypePredicate) return resolveEntityName(<Identifier>name, SymbolFlags.FunctionScopedVariable);
    return;
  }
  function getSymbolAtLocation(node: Node, ignoreErrors?: boolean): Symbol | undefined {
    if (node.kind === Syntax.SourceFile) return qp_isExternalModule(<SourceFile>node) ? getMergedSymbol(node.symbol) : undefined;
    const { parent } = node;
    const grandParent = parent.parent;
    if (node.flags & NodeFlags.InWithStatement) return;
    if (isDeclarationNameOrImportPropertyName(node)) {
      const parentSymbol = getSymbolOfNode(parent)!;
      return qc.is.importOrExportSpecifier(node.parent) && node.parent.propertyName === node ? getImmediateAliasedSymbol(parentSymbol) : parentSymbol;
    } else if (isLiteralComputedPropertyDeclarationName(node)) {
      return getSymbolOfNode(parent.parent);
    }
    if (node.kind === Syntax.Identifier) {
      if (isInRightSideOfImportOrExportAssignment(<Identifier>node)) return getSymbolOfNameOrPropertyAccessExpression(<Identifier>node);
      else if (parent.kind === Syntax.BindingElement && grandParent.kind === Syntax.ObjectBindingPattern && node === (<BindingElement>parent).propertyName) {
        const typeOfPattern = getTypeOfNode(grandParent);
        const propertyDeclaration = getPropertyOfType(typeOfPattern, (<Identifier>node).escapedText);
        if (propertyDeclaration) return propertyDeclaration;
      }
    }
    switch (node.kind) {
      case Syntax.Identifier:
      case Syntax.PrivateIdentifier:
      case Syntax.PropertyAccessExpression:
      case Syntax.QualifiedName:
        return getSymbolOfNameOrPropertyAccessExpression(<EntityName | PrivateIdentifier | PropertyAccessExpression>node);
      case Syntax.ThisKeyword:
        const container = qc.get.thisContainer(node, false);
        if (qc.is.functionLike(container)) {
          const sig = getSignatureFromDeclaration(container);
          if (sig.thisParameter) return sig.thisParameter;
        }
        if (qc.is.inExpressionContext(node)) return checkExpression(node as Expression).symbol;
      case Syntax.ThisType:
        return getTypeFromThisNodeTypeNode(node as ThisExpression | ThisTypeNode).symbol;
      case Syntax.SuperKeyword:
        return checkExpression(node as Expression).symbol;
      case Syntax.ConstructorKeyword:
        const constructorDeclaration = node.parent;
        if (constructorDeclaration && constructorDeclaration.kind === Syntax.Constructor) return (<ClassDeclaration>constructorDeclaration.parent).symbol;
        return;
      case Syntax.StringLiteral:
      case Syntax.NoSubstitutionLiteral:
        if (
          (qc.is.externalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node) ||
          ((node.parent.kind === Syntax.ImportDeclaration || node.parent.kind === Syntax.ExportDeclaration) && (<ImportDeclaration>node.parent).moduleSpecifier === node) ||
          (isInJSFile(node) && isRequireCall(node.parent, false)) ||
          qc.is.importCall(node.parent) ||
          (qc.is.kind(LiteralTypeNode, node.parent) && qc.is.literalImportTypeNode(node.parent.parent) && node.parent.parent.argument === node.parent)
        ) {
          return resolveExternalModuleName(node, <LiteralExpression>node, ignoreErrors);
        }
        if (qc.is.kind(CallExpression, parent) && isBindableObjectDefinePropertyCall(parent) && parent.arguments[1] === node) return getSymbolOfNode(parent);
      case Syntax.NumericLiteral:
        const objectType = qc.is.kind(ElementAccessExpression, parent)
          ? parent.argumentExpression === node
            ? getTypeOfExpression(parent.expression)
            : undefined
          : qc.is.kind(LiteralTypeNode, parent) && qc.is.kind(IndexedAccessTypeNode, grandParent)
          ? getTypeFromTypeNode(grandParent.objectType)
          : undefined;
        return objectType && getPropertyOfType(objectType, syntax.get.escUnderscores((node as StringLiteral | NumericLiteral).text));
      case Syntax.DefaultKeyword:
      case Syntax.FunctionKeyword:
      case Syntax.EqualsGreaterThanToken:
      case Syntax.ClassKeyword:
        return getSymbolOfNode(node.parent);
      case Syntax.ImportType:
        return qc.is.literalImportTypeNode(node) ? getSymbolAtLocation(node.argument.literal, ignoreErrors) : undefined;
      case Syntax.ExportKeyword:
        return qc.is.kind(ExportAssignment, node.parent) ? Debug.checkDefined(node.parent.symbol) : undefined;
      default:
        return;
    }
  }
  function getShorthandAssignmentValueSymbol(location: Node): Symbol | undefined {
    if (location && location.kind === Syntax.ShorthandPropertyAssignment) return resolveEntityName((<ShorthandPropertyAssignment>location).name, SymbolFlags.Value | SymbolFlags.Alias);
    return;
  }
  function getExportSpecifierLocalTargetSymbol(node: ExportSpecifier): Symbol | undefined {
    return node.parent.parent.moduleSpecifier
      ? getExternalModuleMember(node.parent.parent, node)
      : resolveEntityName(node.propertyName || node.name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias);
  }
  function getTypeOfNode(node: Node): Type {
    if (node.flags & NodeFlags.InWithStatement) return errorType;
    const classDecl = tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node);
    const classType = classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfNode(classDecl.class));
    if (qc.is.partOfTypeNode(node)) {
      const typeFromTypeNode = getTypeFromTypeNode(<TypeNode>node);
      return classType ? getTypeWithThisArgument(typeFromTypeNode, classType.thisType) : typeFromTypeNode;
    }
    if (qc.is.expressionNode(node)) return getRegularTypeOfExpression(<Expression>node);
    if (classType && !classDecl!.isImplements) {
      const baseType = firstOrUndefined(getBaseTypes(classType));
      return baseType ? getTypeWithThisArgument(baseType, classType.thisType) : errorType;
    }
    if (isTypeDeclaration(node)) {
      const symbol = getSymbolOfNode(node);
      return getDeclaredTypeOfSymbol(symbol);
    }
    if (isTypeDeclarationName(node)) {
      const symbol = getSymbolAtLocation(node);
      return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
    }
    if (qc.is.declaration(node)) {
      const symbol = getSymbolOfNode(node);
      return this.getTypeOfSymbol();
    }
    if (isDeclarationNameOrImportPropertyName(node)) {
      const symbol = getSymbolAtLocation(node);
      if (symbol) return this.getTypeOfSymbol();
      return errorType;
    }
    if (qc.is.kind(BindingPattern, node)) return getTypeForVariableLikeDeclaration(node.parent, true) || errorType;
    if (isInRightSideOfImportOrExportAssignment(<Identifier>node)) {
      const symbol = getSymbolAtLocation(node);
      if (symbol) {
        const declaredType = getDeclaredTypeOfSymbol(symbol);
        return declaredType !== errorType ? declaredType : this.getTypeOfSymbol();
      }
    }
    return errorType;
  }
  function getTypeOfAssignmentPattern(expr: AssignmentPattern): Type | undefined {
    assert(expr.kind === Syntax.ObjectLiteralExpression || expr.kind === Syntax.ArrayLiteralExpression);
    if (expr.parent.kind === Syntax.ForOfStatement) {
      const iteratedType = checkRightHandSideOfForOf(<ForOfStatement>expr.parent);
      return checkDestructuringAssignment(expr, iteratedType || errorType);
    }
    if (expr.parent.kind === Syntax.BinaryExpression) {
      const iteratedType = getTypeOfExpression((<BinaryExpression>expr.parent).right);
      return checkDestructuringAssignment(expr, iteratedType || errorType);
    }
    if (expr.parent.kind === Syntax.PropertyAssignment) {
      const node = cast(expr.parent.parent, isObjectLiteralExpression);
      const typeOfParentObjectLiteral = getTypeOfAssignmentPattern(node) || errorType;
      const propertyIndex = indexOfNode(node.properties, expr.parent);
      return checkObjectLiteralDestructuringPropertyAssignment(node, typeOfParentObjectLiteral, propertyIndex);
    }
    const node = cast(expr.parent, isArrayLiteralExpression);
    const typeOfArrayLiteral = getTypeOfAssignmentPattern(node) || errorType;
    const elementType = checkIteratedTypeOrElementType(IterationUse.Destructuring, typeOfArrayLiteral, undefinedType, expr.parent) || errorType;
    return checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral, node.elements.indexOf(expr), elementType);
  }
  function getPropertySymbolOfDestructuringAssignment(location: Identifier) {
    const typeOfObjectLiteral = getTypeOfAssignmentPattern(cast(location.parent.parent, isAssignmentPattern));
    return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.escapedText);
  }
  function getRegularTypeOfExpression(expr: Expression): Type {
    if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) expr = <Expression>expr.parent;
    return getRegularTypeOfLiteralType(getTypeOfExpression(expr));
  }
  function getParentTypeOfClassElement(node: ClassElement) {
    const classSymbol = getSymbolOfNode(node.parent)!;
    return hasSyntacticModifier(node, ModifierFlags.Static) ? getTypeOfSymbol(classSymbol) : getDeclaredTypeOfSymbol(classSymbol);
  }
  function getClassElementPropertyKeyType(element: ClassElement) {
    const name = element.name!;
    switch (name.kind) {
      case Syntax.Identifier:
        return getLiteralType(idText(name));
      case Syntax.NumericLiteral:
      case Syntax.StringLiteral:
        return getLiteralType(name.text);
      case Syntax.ComputedPropertyName:
        const nameType = checkComputedPropertyName(name);
        return isTypeAssignableToKind(nameType, TypeFlags.ESSymbolLike) ? nameType : stringType;
      default:
        return fail('Unsupported property name.');
    }
  }
  function getAugmentedPropertiesOfType(type: Type): Symbol[] {
    type = getApparentType(type);
    const propsByName = new SymbolTable(getPropertiesOfType(type));
    const functionType = getSignaturesOfType(type, SignatureKind.Call).length
      ? globalCallableFunctionType
      : getSignaturesOfType(type, SignatureKind.Construct).length
      ? globalNewableFunctionType
      : undefined;
    if (functionType) {
      forEach(getPropertiesOfType(functionType), (p) => {
        if (!propsByName.has(p.escName)) propsByName.set(p.escName, p);
      });
    }
    return getNamedMembers(propsByName);
  }
  function typeHasCallOrConstructSignatures(type: Type): boolean {
    return qnr.typeHasCallOrConstructSignatures(type, checker);
  }
  function isArgumentsLocalBinding(nodeIn: Identifier): boolean {
    if (!qc.is.generatedIdentifier(nodeIn)) {
      const node = qc.get.parseTreeOf(nodeIn, isIdentifier);
      if (node) {
        const isPropertyName = node.parent.kind === Syntax.PropertyAccessExpression && (<PropertyAccessExpression>node.parent).name === node;
        return !isPropertyName && getReferencedValueSymbol(node) === argumentsSymbol;
      }
    }
    return false;
  }
  function moduleExportsSomeValue(moduleReferenceExpression: Expression): boolean {
    let moduleSymbol = resolveExternalModuleName(moduleReferenceExpression.parent, moduleReferenceExpression);
    if (!moduleSymbol || isShorthandAmbientModuleSymbol(moduleSymbol)) return true;
    const hasExportAssignment = hasExportAssignmentSymbol(moduleSymbol);
    moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
    const symbolLinks = s.getLinks(moduleSymbol);
    if (symbolLinks.exportsSomeValue === undefined)
      symbolLinks.exportsSomeValue = hasExportAssignment ? !!(moduleSymbol.flags & SymbolFlags.Value) : forEachEntry(getExportsOfModule(moduleSymbol), isValue);
    return symbolLinks.exportsSomeValue!;
    function isValue(s: Symbol): boolean {
      s = s.resolveSymbol();
      return s && !!(s.flags & SymbolFlags.Value);
    }
  }
  function isNameOfModuleOrEnumDeclaration(node: Identifier) {
    return qc.is.moduleOrEnumDeclaration(node.parent) && node === node.parent.name;
  }
  function getReferencedExportContainer(nodeIn: Identifier, prefixLocals?: boolean): SourceFile | ModuleDeclaration | EnumDeclaration | undefined {
    const node = qc.get.parseTreeOf(nodeIn, isIdentifier);
    if (node) {
      let symbol = getReferencedValueSymbol(node, isNameOfModuleOrEnumDeclaration(node));
      if (symbol) {
        if (symbol.flags & SymbolFlags.ExportValue) {
          const exportSymbol = getMergedSymbol(symbol.exportSymbol!);
          if (!prefixLocals && exportSymbol.flags & SymbolFlags.ExportHasLocal && !(exportSymbol.flags & SymbolFlags.Variable)) return;
          symbol = exportSymbol;
        }
        const parentSymbol = getParentOfSymbol(symbol);
        if (parentSymbol) {
          if (parentSymbol.flags & SymbolFlags.ValueModule && parentSymbol.valueDeclaration.kind === Syntax.SourceFile) {
            const symbolFile = <SourceFile>parentSymbol.valueDeclaration;
            const referenceFile = qc.get.sourceFileOf(node);
            const symbolIsUmdExport = symbolFile !== referenceFile;
            return symbolIsUmdExport ? undefined : symbolFile;
          }
          return Node.findAncestor(node.parent, (n): n is ModuleDeclaration | EnumDeclaration => qc.is.moduleOrEnumDeclaration(n) && getSymbolOfNode(n) === parentSymbol);
        }
      }
    }
  }
  function getReferencedImportDeclaration(nodeIn: Identifier): Declaration | undefined {
    const node = qc.get.parseTreeOf(nodeIn, isIdentifier);
    if (node) {
      const symbol = getReferencedValueSymbol(node);
      if (symbol.isNonLocalAlias(SymbolFlags.Value) && !this.getTypeOnlyAliasDeclaration()) return symbol.getDeclarationOfAliasSymbol();
    }
    return;
  }
  function getReferencedDeclarationWithCollidingName(nodeIn: Identifier): Declaration | undefined {
    if (!qc.is.generatedIdentifier(nodeIn)) {
      const node = qc.get.parseTreeOf(nodeIn, isIdentifier);
      if (node) {
        const symbol = getReferencedValueSymbol(node);
        if (symbol && isSymbolOfDeclarationWithCollidingName(symbol)) return symbol.valueDeclaration;
      }
    }
    return;
  }
  function isDeclarationWithCollidingName(nodeIn: Declaration): boolean {
    const node = qc.get.parseTreeOf(nodeIn, isDeclaration);
    if (node) {
      const symbol = getSymbolOfNode(node);
      if (symbol) return isSymbolOfDeclarationWithCollidingName(symbol);
    }
    return false;
  }
  function isValueAliasDeclaration(node: Node): boolean {
    switch (node.kind) {
      case Syntax.ImportEqualsDeclaration:
        return isAliasResolvedToValue(getSymbolOfNode(node) || unknownSymbol);
      case Syntax.ImportClause:
      case Syntax.NamespaceImport:
      case Syntax.ImportSpecifier:
      case Syntax.ExportSpecifier:
        const symbol = getSymbolOfNode(node) || unknownSymbol;
        return isAliasResolvedToValue(symbol) && !this.getTypeOnlyAliasDeclaration();
      case Syntax.ExportDeclaration:
        const exportClause = (<ExportDeclaration>node).exportClause;
        return !!exportClause && (qc.is.kind(NamespaceExport, exportClause) || some(exportClause.elements, isValueAliasDeclaration));
      case Syntax.ExportAssignment:
        return (<ExportAssignment>node).expression && (<ExportAssignment>node).expression.kind === Syntax.Identifier ? isAliasResolvedToValue(getSymbolOfNode(node) || unknownSymbol) : true;
    }
    return false;
  }
  function isTopLevelValueImportEqualsWithEntityName(nodeIn: ImportEqualsDeclaration): boolean {
    const node = qc.get.parseTreeOf(nodeIn, isImportEqualsDeclaration);
    if (node === undefined || node.parent.kind !== Syntax.SourceFile || !isInternalModuleImportEqualsDeclaration(node)) return false;
    const isValue = isAliasResolvedToValue(getSymbolOfNode(node));
    return isValue && node.moduleReference && !qc.is.missing(node.moduleReference);
  }
  function isReferencedAliasDeclaration(node: Node, checkChildren?: boolean): boolean {
    if (isAliasSymbolDeclaration(node)) {
      const symbol = getSymbolOfNode(node);
      if (symbol && s.getLinks(symbol).referenced) return true;
      const target = s.getLinks(symbol!).target;
      if (target && getEffectiveModifierFlags(node) & ModifierFlags.Export && target.flags & SymbolFlags.Value && (compilerOptions.preserveConstEnums || !isConstEnumOrConstEnumOnlyModule(target)))
        return true;
    }
    if (checkChildren) return !!qc.forEach.child(node, (node) => isReferencedAliasDeclaration(node, checkChildren));
    return false;
  }
  function isImplementationOfOverload(node: SignatureDeclaration) {
    if (qc.is.present((node as FunctionLikeDeclaration).body)) {
      if (qc.is.kind(GetAccessorDeclaration, node) || qc.is.kind(SetAccessorDeclaration, node)) return false;
      const symbol = getSymbolOfNode(node);
      const signaturesOfSymbol = getSignaturesOfSymbol(symbol);
      return signaturesOfSymbol.length > 1 || (signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node);
    }
    return false;
  }
  function isRequiredInitializedParameter(parameter: ParameterDeclaration | JSDocParameterTag): boolean {
    return (
      !!strictNullChecks &&
      !isOptionalParameter(parameter) &&
      !qc.is.kind(JSDocParameterTag, parameter) &&
      !!parameter.initializer &&
      !hasSyntacticModifier(parameter, ModifierFlags.ParameterPropertyModifier)
    );
  }
  function isOptionalUninitializedParameterProperty(parameter: ParameterDeclaration) {
    return strictNullChecks && isOptionalParameter(parameter) && !parameter.initializer && hasSyntacticModifier(parameter, ModifierFlags.ParameterPropertyModifier);
  }
  function isExpandoFunctionDeclaration(node: Declaration): boolean {
    const declaration = qc.get.parseTreeOf(node, isFunctionDeclaration);
    if (!declaration) return false;
    const symbol = getSymbolOfNode(declaration);
    if (!symbol || !(symbol.flags & SymbolFlags.Function)) return false;
    return !!forEachEntry(this.getExportsOfSymbol(), (p) => p.flags & SymbolFlags.Value && p.valueDeclaration && qc.is.kind(PropertyAccessExpression, p.valueDeclaration));
  }
  function getPropertiesOfContainerFunction(node: Declaration): Symbol[] {
    const declaration = qc.get.parseTreeOf(node, isFunctionDeclaration);
    if (!declaration) return empty;
    const symbol = getSymbolOfNode(declaration);
    return (symbol && getPropertiesOfType(this.getTypeOfSymbol())) || empty;
  }
  function getNodeCheckFlags(node: Node): NodeCheckFlags {
    return getNodeLinks(node).flags || 0;
  }
  function getEnumMemberValue(node: EnumMember): string | number | undefined {
    computeEnumMemberValues(node.parent);
    return getNodeLinks(node).enumMemberValue;
  }
  function canHaveConstantValue(node: Node): node is EnumMember | AccessExpression {
    switch (node.kind) {
      case Syntax.EnumMember:
      case Syntax.PropertyAccessExpression:
      case Syntax.ElementAccessExpression:
        return true;
    }
    return false;
  }
  function getConstantValue(node: EnumMember | AccessExpression): string | number | undefined {
    if (node.kind === Syntax.EnumMember) return getEnumMemberValue(node);
    const symbol = getNodeLinks(node).resolvedSymbol;
    if (symbol && symbol.flags & SymbolFlags.EnumMember) {
      const member = symbol.valueDeclaration as EnumMember;
      if (isEnumConst(member.parent)) return getEnumMemberValue(member);
    }
    return;
  }
  function isFunctionType(type: Type): boolean {
    return !!(type.flags & TypeFlags.Object) && getSignaturesOfType(type, SignatureKind.Call).length > 0;
  }
  function getTypeReferenceSerializationKind(typeNameIn: EntityName, location?: Node): TypeReferenceSerializationKind {
    const typeName = qc.get.parseTreeOf(typeNameIn, isEntityName);
    if (!typeName) return TypeReferenceSerializationKind.Unknown;
    if (location) {
      location = qc.get.parseTreeOf(location);
      if (!location) return TypeReferenceSerializationKind.Unknown;
    }
    const valueSymbol = resolveEntityName(typeName, SymbolFlags.Value, true, false, location);
    const typeSymbol = resolveEntityName(typeName, SymbolFlags.Type, true, false, location);
    if (valueSymbol && valueSymbol === typeSymbol) {
      const globalPromiseSymbol = getGlobalPromiseConstructorSymbol(false);
      if (globalPromiseSymbol && valueSymbol === globalPromiseSymbol) return TypeReferenceSerializationKind.Promise;
      const constructorType = getTypeOfSymbol(valueSymbol);
      if (constructorType && isConstructorType(constructorType)) return TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue;
    }
    if (!typeSymbol) return TypeReferenceSerializationKind.Unknown;
    const type = getDeclaredTypeOfSymbol(typeSymbol);
    if (type === errorType) return TypeReferenceSerializationKind.Unknown;
    if (type.flags & TypeFlags.AnyOrUnknown) return TypeReferenceSerializationKind.ObjectType;
    if (isTypeAssignableToKind(type, TypeFlags.Void | TypeFlags.Nullable | TypeFlags.Never)) return TypeReferenceSerializationKind.VoidNullableOrNeverType;
    if (isTypeAssignableToKind(type, TypeFlags.BooleanLike)) return TypeReferenceSerializationKind.BooleanType;
    if (isTypeAssignableToKind(type, TypeFlags.NumberLike)) return TypeReferenceSerializationKind.NumberLikeType;
    if (isTypeAssignableToKind(type, TypeFlags.BigIntLike)) return TypeReferenceSerializationKind.BigIntLikeType;
    if (isTypeAssignableToKind(type, TypeFlags.StringLike)) return TypeReferenceSerializationKind.StringLikeType;
    if (isTupleType(type)) return TypeReferenceSerializationKind.ArrayLikeType;
    if (isTypeAssignableToKind(type, TypeFlags.ESSymbolLike)) return TypeReferenceSerializationKind.ESSymbolType;
    if (isFunctionType(type)) return TypeReferenceSerializationKind.TypeWithCallSignature;
    if (isArrayType(type)) return TypeReferenceSerializationKind.ArrayLikeType;
    return TypeReferenceSerializationKind.ObjectType;
  }
  function createTypeOfDeclaration(
    declarationIn: AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression,
    enclosingDeclaration: Node,
    flags: NodeBuilderFlags,
    tracker: SymbolTracker,
    addUndefined?: boolean
  ) {
    const declaration = qc.get.parseTreeOf(declarationIn, isVariableLikeOrAccessor);
    if (!declaration) return new Token(Syntax.AnyKeyword) as KeywordTypeNode;
    const symbol = getSymbolOfNode(declaration);
    let type = symbol && !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.Signature)) ? getWidenedLiteralType(this.getTypeOfSymbol()) : errorType;
    if (type.flags & TypeFlags.UniqueESSymbol && type.symbol === symbol) flags |= NodeBuilderFlags.AllowUniqueESSymbolType;
    if (addUndefined) type = getOptionalType(type);
    return nodeBuilder.typeToTypeNode(type, enclosingDeclaration, flags | NodeBuilderFlags.MultilineObjectLiterals, tracker);
  }
  function createReturnTypeOfSignatureDeclaration(signatureDeclarationIn: SignatureDeclaration, enclosingDeclaration: Node, flags: NodeBuilderFlags, tracker: SymbolTracker) {
    const signatureDeclaration = qc.get.parseTreeOf(signatureDeclarationIn, isFunctionLike);
    if (!signatureDeclaration) return new Token(Syntax.AnyKeyword) as KeywordTypeNode;
    const signature = getSignatureFromDeclaration(signatureDeclaration);
    return nodeBuilder.typeToTypeNode(getReturnTypeOfSignature(signature), enclosingDeclaration, flags | NodeBuilderFlags.MultilineObjectLiterals, tracker);
  }
  function createTypeOfExpression(exprIn: Expression, enclosingDeclaration: Node, flags: NodeBuilderFlags, tracker: SymbolTracker) {
    const expr = qc.get.parseTreeOf(exprIn, isExpression);
    if (!expr) return new Token(Syntax.AnyKeyword) as KeywordTypeNode;
    const type = getWidenedType(getRegularTypeOfExpression(expr));
    return nodeBuilder.typeToTypeNode(type, enclosingDeclaration, flags | NodeBuilderFlags.MultilineObjectLiterals, tracker);
  }
  function hasGlobalName(name: string): boolean {
    return globals.has(syntax.get.escUnderscores(name));
  }
  function getReferencedValueSymbol(reference: Identifier, startInDeclarationContainer?: boolean): Symbol | undefined {
    const resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
    if (resolvedSymbol) return resolvedSymbol;
    let location: Node = reference;
    if (startInDeclarationContainer) {
      const parent = reference.parent;
      if (qc.is.declaration(parent) && reference === parent.name) location = getDeclarationContainer(parent);
    }
    return resolveName(location, reference.escapedText, SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias, undefined, undefined, true);
  }
  function getReferencedValueDeclaration(referenceIn: Identifier): Declaration | undefined {
    if (!qc.is.generatedIdentifier(referenceIn)) {
      const reference = qc.get.parseTreeOf(referenceIn, isIdentifier);
      if (reference) {
        const symbol = getReferencedValueSymbol(reference);
        if (symbol) return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration;
      }
    }
    return;
  }
  function isLiteralConstDeclaration(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration): boolean {
    if (isDeclarationReadonly(node) || (qc.is.kind(VariableDeclaration, node) && isVarConst(node))) return isFreshLiteralType(getTypeOfSymbol(getSymbolOfNode(node)));
    return false;
  }
  function literalTypeToNode(type: FreshableType, enclosing: Node, tracker: SymbolTracker): Expression {
    const enumResult =
      type.flags & TypeFlags.EnumLiteral
        ? nodeBuilder.symbolToExpression(type.symbol, SymbolFlags.Value, enclosing, undefined, tracker)
        : type === trueType
        ? new qc.BooleanLiteral(true)
        : type === falseType && new qc.BooleanLiteral(false);
    return enumResult || qc.asLiteral((type as LiteralType).value);
  }
  function createLiteralConstValue(node: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration, tracker: SymbolTracker) {
    const type = getTypeOfSymbol(getSymbolOfNode(node));
    return literalTypeToNode(<FreshableType>type, node, tracker);
  }
  function getJsxFactoryEntity(location: Node) {
    return location ? (getJsxNamespace(location), qc.get.sourceFileOf(location).localJsxFactory || _jsxFactoryEntity) : _jsxFactoryEntity;
  }
  function createResolver(): EmitResolver {
    const resolvedTypeReferenceDirectives = host.getResolvedTypeReferenceDirectives();
    let fileToDirective: qb.QMap<string>;
    if (resolvedTypeReferenceDirectives) {
      fileToDirective = new qb.QMap<string>();
      resolvedTypeReferenceDirectives.forEach((resolvedDirective, key) => {
        if (!resolvedDirective || !resolvedDirective.resolvedFileName) return;
        const file = host.getSourceFile(resolvedDirective.resolvedFileName);
        if (file) addReferencedFilesToTypeDirective(file, key);
      });
    }
    return {
      getReferencedExportContainer,
      getReferencedImportDeclaration,
      getReferencedDeclarationWithCollidingName,
      isDeclarationWithCollidingName,
      isValueAliasDeclaration: (node) => {
        node = qc.get.parseTreeOf(node);
        return node ? isValueAliasDeclaration(node) : true;
      },
      hasGlobalName,
      isReferencedAliasDeclaration: (node, checkChildren?) => {
        node = qc.get.parseTreeOf(node);
        return node ? isReferencedAliasDeclaration(node, checkChildren) : true;
      },
      getNodeCheckFlags: (node) => {
        node = qc.get.parseTreeOf(node);
        return node ? getNodeCheckFlags(node) : 0;
      },
      isTopLevelValueImportEqualsWithEntityName,
      isDeclarationVisible,
      isImplementationOfOverload,
      isRequiredInitializedParameter,
      isOptionalUninitializedParameterProperty,
      isExpandoFunctionDeclaration,
      getPropertiesOfContainerFunction,
      createTypeOfDeclaration,
      createReturnTypeOfSignatureDeclaration,
      createTypeOfExpression,
      createLiteralConstValue,
      isSymbolAccessible,
      isEntityNameVisible,
      getConstantValue: (nodeIn) => {
        const node = qc.get.parseTreeOf(nodeIn, canHaveConstantValue);
        return node ? getConstantValue(node) : undefined;
      },
      collectLinkedAliases,
      getReferencedValueDeclaration,
      getTypeReferenceSerializationKind,
      isOptionalParameter,
      moduleExportsSomeValue,
      isArgumentsLocalBinding,
      getExternalModuleFileFromDeclaration,
      getTypeReferenceDirectivesForEntityName,
      getTypeReferenceDirectivesForSymbol,
      isLiteralConstDeclaration,
      isLateBound: (nodeIn: Declaration): nodeIn is LateBoundDeclaration => {
        const node = qc.get.parseTreeOf(nodeIn, isDeclaration);
        const symbol = node && getSymbolOfNode(node);
        return !!(symbol && this.getCheckFlags() & CheckFlags.Late);
      },
      getJsxFactoryEntity,
      getAllAccessorDeclarations(accessor: AccessorDeclaration): AllAccessorDeclarations {
        accessor = qc.get.parseTreeOf(accessor, GetAccessorDeclaration.orSetKind)!;
        const otherKind = accessor.kind === Syntax.SetAccessor ? Syntax.GetAccessor : Syntax.SetAccessor;
        const otherAccessor = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfNode(accessor), otherKind);
        const firstAccessor = otherAccessor && otherAccessor.pos < accessor.pos ? otherAccessor : accessor;
        const secondAccessor = otherAccessor && otherAccessor.pos < accessor.pos ? accessor : otherAccessor;
        const setAccessor = accessor.kind === Syntax.SetAccessor ? accessor : (otherAccessor as SetAccessorDeclaration);
        const getAccessor = accessor.kind === Syntax.GetAccessor ? accessor : (otherAccessor as GetAccessorDeclaration);
        return {
          firstAccessor,
          secondAccessor,
          setAccessor,
          getAccessor,
        };
      },
      getSymbolOfExternalModuleSpecifier: (moduleName) => resolveExternalModuleNameWorker(moduleName, moduleName, undefined),
      isBindingCapturedByNode: (node, decl) => {
        const parseNode = qc.get.parseTreeOf(node);
        const parseDecl = qc.get.parseTreeOf(decl);
        return !!parseNode && !!parseDecl && (qc.is.kind(VariableDeclaration, parseDecl) || qc.is.kind(BindingElement, parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl);
      },
      getDeclarationStatementsForSourceFile: (node, flags, tracker, bundled) => {
        const n = qc.get.parseTreeOf(node) as SourceFile;
        assert(n && n.kind === Syntax.SourceFile, 'Non-sourcefile node passed into getDeclarationsForSourceFile');
        const sym = getSymbolOfNode(node);
        if (!sym) return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, tracker, bundled);
        return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, tracker, bundled);
      },
      isImportRequiredByAugmentation,
    };
    function isImportRequiredByAugmentation(node: ImportDeclaration) {
      const file = qc.get.sourceFileOf(node);
      if (!file.symbol) return false;
      const importTarget = getExternalModuleFileFromDeclaration(node);
      if (!importTarget) return false;
      if (importTarget === file) return false;
      const exports = getExportsOfModule(file.symbol);
      for (const s of arrayFrom(exports.values())) {
        if (s.mergeId) {
          const merged = getMergedSymbol(s);
          for (const d of merged.declarations) {
            const declFile = qc.get.sourceFileOf(d);
            if (declFile === importTarget) return true;
          }
        }
      }
      return false;
    }
    function isInHeritageClause(node: PropertyAccessEntityNameExpression) {
      return node.parent && node.parent.kind === Syntax.ExpressionWithTypeArguments && node.parent.parent && node.parent.parent.kind === Syntax.HeritageClause;
    }
    function getTypeReferenceDirectivesForEntityName(node: EntityNameOrEntityNameExpression): string[] | undefined {
      if (!fileToDirective) return;
      let meaning = SymbolFlags.Type | SymbolFlags.Namespace;
      if ((node.kind === Syntax.Identifier && isInTypeQuery(node)) || (node.kind === Syntax.PropertyAccessExpression && !isInHeritageClause(node)))
        meaning = SymbolFlags.Value | SymbolFlags.ExportValue;
      const symbol = resolveEntityName(node, meaning, true);
      return symbol && symbol !== unknownSymbol ? getTypeReferenceDirectivesForSymbol(symbol, meaning) : undefined;
    }
    function addReferencedFilesToTypeDirective(file: SourceFile, key: string) {
      if (fileToDirective.has(file.path)) return;
      fileToDirective.set(file.path, key);
      for (const { fileName } of file.referencedFiles) {
        const resolvedFile = resolveTripleslashReference(fileName, file.originalFileName);
        const referencedFile = host.getSourceFile(resolvedFile);
        if (referencedFile) addReferencedFilesToTypeDirective(referencedFile, key);
      }
    }
  }
  function getExternalModuleFileFromDeclaration(declaration: AnyImportOrReExport | ModuleDeclaration | ImportTypeNode): SourceFile | undefined {
    const specifier = declaration.kind === Syntax.ModuleDeclaration ? tryCast(declaration.name, isStringLiteral) : getExternalModuleName(declaration);
    const moduleSymbol = resolveExternalModuleNameWorker(specifier!, specifier!, undefined);
    if (!moduleSymbol) return;
    return getDeclarationOfKind(moduleSymbol, Syntax.SourceFile);
  }
  function initializeTypeChecker() {
    for (const file of host.getSourceFiles()) {
      bindSourceFile(file, compilerOptions);
    }
    amalgamatedDuplicates = new qb.QMap();
    let augmentations: (readonly (StringLiteral | Identifier)[])[] | undefined;
    for (const file of host.getSourceFiles()) {
      if (file.redirectInfo) continue;
      if (!isExternalOrCommonJsModule(file)) {
        const fileGlobalThisSymbol = file.locals!.get('globalThis' as __String);
        if (fileGlobalThisSymbol) {
          for (const declaration of fileGlobalThisSymbol.declarations) {
            diagnostics.add(createDiagnosticForNode(declaration, qd.Declaration_name_conflicts_with_built_in_global_identifier_0, 'globalThis'));
          }
        }
        globals.merge(file.locals!);
      }
      if (file.jsGlobalAugmentations) globals.merge(file.jsGlobalAugmentations);
      if (file.patternAmbientModules && file.patternAmbientModules.length) patternAmbientModules = concatenate(patternAmbientModules, file.patternAmbientModules);
      if (file.moduleAugmentations.length) (augmentations || (augmentations = [])).push(file.moduleAugmentations);
      if (file.symbol && file.symbol.globalExports) {
        const source = file.symbol.globalExports;
        source.forEach((sourceSymbol, id) => {
          if (!globals.has(id)) globals.set(id, sourceSymbol);
        });
      }
    }
    if (augmentations) {
      for (const list of augmentations) {
        for (const augmentation of list) {
          if (!isGlobalScopeAugmentation(augmentation.parent as ModuleDeclaration)) continue;
          mergeModuleAugmentation(augmentation);
        }
      }
    }
    globals.add(builtinGlobals, qd.Declaration_name_conflicts_with_built_in_global_identifier_0);
    s.getLinks(undefinedSymbol).type = undefinedWideningType;
    s.getLinks(argumentsSymbol).type = getGlobalType('IArguments' as __String, 0, true);
    s.getLinks(unknownSymbol).type = errorType;
    s.getLinks(globalThisSymbol).type = createObjectType(ObjectFlags.Anonymous, globalThisSymbol);
    globalArrayType = getGlobalType('Array' as __String, 1, true);
    globalObjectType = getGlobalType('Object' as __String, 0, true);
    globalFunctionType = getGlobalType('Function' as __String, 0, true);
    globalCallableFunctionType = (strictBindCallApply && getGlobalType('CallableFunction' as __String, 0, true)) || globalFunctionType;
    globalNewableFunctionType = (strictBindCallApply && getGlobalType('NewableFunction' as __String, 0, true)) || globalFunctionType;
    globalStringType = getGlobalType('String' as __String, 0, true);
    globalNumberType = getGlobalType('Number' as __String, 0, true);
    globalBooleanType = getGlobalType('Boolean' as __String, 0, true);
    globalRegExpType = getGlobalType('RegExp' as __String, 0, true);
    anyArrayType = createArrayType(anyType);
    autoArrayType = createArrayType(autoType);
    if (autoArrayType === emptyObjectType) autoArrayType = createAnonymousType(undefined, emptySymbols, empty, empty, undefined, undefined);
    globalReadonlyArrayType = <GenericType>getGlobalTypeOrUndefined('ReadonlyArray' as __String, 1) || globalArrayType;
    anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType;
    globalThisType = <GenericType>getGlobalTypeOrUndefined('ThisType' as __String, 1);
    if (augmentations) {
      for (const list of augmentations) {
        for (const augmentation of list) {
          if (isGlobalScopeAugmentation(augmentation.parent as ModuleDeclaration)) continue;
          mergeModuleAugmentation(augmentation);
        }
      }
    }
    amalgamatedDuplicates.forEach(({ firstFile, secondFile, conflictingSymbols }) => {
      if (conflictingSymbols.size < 8) {
        conflictingSymbols.forEach(({ isBlockScoped, firstFileLocations, secondFileLocations }, symbolName) => {
          const message = isBlockScoped ? qd.Cannot_redeclare_block_scoped_variable_0 : qd.Duplicate_identifier_0;
          for (const node of firstFileLocations) {
            addDuplicateDeclarationError(node, message, symbolName, secondFileLocations);
          }
          for (const node of secondFileLocations) {
            addDuplicateDeclarationError(node, message, symbolName, firstFileLocations);
          }
        });
      } else {
        const list = arrayFrom(conflictingSymbols.keys()).join(', ');
        diagnostics.add(
          addRelatedInfo(
            createDiagnosticForNode(firstFile, qd.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list),
            createDiagnosticForNode(secondFile, qd.Conflicts_are_in_this_file)
          )
        );
        diagnostics.add(
          addRelatedInfo(
            createDiagnosticForNode(secondFile, qd.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list),
            createDiagnosticForNode(firstFile, qd.Conflicts_are_in_this_file)
          )
        );
      }
    });
    amalgamatedDuplicates = undefined;
  }
  function checkExternalEmitHelpers(location: Node, helpers: ExternalEmitHelpers) {
    if ((requestedExternalEmitHelpers & helpers) !== helpers && compilerOptions.importHelpers) {
      const sourceFile = qc.get.sourceFileOf(location);
      if (isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & NodeFlags.Ambient)) {
        const helpersModule = resolveHelpersModule(sourceFile, location);
        if (helpersModule !== unknownSymbol) {
          const uncheckedHelpers = helpers & ~requestedExternalEmitHelpers;
          for (let helper = ExternalEmitHelpers.FirstEmitHelper; helper <= ExternalEmitHelpers.LastEmitHelper; helper <<= 1) {
            if (uncheckedHelpers & helper) {
              const name = getHelperName(helper);
              const symbol = getSymbol(helpersModule.exports!, syntax.get.escUnderscores(name), SymbolFlags.Value);
              if (!symbol) error(location, qd.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name);
            }
          }
        }
        requestedExternalEmitHelpers |= helpers;
      }
    }
  }
  function getHelperName(helper: ExternalEmitHelpers) {
    switch (helper) {
      case ExternalEmitHelpers.Extends:
        return '__extends';
      case ExternalEmitHelpers.Assign:
        return '__assign';
      case ExternalEmitHelpers.Rest:
        return '__rest';
      case ExternalEmitHelpers.Decorate:
        return '__decorate';
      case ExternalEmitHelpers.Metadata:
        return '__metadata';
      case ExternalEmitHelpers.Param:
        return '__param';
      case ExternalEmitHelpers.Awaiter:
        return '__awaiter';
      case ExternalEmitHelpers.Generator:
        return '__generator';
      case ExternalEmitHelpers.Values:
        return '__values';
      case ExternalEmitHelpers.Read:
        return '__read';
      case ExternalEmitHelpers.Spread:
        return '__spread';
      case ExternalEmitHelpers.SpreadArrays:
        return '__spreadArrays';
      case ExternalEmitHelpers.Await:
        return '__await';
      case ExternalEmitHelpers.AsyncGenerator:
        return '__asyncGenerator';
      case ExternalEmitHelpers.AsyncDelegator:
        return '__asyncDelegator';
      case ExternalEmitHelpers.AsyncValues:
        return '__asyncValues';
      case ExternalEmitHelpers.ExportStar:
        return '__exportStar';
      case ExternalEmitHelpers.MakeTemplateObject:
        return '__makeTemplateObject';
      case ExternalEmitHelpers.ClassPrivateFieldGet:
        return '__classPrivateFieldGet';
      case ExternalEmitHelpers.ClassPrivateFieldSet:
        return '__classPrivateFieldSet';
      case ExternalEmitHelpers.CreateBinding:
        return '__createBinding';
      default:
        return fail('Unrecognized helper');
    }
  }
  function resolveHelpersModule(node: SourceFile, errorNode: Node) {
    if (!externalHelpersModule)
      externalHelpersModule = resolveExternalModule(node, externalHelpersModuleNameText, qd.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol;
    return externalHelpersModule;
  }
  function checkGrammarDecoratorsAndModifiers(node: Node): boolean {
    return checkGrammarDecorators(node) || checkGrammarModifiers(node);
  }
  function checkGrammarDecorators(node: Node): boolean {
    if (!node.decorators) return false;
    if (!nodeCanBeDecorated(node, node.parent, node.parent.parent)) {
      if (node.kind === Syntax.MethodDeclaration && !qc.is.present((<MethodDeclaration>node).body))
        return grammarErrorOnFirstToken(node, qd.A_decorator_can_only_decorate_a_method_implementation_not_an_overload);
      return grammarErrorOnFirstToken(node, qd.Decorators_are_not_valid_here);
    } else if (node.kind === Syntax.GetAccessor || node.kind === Syntax.SetAccessor) {
      const accessors = getAllAccessorDeclarations((<ClassDeclaration>node.parent).members, <AccessorDeclaration>node);
      if (accessors.firstAccessor.decorators && node === accessors.secondAccessor)
        return grammarErrorOnFirstToken(node, qd.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name);
    }
    return false;
  }
  function checkGrammarModifiers(node: Node): boolean {
    const quickResult = reportObviousModifierErrors(node);
    if (quickResult !== undefined) return quickResult;
    let lastStatic: Node | undefined, lastDeclare: Node | undefined, lastAsync: Node | undefined, lastReadonly: Node | undefined;
    let flags = ModifierFlags.None;
    for (const modifier of node.modifiers!) {
      if (modifier.kind !== Syntax.ReadonlyKeyword) {
        if (node.kind === Syntax.PropertySignature || node.kind === Syntax.MethodSignature)
          return grammarErrorOnNode(modifier, qd._0_modifier_cannot_appear_on_a_type_member, Token.toString(modifier.kind));
        if (node.kind === Syntax.IndexSignature) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_appear_on_an_index_signature, Token.toString(modifier.kind));
      }
      switch (modifier.kind) {
        case Syntax.ConstKeyword:
          if (node.kind !== Syntax.EnumDeclaration) return grammarErrorOnNode(node, qd.A_class_member_cannot_have_the_0_keyword, Token.toString(Syntax.ConstKeyword));
          break;
        case Syntax.PublicKeyword:
        case Syntax.ProtectedKeyword:
        case Syntax.PrivateKeyword:
          const text = visibilityToString(syntax.get.modifierFlag(modifier.kind));
          if (flags & ModifierFlags.AccessibilityModifier) return grammarErrorOnNode(modifier, qd.Accessibility_modifier_already_seen);
          else if (flags & ModifierFlags.Static) return grammarErrorOnNode(modifier, qd._0_modifier_must_precede_1_modifier, text, 'static');
          else if (flags & ModifierFlags.Readonly) return grammarErrorOnNode(modifier, qd._0_modifier_must_precede_1_modifier, text, 'readonly');
          else if (flags & ModifierFlags.Async) return grammarErrorOnNode(modifier, qd._0_modifier_must_precede_1_modifier, text, 'async');
          else if (node.parent.kind === Syntax.ModuleBlock || node.parent.kind === Syntax.SourceFile)
            return grammarErrorOnNode(modifier, qd._0_modifier_cannot_appear_on_a_module_or_namespace_element, text);
          else if (flags & ModifierFlags.Abstract) {
            if (modifier.kind === Syntax.PrivateKeyword) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_be_used_with_1_modifier, text, 'abstract');
            return grammarErrorOnNode(modifier, qd._0_modifier_must_precede_1_modifier, text, 'abstract');
          } else if (node.isPrivateIdentifierPropertyDeclaration()) {
            return grammarErrorOnNode(modifier, qd.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);
          }
          flags |= syntax.get.modifierFlag(modifier.kind);
          break;
        case Syntax.StaticKeyword:
          if (flags & ModifierFlags.Static) return grammarErrorOnNode(modifier, qd._0_modifier_already_seen, 'static');
          else if (flags & ModifierFlags.Readonly) return grammarErrorOnNode(modifier, qd._0_modifier_must_precede_1_modifier, 'static', 'readonly');
          else if (flags & ModifierFlags.Async) return grammarErrorOnNode(modifier, qd._0_modifier_must_precede_1_modifier, 'static', 'async');
          else if (node.parent.kind === Syntax.ModuleBlock || node.parent.kind === Syntax.SourceFile)
            return grammarErrorOnNode(modifier, qd._0_modifier_cannot_appear_on_a_module_or_namespace_element, 'static');
          else if (node.kind === Syntax.Parameter) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_appear_on_a_parameter, 'static');
          else if (flags & ModifierFlags.Abstract) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_be_used_with_1_modifier, 'static', 'abstract');
          else if (node.isPrivateIdentifierPropertyDeclaration()) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_be_used_with_a_private_identifier, 'static');
          flags |= ModifierFlags.Static;
          lastStatic = modifier;
          break;
        case Syntax.ReadonlyKeyword:
          if (flags & ModifierFlags.Readonly) return grammarErrorOnNode(modifier, qd._0_modifier_already_seen, 'readonly');
          else if (node.kind !== Syntax.PropertyDeclaration && node.kind !== Syntax.PropertySignature && node.kind !== Syntax.IndexSignature && node.kind !== Syntax.Parameter)
            return grammarErrorOnNode(modifier, qd.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature);
          flags |= ModifierFlags.Readonly;
          lastReadonly = modifier;
          break;
        case Syntax.ExportKeyword:
          if (flags & ModifierFlags.Export) return grammarErrorOnNode(modifier, qd._0_modifier_already_seen, 'export');
          else if (flags & ModifierFlags.Ambient) return grammarErrorOnNode(modifier, qd._0_modifier_must_precede_1_modifier, 'export', 'declare');
          else if (flags & ModifierFlags.Abstract) return grammarErrorOnNode(modifier, qd._0_modifier_must_precede_1_modifier, 'export', 'abstract');
          else if (flags & ModifierFlags.Async) return grammarErrorOnNode(modifier, qd._0_modifier_must_precede_1_modifier, 'export', 'async');
          else if (qc.is.classLike(node.parent)) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_appear_on_a_class_element, 'export');
          else if (node.kind === Syntax.Parameter) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_appear_on_a_parameter, 'export');
          flags |= ModifierFlags.Export;
          break;
        case Syntax.DefaultKeyword:
          const container = node.parent.kind === Syntax.SourceFile ? node.parent : node.parent.parent;
          if (container.kind === Syntax.ModuleDeclaration && !qc.is.ambientModule(container)) return grammarErrorOnNode(modifier, qd.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
          flags |= ModifierFlags.Default;
          break;
        case Syntax.DeclareKeyword:
          if (flags & ModifierFlags.Ambient) return grammarErrorOnNode(modifier, qd._0_modifier_already_seen, 'declare');
          else if (flags & ModifierFlags.Async) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_be_used_in_an_ambient_context, 'async');
          else if (qc.is.classLike(node.parent) && !qc.is.kind(PropertyDeclaration, node)) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_appear_on_a_class_element, 'declare');
          else if (node.kind === Syntax.Parameter) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_appear_on_a_parameter, 'declare');
          else if (node.parent.flags & NodeFlags.Ambient && node.parent.kind === Syntax.ModuleBlock)
            return grammarErrorOnNode(modifier, qd.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
          else if (node.isPrivateIdentifierPropertyDeclaration()) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_be_used_with_a_private_identifier, 'declare');
          flags |= ModifierFlags.Ambient;
          lastDeclare = modifier;
          break;
        case Syntax.AbstractKeyword:
          if (flags & ModifierFlags.Abstract) return grammarErrorOnNode(modifier, qd._0_modifier_already_seen, 'abstract');
          if (node.kind !== Syntax.ClassDeclaration) {
            if (node.kind !== Syntax.MethodDeclaration && node.kind !== Syntax.PropertyDeclaration && node.kind !== Syntax.GetAccessor && node.kind !== Syntax.SetAccessor)
              return grammarErrorOnNode(modifier, qd.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration);
            if (!(node.parent.kind === Syntax.ClassDeclaration && hasSyntacticModifier(node.parent, ModifierFlags.Abstract)))
              return grammarErrorOnNode(modifier, qd.Abstract_methods_can_only_appear_within_an_abstract_class);
            if (flags & ModifierFlags.Static) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_be_used_with_1_modifier, 'static', 'abstract');
            if (flags & ModifierFlags.Private) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_be_used_with_1_modifier, 'private', 'abstract');
          }
          if (qc.is.namedDeclaration(node) && node.name.kind === Syntax.PrivateIdentifier) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_be_used_with_a_private_identifier, 'abstract');
          flags |= ModifierFlags.Abstract;
          break;
        case Syntax.AsyncKeyword:
          if (flags & ModifierFlags.Async) return grammarErrorOnNode(modifier, qd._0_modifier_already_seen, 'async');
          else if (flags & ModifierFlags.Ambient || node.parent.flags & NodeFlags.Ambient) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_be_used_in_an_ambient_context, 'async');
          else if (node.kind === Syntax.Parameter) return grammarErrorOnNode(modifier, qd._0_modifier_cannot_appear_on_a_parameter, 'async');
          flags |= ModifierFlags.Async;
          lastAsync = modifier;
          break;
      }
    }
    if (node.kind === Syntax.Constructor) {
      if (flags & ModifierFlags.Static) return grammarErrorOnNode(lastStatic!, qd._0_modifier_cannot_appear_on_a_constructor_declaration, 'static');
      if (flags & ModifierFlags.Abstract) return grammarErrorOnNode(lastStatic!, qd._0_modifier_cannot_appear_on_a_constructor_declaration, 'abstract');
      else if (flags & ModifierFlags.Async) return grammarErrorOnNode(lastAsync!, qd._0_modifier_cannot_appear_on_a_constructor_declaration, 'async');
      else if (flags & ModifierFlags.Readonly) return grammarErrorOnNode(lastReadonly!, qd._0_modifier_cannot_appear_on_a_constructor_declaration, 'readonly');
      return false;
    } else if ((node.kind === Syntax.ImportDeclaration || node.kind === Syntax.ImportEqualsDeclaration) && flags & ModifierFlags.Ambient) {
      return grammarErrorOnNode(lastDeclare!, qd.A_0_modifier_cannot_be_used_with_an_import_declaration, 'declare');
    } else if (node.kind === Syntax.Parameter && flags & ModifierFlags.ParameterPropertyModifier && qc.is.kind(BindingPattern, (<ParameterDeclaration>node).name)) {
      return grammarErrorOnNode(node, qd.A_parameter_property_may_not_be_declared_using_a_binding_pattern);
    } else if (node.kind === Syntax.Parameter && flags & ModifierFlags.ParameterPropertyModifier && (<ParameterDeclaration>node).dot3Token) {
      return grammarErrorOnNode(node, qd.A_parameter_property_cannot_be_declared_using_a_rest_parameter);
    }
    if (flags & ModifierFlags.Async) return checkGrammarAsyncModifier(node, lastAsync!);
    return false;
  }
  function reportObviousModifierErrors(node: Node): boolean | undefined {
    return !node.modifiers ? false : shouldReportBadModifier(node) ? grammarErrorOnFirstToken(node, qd.Modifiers_cannot_appear_here) : undefined;
  }
  function shouldReportBadModifier(node: Node): boolean {
    switch (node.kind) {
      case Syntax.GetAccessor:
      case Syntax.SetAccessor:
      case Syntax.Constructor:
      case Syntax.PropertyDeclaration:
      case Syntax.PropertySignature:
      case Syntax.MethodDeclaration:
      case Syntax.MethodSignature:
      case Syntax.IndexSignature:
      case Syntax.ModuleDeclaration:
      case Syntax.ImportDeclaration:
      case Syntax.ImportEqualsDeclaration:
      case Syntax.ExportDeclaration:
      case Syntax.ExportAssignment:
      case Syntax.FunctionExpression:
      case Syntax.ArrowFunction:
      case Syntax.Parameter:
        return false;
      default:
        if (node.parent.kind === Syntax.ModuleBlock || node.parent.kind === Syntax.SourceFile) return false;
        switch (node.kind) {
          case Syntax.FunctionDeclaration:
            return nodeHasAnyModifiersExcept(node, Syntax.AsyncKeyword);
          case Syntax.ClassDeclaration:
            return nodeHasAnyModifiersExcept(node, Syntax.AbstractKeyword);
          case Syntax.InterfaceDeclaration:
          case Syntax.VariableStatement:
          case Syntax.TypeAliasDeclaration:
            return true;
          case Syntax.EnumDeclaration:
            return nodeHasAnyModifiersExcept(node, Syntax.ConstKeyword);
          default:
            fail();
            return false;
        }
    }
  }
  function nodeHasAnyModifiersExcept(node: Node, allowedModifier: Syntax): boolean {
    return node.modifiers!.length > 1 || node.modifiers![0].kind !== allowedModifier;
  }
  function checkGrammarAsyncModifier(node: Node, asyncModifier: Node): boolean {
    switch (node.kind) {
      case Syntax.MethodDeclaration:
      case Syntax.FunctionDeclaration:
      case Syntax.FunctionExpression:
      case Syntax.ArrowFunction:
        return false;
    }
    return grammarErrorOnNode(asyncModifier, qd._0_modifier_cannot_be_used_here, 'async');
  }
  function checkGrammarForDisallowedTrailingComma(list: Nodes<Node> | undefined, diag = qd.Trailing_comma_not_allowed): boolean {
    if (list && list.trailingComma) return grammarErrorAtPos(list[0], list.end - ','.length, ','.length, diag);
    return false;
  }
  function checkGrammarTypeParameterList(typeParameters: Nodes<TypeParameterDeclaration> | undefined, file: SourceFile): boolean {
    if (typeParameters && typeParameters.length === 0) {
      const start = typeParameters.pos - '<'.length;
      const end = syntax.skipTrivia(file.text, typeParameters.end) + '>'.length;
      return grammarErrorAtPos(file, start, end - start, qd.Type_parameter_list_cannot_be_empty);
    }
    return false;
  }
  function checkGrammarParameterList(parameters: Nodes<ParameterDeclaration>) {
    let seenOptionalParameter = false;
    const parameterCount = parameters.length;
    for (let i = 0; i < parameterCount; i++) {
      const parameter = parameters[i];
      if (parameter.dot3Token) {
        if (i !== parameterCount - 1) return grammarErrorOnNode(parameter.dot3Token, qd.A_rest_parameter_must_be_last_in_a_parameter_list);
        if (!(parameter.flags & NodeFlags.Ambient)) checkGrammarForDisallowedTrailingComma(parameters, qd.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
        if (parameter.questionToken) return grammarErrorOnNode(parameter.questionToken, qd.A_rest_parameter_cannot_be_optional);
        if (parameter.initializer) return grammarErrorOnNode(parameter.name, qd.A_rest_parameter_cannot_have_an_initializer);
      } else if (isOptionalParameter(parameter)) {
        seenOptionalParameter = true;
        if (parameter.questionToken && parameter.initializer) return grammarErrorOnNode(parameter.name, qd.Parameter_cannot_have_question_mark_and_initializer);
      } else if (seenOptionalParameter && !parameter.initializer) {
        return grammarErrorOnNode(parameter.name, qd.A_required_parameter_cannot_follow_an_optional_parameter);
      }
    }
  }
  function getNonSimpleParameters(parameters: readonly ParameterDeclaration[]): readonly ParameterDeclaration[] {
    return filter(parameters, (parameter) => !!parameter.initializer || qc.is.kind(BindingPattern, parameter.name) || isRestParameter(parameter));
  }
  function checkGrammarForUseStrictSimpleParameterList(node: FunctionLikeDeclaration): boolean {
    const useStrictDirective = node.body && qc.is.kind(Block, node.body) && findUseStrictPrologue(node.body.statements);
    if (useStrictDirective) {
      const nonSimpleParameters = getNonSimpleParameters(node.parameters);
      if (length(nonSimpleParameters)) {
        forEach(nonSimpleParameters, (parameter) => {
          addRelatedInfo(error(parameter, qd.This_parameter_is_not_allowed_with_use_strict_directive), createDiagnosticForNode(useStrictDirective, qd.use_strict_directive_used_here));
        });
        const diagnostics = nonSimpleParameters.map((parameter, index) =>
          index === 0 ? createDiagnosticForNode(parameter, qd.Non_simple_parameter_declared_here) : createDiagnosticForNode(parameter, qd.and_here)
        ) as [DiagnosticWithLocation, ...DiagnosticWithLocation[]];
        addRelatedInfo(error(useStrictDirective, qd.use_strict_directive_cannot_be_used_with_non_simple_parameter_list), ...diagnostics);
        return true;
      }
    }
    return false;
  }
  function checkGrammarFunctionLikeDeclaration(node: FunctionLikeDeclaration | MethodSignature): boolean {
    const file = qc.get.sourceFileOf(node);
    return (
      checkGrammarDecoratorsAndModifiers(node) ||
      checkGrammarTypeParameterList(node.typeParameters, file) ||
      checkGrammarParameterList(node.parameters) ||
      checkGrammarArrowFunction(node, file) ||
      (qc.is.functionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node))
    );
  }
  function checkGrammarClassLikeDeclaration(node: ClassLikeDeclaration): boolean {
    const file = qc.get.sourceFileOf(node);
    return checkGrammarClassDeclarationHeritageClauses(node) || checkGrammarTypeParameterList(node.typeParameters, file);
  }
  function checkGrammarArrowFunction(node: Node, file: SourceFile): boolean {
    if (!qc.is.kind(ArrowFunction, node)) return false;
    const { equalsGreaterThanToken } = node;
    const startLine = syntax.get.lineAndCharOf(file, equalsGreaterThanToken.pos).line;
    const endLine = syntax.get.lineAndCharOf(file, equalsGreaterThanToken.end).line;
    return startLine !== endLine && grammarErrorOnNode(equalsGreaterThanToken, qd.Line_terminator_not_permitted_before_arrow);
  }
  function checkGrammarIndexSignatureParameters(node: SignatureDeclaration): boolean {
    const parameter = node.parameters[0];
    if (node.parameters.length !== 1) {
      if (parameter) return grammarErrorOnNode(parameter.name, qd.An_index_signature_must_have_exactly_one_parameter);
      return grammarErrorOnNode(node, qd.An_index_signature_must_have_exactly_one_parameter);
    }
    checkGrammarForDisallowedTrailingComma(node.parameters, qd.An_index_signature_cannot_have_a_trailing_comma);
    if (parameter.dot3Token) return grammarErrorOnNode(parameter.dot3Token, qd.An_index_signature_cannot_have_a_rest_parameter);
    if (hasEffectiveModifiers(parameter)) return grammarErrorOnNode(parameter.name, qd.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
    if (parameter.questionToken) return grammarErrorOnNode(parameter.questionToken, qd.An_index_signature_parameter_cannot_have_a_question_mark);
    if (parameter.initializer) return grammarErrorOnNode(parameter.name, qd.An_index_signature_parameter_cannot_have_an_initializer);
    if (!parameter.type) return grammarErrorOnNode(parameter.name, qd.An_index_signature_parameter_must_have_a_type_annotation);
    if (parameter.type.kind !== Syntax.StringKeyword && parameter.type.kind !== Syntax.NumberKeyword) {
      const type = getTypeFromTypeNode(parameter.type);
      if (type.flags & TypeFlags.String || type.flags & TypeFlags.Number) {
        return grammarErrorOnNode(
          parameter.name,
          qd.An_index_signature_parameter_type_cannot_be_a_type_alias_Consider_writing_0_Colon_1_Colon_2_instead,
          qc.get.textOf(parameter.name),
          typeToString(type),
          typeToString(node.type ? getTypeFromTypeNode(node.type) : anyType)
        );
      }
      if (type.flags & TypeFlags.Union && allTypesAssignableToKind(type, TypeFlags.StringOrNumberLiteral, true))
        return grammarErrorOnNode(parameter.name, qd.An_index_signature_parameter_type_cannot_be_a_union_type_Consider_using_a_mapped_object_type_instead);
      return grammarErrorOnNode(parameter.name, qd.An_index_signature_parameter_type_must_be_either_string_or_number);
    }
    if (!node.type) return grammarErrorOnNode(node, qd.An_index_signature_must_have_a_type_annotation);
    return false;
  }
  function checkGrammarIndexSignature(node: SignatureDeclaration) {
    return checkGrammarDecoratorsAndModifiers(node) || checkGrammarIndexSignatureParameters(node);
  }
  function checkGrammarForAtLeastOneTypeArgument(node: Node, typeArguments: Nodes<TypeNode> | undefined): boolean {
    if (typeArguments && typeArguments.length === 0) {
      const sourceFile = qc.get.sourceFileOf(node);
      const start = typeArguments.pos - '<'.length;
      const end = syntax.skipTrivia(sourceFile.text, typeArguments.end) + '>'.length;
      return grammarErrorAtPos(sourceFile, start, end - start, qd.Type_argument_list_cannot_be_empty);
    }
    return false;
  }
  function checkGrammarTypeArguments(node: Node, typeArguments: Nodes<TypeNode> | undefined): boolean {
    return checkGrammarForDisallowedTrailingComma(typeArguments) || checkGrammarForAtLeastOneTypeArgument(node, typeArguments);
  }
  function checkGrammarTaggedTemplateChain(node: TaggedTemplateExpression): boolean {
    if (node.questionDotToken || node.flags & NodeFlags.OptionalChain) return grammarErrorOnNode(node.template, qd.Tagged_template_expressions_are_not_permitted_in_an_optional_chain);
    return false;
  }
  function checkGrammarForOmittedArgument(args: Nodes<Expression> | undefined): boolean {
    if (args) {
      for (const arg of args) {
        if (arg.kind === Syntax.OmittedExpression) return grammarErrorAtPos(arg, arg.pos, 0, qd.Argument_expression_expected);
      }
    }
    return false;
  }
  function checkGrammarArguments(args: Nodes<Expression> | undefined): boolean {
    return checkGrammarForOmittedArgument(args);
  }
  function checkGrammarHeritageClause(node: HeritageClause): boolean {
    const types = node.types;
    if (checkGrammarForDisallowedTrailingComma(types)) return true;
    if (types && types.length === 0) {
      const listType = Token.toString(node.token);
      return grammarErrorAtPos(node, types.pos, 0, qd._0_list_cannot_be_empty, listType);
    }
    return some(types, checkGrammarExpressionWithTypeArguments);
  }
  function checkGrammarExpressionWithTypeArguments(node: ExpressionWithTypeArguments) {
    return checkGrammarTypeArguments(node, node.typeArguments);
  }
  function checkGrammarClassDeclarationHeritageClauses(node: ClassLikeDeclaration) {
    let seenExtendsClause = false;
    let seenImplementsClause = false;
    if (!checkGrammarDecoratorsAndModifiers(node) && node.heritageClauses) {
      for (const heritageClause of node.heritageClauses) {
        if (heritageClause.token === Syntax.ExtendsKeyword) {
          if (seenExtendsClause) return grammarErrorOnFirstToken(heritageClause, qd.extends_clause_already_seen);
          if (seenImplementsClause) return grammarErrorOnFirstToken(heritageClause, qd.extends_clause_must_precede_implements_clause);
          if (heritageClause.types.length > 1) return grammarErrorOnFirstToken(heritageClause.types[1], qd.Classes_can_only_extend_a_single_class);
          seenExtendsClause = true;
        } else {
          assert(heritageClause.token === Syntax.ImplementsKeyword);
          if (seenImplementsClause) return grammarErrorOnFirstToken(heritageClause, qd.implements_clause_already_seen);
          seenImplementsClause = true;
        }
        checkGrammarHeritageClause(heritageClause);
      }
    }
  }
  function checkGrammarInterfaceDeclaration(node: InterfaceDeclaration) {
    let seenExtendsClause = false;
    if (node.heritageClauses) {
      for (const heritageClause of node.heritageClauses) {
        if (heritageClause.token === Syntax.ExtendsKeyword) {
          if (seenExtendsClause) return grammarErrorOnFirstToken(heritageClause, qd.extends_clause_already_seen);
          seenExtendsClause = true;
        } else {
          assert(heritageClause.token === Syntax.ImplementsKeyword);
          return grammarErrorOnFirstToken(heritageClause, qd.Interface_declaration_cannot_have_implements_clause);
        }
        checkGrammarHeritageClause(heritageClause);
      }
    }
    return false;
  }
  function checkGrammarComputedPropertyName(node: Node): boolean {
    if (node.kind !== Syntax.ComputedPropertyName) return false;
    const computedPropertyName = <ComputedPropertyName>node;
    if (computedPropertyName.expression.kind === Syntax.BinaryExpression && (<BinaryExpression>computedPropertyName.expression).operatorToken.kind === Syntax.CommaToken)
      return grammarErrorOnNode(computedPropertyName.expression, qd.A_comma_expression_is_not_allowed_in_a_computed_property_name);
    return false;
  }
  function checkGrammarForGenerator(node: FunctionLikeDeclaration) {
    if (node.asteriskToken) {
      assert(node.kind === Syntax.FunctionDeclaration || node.kind === Syntax.FunctionExpression || node.kind === Syntax.MethodDeclaration);
      if (node.flags & NodeFlags.Ambient) return grammarErrorOnNode(node.asteriskToken, qd.Generators_are_not_allowed_in_an_ambient_context);
      if (!node.body) return grammarErrorOnNode(node.asteriskToken, qd.An_overload_signature_cannot_be_declared_as_a_generator);
    }
  }
  function checkGrammarForInvalidQuestionMark(questionToken: QuestionToken | undefined, message: DiagnosticMessage): boolean {
    return !!questionToken && grammarErrorOnNode(questionToken, message);
  }
  function checkGrammarForInvalidExclamationToken(exclamationToken: ExclamationToken | undefined, message: DiagnosticMessage): boolean {
    return !!exclamationToken && grammarErrorOnNode(exclamationToken, message);
  }
  function checkGrammarObjectLiteralExpression(node: ObjectLiteralExpression, inDestructuring: boolean) {
    const seen = createUnderscoreEscapedMap<DeclarationMeaning>();
    for (const prop of node.properties) {
      if (prop.kind === Syntax.SpreadAssignment) {
        if (inDestructuring) {
          const expression = skipParentheses(prop.expression);
          if (isArrayLiteralExpression(expression) || qc.is.kind(ObjectLiteralExpression, expression)) return grammarErrorOnNode(prop.expression, qd.A_rest_element_cannot_contain_a_binding_pattern);
        }
        continue;
      }
      const name = prop.name;
      if (name.kind === Syntax.ComputedPropertyName) checkGrammarComputedPropertyName(name);
      if (prop.kind === Syntax.ShorthandPropertyAssignment && !inDestructuring && prop.objectAssignmentInitializer)
        return grammarErrorOnNode(prop.equalsToken!, qd.can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment);
      if (name.kind === Syntax.PrivateIdentifier) return grammarErrorOnNode(name, qd.Private_identifiers_are_not_allowed_outside_class_bodies);
      if (prop.modifiers) {
        for (const mod of prop.modifiers!) {
          if (mod.kind !== Syntax.AsyncKeyword || prop.kind !== Syntax.MethodDeclaration) grammarErrorOnNode(mod, qd._0_modifier_cannot_be_used_here, qc.get.textOf(mod));
        }
      }
      let currentKind: DeclarationMeaning;
      switch (prop.kind) {
        case Syntax.ShorthandPropertyAssignment:
          checkGrammarForInvalidExclamationToken(prop.exclamationToken, qd.A_definite_assignment_assertion_is_not_permitted_in_this_context);
        case Syntax.PropertyAssignment:
          checkGrammarForInvalidQuestionMark(prop.questionToken, qd.An_object_member_cannot_be_declared_optional);
          if (name.kind === Syntax.NumericLiteral) checkGrammarNumericLiteral(name);
          currentKind = DeclarationMeaning.PropertyAssignment;
          break;
        case Syntax.MethodDeclaration:
          currentKind = DeclarationMeaning.Method;
          break;
        case Syntax.GetAccessor:
          currentKind = DeclarationMeaning.GetAccessor;
          break;
        case Syntax.SetAccessor:
          currentKind = DeclarationMeaning.SetAccessor;
          break;
        default:
          throw Debug.assertNever(prop, 'Unexpected syntax kind:' + (<Node>prop).kind);
      }
      if (!inDestructuring) {
        const effectiveName = getPropertyNameForPropertyNameNode(name);
        if (effectiveName === undefined) continue;
        const existingKind = seen.get(effectiveName);
        if (!existingKind) seen.set(effectiveName, currentKind);
        else {
          if (currentKind & DeclarationMeaning.PropertyAssignmentOrMethod && existingKind & DeclarationMeaning.PropertyAssignmentOrMethod)
            grammarErrorOnNode(name, qd.Duplicate_identifier_0, qc.get.textOf(name));
          else if (currentKind & DeclarationMeaning.GetOrSetAccessor && existingKind & DeclarationMeaning.GetOrSetAccessor) {
            if (existingKind !== DeclarationMeaning.GetOrSetAccessor && currentKind !== existingKind) seen.set(effectiveName, currentKind | existingKind);
            return grammarErrorOnNode(name, qd.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
          }
          return grammarErrorOnNode(name, qd.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
        }
      }
    }
  }
  function checkGrammarJsxElement(node: JsxOpeningLikeElement) {
    checkGrammarTypeArguments(node, node.typeArguments);
    const seen = createUnderscoreEscapedMap<boolean>();
    for (const attr of node.attributes.properties) {
      if (attr.kind === Syntax.JsxSpreadAttribute) continue;
      const { name, initializer } = attr;
      if (!seen.get(name.escapedText)) seen.set(name.escapedText, true);
      return grammarErrorOnNode(name, qd.JSX_elements_cannot_have_multiple_attributes_with_the_same_name);
      if (initializer && initializer.kind === Syntax.JsxExpression && !initializer.expression) return grammarErrorOnNode(initializer, qd.JSX_attributes_must_only_be_assigned_a_non_empty_expression);
    }
  }
  function checkGrammarJsxExpression(node: JsxExpression) {
    if (node.expression && isCommaSequence(node.expression)) return grammarErrorOnNode(node.expression, qd.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array);
  }
  function checkGrammarForInOrForOfStatement(forInOrOfStatement: ForInOrOfStatement): boolean {
    if (checkGrammarStatementInAmbientContext(forInOrOfStatement)) return true;
    if (forInOrOfStatement.kind === Syntax.ForOfStatement && forInOrOfStatement.awaitModifier) {
      if ((forInOrOfStatement.flags & NodeFlags.AwaitContext) === NodeFlags.None) {
        const sourceFile = qc.get.sourceFileOf(forInOrOfStatement);
        if (!hasParseDiagnostics(sourceFile)) {
          const diagnostic = createDiagnosticForNode(forInOrOfStatement.awaitModifier, qd.A_for_await_of_statement_is_only_allowed_within_an_async_function_or_async_generator);
          const func = qc.get.containingFunction(forInOrOfStatement);
          if (func && func.kind !== Syntax.Constructor) {
            assert((getFunctionFlags(func) & FunctionFlags.Async) === 0, 'Enclosing function should never be an async function.');
            const relatedInfo = createDiagnosticForNode(func, qd.Did_you_mean_to_mark_this_function_as_async);
            addRelatedInfo(diagnostic, relatedInfo);
          }
          diagnostics.add(diagnostic);
          return true;
        }
        return false;
      }
    }
    if (forInOrOfStatement.initializer.kind === Syntax.VariableDeclarationList) {
      const variableList = <VariableDeclarationList>forInOrOfStatement.initializer;
      if (!checkGrammarVariableDeclarationList(variableList)) {
        const declarations = variableList.declarations;
        if (!declarations.length) return false;
        if (declarations.length > 1) {
          const diagnostic =
            forInOrOfStatement.kind === Syntax.ForInStatement
              ? qd.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement
              : qd.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement;
          return grammarErrorOnFirstToken(variableList.declarations[1], diagnostic);
        }
        const firstDeclaration = declarations[0];
        if (firstDeclaration.initializer) {
          const diagnostic =
            forInOrOfStatement.kind === Syntax.ForInStatement
              ? qd.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer
              : qd.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer;
          return grammarErrorOnNode(firstDeclaration.name, diagnostic);
        }
        if (firstDeclaration.type) {
          const diagnostic =
            forInOrOfStatement.kind === Syntax.ForInStatement
              ? qd.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation
              : qd.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation;
          return grammarErrorOnNode(firstDeclaration, diagnostic);
        }
      }
    }
    return false;
  }
  function checkGrammarAccessor(accessor: AccessorDeclaration): boolean {
    if (!(accessor.flags & NodeFlags.Ambient)) {
      if (accessor.body === undefined && !hasSyntacticModifier(accessor, ModifierFlags.Abstract)) return grammarErrorAtPos(accessor, accessor.end - 1, ';'.length, qd._0_expected, '{');
    }
    if (accessor.body && hasSyntacticModifier(accessor, ModifierFlags.Abstract)) return grammarErrorOnNode(accessor, qd.An_abstract_accessor_cannot_have_an_implementation);
    if (accessor.typeParameters) return grammarErrorOnNode(accessor.name, qd.An_accessor_cannot_have_type_parameters);
    if (!doesAccessorHaveCorrectParameterCount(accessor))
      return grammarErrorOnNode(accessor.name, accessor.kind === Syntax.GetAccessor ? qd.A_get_accessor_cannot_have_parameters : qd.A_set_accessor_must_have_exactly_one_parameter);
    if (accessor.kind === Syntax.SetAccessor) {
      if (accessor.type) return grammarErrorOnNode(accessor.name, qd.A_set_accessor_cannot_have_a_return_type_annotation);
      const parameter = Debug.checkDefined(getSetAccessorValueParameter(accessor), 'Return value does not match parameter count assertion.');
      if (parameter.dot3Token) return grammarErrorOnNode(parameter.dot3Token, qd.A_set_accessor_cannot_have_rest_parameter);
      if (parameter.questionToken) return grammarErrorOnNode(parameter.questionToken, qd.A_set_accessor_cannot_have_an_optional_parameter);
      if (parameter.initializer) return grammarErrorOnNode(accessor.name, qd.A_set_accessor_parameter_cannot_have_an_initializer);
    }
    return false;
  }
  function doesAccessorHaveCorrectParameterCount(accessor: AccessorDeclaration) {
    return getAccessorThisNodeKind(ParameterDeclaration, accessor) || accessor.parameters.length === (accessor.kind === Syntax.GetAccessor ? 0 : 1);
  }
  function getAccessorThisNodeKind(ParameterDeclaration, accessor: AccessorDeclaration): ParameterDeclaration | undefined {
    if (accessor.parameters.length === (accessor.kind === Syntax.GetAccessor ? 1 : 2)) return getThisNodeKind(ParameterDeclaration, accessor);
  }
  function checkGrammarTypeOperatorNode(node: TypeOperatorNode) {
    if (node.operator === Syntax.UniqueKeyword) {
      if (node.type.kind !== Syntax.SymbolKeyword) return grammarErrorOnNode(node.type, qd._0_expected, Token.toString(Syntax.SymbolKeyword));
      let parent = walkUpParenthesizedTypes(node.parent);
      if (isInJSFile(parent) && qc.is.kind(JSDocTypeExpression, parent)) {
        parent = parent.parent;
        if (qc.is.kind(JSDocTypeTag, parent)) parent = parent.parent.parent;
      }
      switch (parent.kind) {
        case Syntax.VariableDeclaration:
          const decl = parent as VariableDeclaration;
          if (decl.name.kind !== Syntax.Identifier) return grammarErrorOnNode(node, qd.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name);
          if (!isVariableDeclarationInVariableStatement(decl)) return grammarErrorOnNode(node, qd.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement);
          if (!(decl.parent.flags & NodeFlags.Const)) return grammarErrorOnNode((<VariableDeclaration>parent).name, qd.A_variable_whose_type_is_a_unique_symbol_type_must_be_const);
          break;
        case Syntax.PropertyDeclaration:
          if (!hasSyntacticModifier(parent, ModifierFlags.Static) || !hasEffectiveModifier(parent, ModifierFlags.Readonly))
            return grammarErrorOnNode((<PropertyDeclaration>parent).name, qd.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly);
          break;
        case Syntax.PropertySignature:
          if (!hasSyntacticModifier(parent, ModifierFlags.Readonly))
            return grammarErrorOnNode((<PropertySignature>parent).name, qd.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly);
          break;
        default:
          return grammarErrorOnNode(node, qd.unique_symbol_types_are_not_allowed_here);
      }
    } else if (node.operator === Syntax.ReadonlyKeyword) {
      if (node.type.kind !== Syntax.ArrayType && node.type.kind !== Syntax.TupleType)
        return grammarErrorOnFirstToken(node, qd.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types, Token.toString(Syntax.SymbolKeyword));
    }
  }
  function checkGrammarForInvalidDynamicName(node: DeclarationName, message: DiagnosticMessage) {
    if (isNonBindableDynamicName(node)) return grammarErrorOnNode(node, message);
  }
  function checkGrammarMethod(node: MethodDeclaration | MethodSignature) {
    if (checkGrammarFunctionLikeDeclaration(node)) return true;
    if (node.kind === Syntax.MethodDeclaration) {
      if (node.parent.kind === Syntax.ObjectLiteralExpression) {
        if (node.modifiers && !(node.modifiers.length === 1 && first(node.modifiers).kind === Syntax.AsyncKeyword)) return grammarErrorOnFirstToken(node, qd.Modifiers_cannot_appear_here);
        else if (checkGrammarForInvalidQuestionMark(node.questionToken, qd.An_object_member_cannot_be_declared_optional)) return true;
        else if (checkGrammarForInvalidExclamationToken(node.exclamationToken, qd.A_definite_assignment_assertion_is_not_permitted_in_this_context)) return true;
        else if (node.body === undefined) return grammarErrorAtPos(node, node.end - 1, ';'.length, qd._0_expected, '{');
      }
      if (checkGrammarForGenerator(node)) return true;
    }
    if (qc.is.classLike(node.parent)) {
      if (node.flags & NodeFlags.Ambient) {
        return checkGrammarForInvalidDynamicName(node.name, qd.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
      } else if (node.kind === Syntax.MethodDeclaration && !node.body) {
        return checkGrammarForInvalidDynamicName(node.name, qd.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
      }
    } else if (node.parent.kind === Syntax.InterfaceDeclaration) {
      return checkGrammarForInvalidDynamicName(node.name, qd.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
    } else if (node.parent.kind === Syntax.TypeLiteral) {
      return checkGrammarForInvalidDynamicName(node.name, qd.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
    }
  }
  function checkGrammarBreakOrContinueStatement(node: BreakOrContinueStatement): boolean {
    let current: Node = node;
    while (current) {
      if (qc.is.functionLike(current)) return grammarErrorOnNode(node, qd.Jump_target_cannot_cross_function_boundary);
      switch (current.kind) {
        case Syntax.LabeledStatement:
          if (node.label && (<LabeledStatement>current).label.escapedText === node.label.escapedText) {
            const isMisplacedContinueLabel = node.kind === Syntax.ContinueStatement && !qc.is.iterationStatement((<LabeledStatement>current).statement, true);
            if (isMisplacedContinueLabel) return grammarErrorOnNode(node, qd.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
            return false;
          }
          break;
        case Syntax.SwitchStatement:
          if (node.kind === Syntax.BreakStatement && !node.label) return false;
          break;
        default:
          if (qc.is.iterationStatement(current, false) && !node.label) return false;
          break;
      }
      current = current.parent;
    }
    if (node.label) {
      const message =
        node.kind === Syntax.BreakStatement
          ? qd.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement
          : qd.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;
      return grammarErrorOnNode(node, message);
    } else {
      const message =
        node.kind === Syntax.BreakStatement
          ? qd.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement
          : qd.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;
      return grammarErrorOnNode(node, message);
    }
  }
  function checkGrammarBindingElement(node: BindingElement) {
    if (node.dot3Token) {
      const elements = node.parent.elements;
      if (node !== last(elements)) return grammarErrorOnNode(node, qd.A_rest_element_must_be_last_in_a_destructuring_pattern);
      checkGrammarForDisallowedTrailingComma(elements, qd.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
      if (node.propertyName) return grammarErrorOnNode(node.name, qd.A_rest_element_cannot_have_a_property_name);
      if (node.initializer) return grammarErrorAtPos(node, node.initializer.pos - 1, 1, qd.A_rest_element_cannot_have_an_initializer);
    }
    return;
  }
  function isSimpleLiteralEnumReference(expr: Expression) {
    if (
      (qc.is.kind(PropertyAccessExpression, expr) || (qc.is.kind(ElementAccessExpression, expr) && StringLiteral.orNumberLiteralExpression(expr.argumentExpression))) &&
      isEntityNameExpression(expr.expression)
    ) {
      return !!(checkExpressionCached(expr).flags & TypeFlags.EnumLiteral);
    }
    return;
  }
  function checkAmbientInitializer(node: VariableDeclaration | PropertyDeclaration | PropertySignature) {
    const { initializer } = node;
    if (initializer) {
      const isInvalidInitializer = !(
        StringLiteral.orNumberLiteralExpression(initializer) ||
        isSimpleLiteralEnumReference(initializer) ||
        initializer.kind === Syntax.TrueKeyword ||
        initializer.kind === Syntax.FalseKeyword ||
        BigIntLiteral.expression(initializer)
      );
      const isConstOrReadonly = isDeclarationReadonly(node) || (qc.is.kind(VariableDeclaration, node) && isVarConst(node));
      if (isConstOrReadonly && !node.type) {
        if (isInvalidInitializer) return grammarErrorOnNode(initializer, qd.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference);
      }
      return grammarErrorOnNode(initializer, qd.Initializers_are_not_allowed_in_ambient_contexts);
      if (!isConstOrReadonly || isInvalidInitializer) return grammarErrorOnNode(initializer, qd.Initializers_are_not_allowed_in_ambient_contexts);
    }
    return;
  }
  function checkGrammarVariableDeclaration(node: VariableDeclaration) {
    if (node.parent.parent.kind !== Syntax.ForInStatement && node.parent.parent.kind !== Syntax.ForOfStatement) {
      if (node.flags & NodeFlags.Ambient) checkAmbientInitializer(node);
      else if (!node.initializer) {
        if (qc.is.kind(BindingPattern, node.name) && !qc.is.kind(BindingPattern, node.parent)) return grammarErrorOnNode(node, qd.A_destructuring_declaration_must_have_an_initializer);
        if (isVarConst(node)) return grammarErrorOnNode(node, qd.const_declarations_must_be_initialized);
      }
    }
    if (node.exclamationToken && (node.parent.parent.kind !== Syntax.VariableStatement || !node.type || node.initializer || node.flags & NodeFlags.Ambient))
      return grammarErrorOnNode(node.exclamationToken, qd.Definite_assignment_assertions_can_only_be_used_along_with_a_type_annotation);
    const moduleKind = getEmitModuleKind(compilerOptions);
    if (
      moduleKind < ModuleKind.ES2015 &&
      moduleKind !== ModuleKind.System &&
      !compilerOptions.noEmit &&
      !(node.parent.parent.flags & NodeFlags.Ambient) &&
      hasSyntacticModifier(node.parent.parent, ModifierFlags.Export)
    ) {
      checkESModuleMarker(node.name);
    }
    const checkLetConstNames = qc.is.aLet(node) || isVarConst(node);
    return checkLetConstNames && checkGrammarNameInLetOrConstDeclarations(node.name);
  }
  function checkESModuleMarker(name: Identifier | BindingPattern): boolean {
    if (name.kind === Syntax.Identifier) {
      if (idText(name) === '__esModule') return grammarErrorOnNode(name, qd.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules);
    } else {
      const elements = name.elements;
      for (const element of elements) {
        if (!qc.is.kind(OmittedExpression, element)) return checkESModuleMarker(element.name);
      }
    }
    return false;
  }
  function checkGrammarNameInLetOrConstDeclarations(name: Identifier | BindingPattern): boolean {
    if (name.kind === Syntax.Identifier) {
      if (name.originalKeywordKind === Syntax.LetKeyword) return grammarErrorOnNode(name, qd.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations);
    } else {
      const elements = name.elements;
      for (const element of elements) {
        if (!qc.is.kind(OmittedExpression, element)) checkGrammarNameInLetOrConstDeclarations(element.name);
      }
    }
    return false;
  }
  function checkGrammarVariableDeclarationList(declarationList: VariableDeclarationList): boolean {
    const declarations = declarationList.declarations;
    if (checkGrammarForDisallowedTrailingComma(declarationList.declarations)) return true;
    if (!declarationList.declarations.length) return grammarErrorAtPos(declarationList, declarations.pos, declarations.end - declarations.pos, qd.Variable_declaration_list_cannot_be_empty);
    return false;
  }
  function allowLetAndConstDeclarations(parent: Node): boolean {
    switch (parent.kind) {
      case Syntax.IfStatement:
      case Syntax.DoStatement:
      case Syntax.WhileStatement:
      case Syntax.WithStatement:
      case Syntax.ForStatement:
      case Syntax.ForInStatement:
      case Syntax.ForOfStatement:
        return false;
      case Syntax.LabeledStatement:
        return allowLetAndConstDeclarations(parent.parent);
    }
    return true;
  }
  function checkGrammarForDisallowedLetOrConstStatement(node: VariableStatement) {
    if (!allowLetAndConstDeclarations(node.parent)) {
      if (qc.is.aLet(node.declarationList)) return grammarErrorOnNode(node, qd.let_declarations_can_only_be_declared_inside_a_block);
      else if (isVarConst(node.declarationList)) return grammarErrorOnNode(node, qd.const_declarations_can_only_be_declared_inside_a_block);
    }
  }
  function checkGrammarMetaProperty(node: MetaProperty) {
    const escapedText = node.name.escapedText;
    switch (node.keywordToken) {
      case Syntax.NewKeyword:
        if (escapedText !== 'target')
          return grammarErrorOnNode(node.name, qd._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, node.name.escapedText, Token.toString(node.keywordToken), 'target');
        break;
      case Syntax.ImportKeyword:
        if (escapedText !== 'meta')
          return grammarErrorOnNode(node.name, qd._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, node.name.escapedText, Token.toString(node.keywordToken), 'meta');
        break;
    }
  }
  function hasParseDiagnostics(sourceFile: SourceFile): boolean {
    return sourceFile.parseqd.length > 0;
  }
  function grammarErrorOnFirstToken(node: Node, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): boolean {
    const sourceFile = qc.get.sourceFileOf(node);
    if (!hasParseDiagnostics(sourceFile)) {
      const span = getSpanOfTokenAtPosition(sourceFile, node.pos);
      diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message, arg0, arg1, arg2));
      return true;
    }
    return false;
  }
  function grammarErrorAtPos(nodeForSourceFile: Node, start: number, length: number, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): boolean {
    const sourceFile = qc.get.sourceFileOf(nodeForSourceFile);
    if (!hasParseDiagnostics(sourceFile)) {
      diagnostics.add(createFileDiagnostic(sourceFile, start, length, message, arg0, arg1, arg2));
      return true;
    }
    return false;
  }
  function grammarErrorOnNode(node: Node, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): boolean {
    const sourceFile = qc.get.sourceFileOf(node);
    if (!hasParseDiagnostics(sourceFile)) {
      diagnostics.add(createDiagnosticForNode(node, message, arg0, arg1, arg2));
      return true;
    }
    return false;
  }
  function checkGrammarConstructorTypeParameters(node: ConstructorDeclaration) {
    const jsdocTypeParameters = isInJSFile(node) ? qc.getDoc.typeParameterDeclarations(node) : undefined;
    const range = node.typeParameters || (jsdocTypeParameters && firstOrUndefined(jsdocTypeParameters));
    if (range) {
      const pos = range.pos === range.end ? range.pos : syntax.skipTrivia(qc.get.sourceFileOf(node).text, range.pos);
      return grammarErrorAtPos(node, pos, range.end - pos, qd.Type_parameters_cannot_appear_on_a_constructor_declaration);
    }
  }
  function checkGrammarConstructorTypeAnnotation(node: ConstructorDeclaration) {
    const type = getEffectiveReturnTypeNode(node);
    if (type) return grammarErrorOnNode(type, qd.Type_annotation_cannot_appear_on_a_constructor_declaration);
  }
  function checkGrammarProperty(node: PropertyDeclaration | PropertySignature) {
    if (qc.is.classLike(node.parent)) {
      if (qc.is.kind(StringLiteral, node.name) && node.name.text === 'constructor') return grammarErrorOnNode(node.name, qd.Classes_may_not_have_a_field_named_constructor);
      if (checkGrammarForInvalidDynamicName(node.name, qd.A_computed_property_name_in_a_class_property_declaration_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) {
        return true;
      }
    } else if (node.parent.kind === Syntax.InterfaceDeclaration) {
      if (checkGrammarForInvalidDynamicName(node.name, qd.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) return true;
      if (node.initializer) return grammarErrorOnNode(node.initializer, qd.An_interface_property_cannot_have_an_initializer);
    } else if (node.parent.kind === Syntax.TypeLiteral) {
      if (checkGrammarForInvalidDynamicName(node.name, qd.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) return true;
      if (node.initializer) return grammarErrorOnNode(node.initializer, qd.A_type_literal_property_cannot_have_an_initializer);
    }
    if (node.flags & NodeFlags.Ambient) checkAmbientInitializer(node);
    if (
      qc.is.kind(PropertyDeclaration, node) &&
      node.exclamationToken &&
      (!qc.is.classLike(node.parent) || !node.type || node.initializer || node.flags & NodeFlags.Ambient || hasSyntacticModifier(node, ModifierFlags.Static | ModifierFlags.Abstract))
    ) {
      return grammarErrorOnNode(node.exclamationToken, qd.A_definite_assignment_assertion_is_not_permitted_in_this_context);
    }
  }
  function checkGrammarTopLevelElementForRequiredDeclareModifier(node: Node): boolean {
    if (
      node.kind === Syntax.InterfaceDeclaration ||
      node.kind === Syntax.TypeAliasDeclaration ||
      node.kind === Syntax.ImportDeclaration ||
      node.kind === Syntax.ImportEqualsDeclaration ||
      node.kind === Syntax.ExportDeclaration ||
      node.kind === Syntax.ExportAssignment ||
      node.kind === Syntax.NamespaceExportDeclaration ||
      hasSyntacticModifier(node, ModifierFlags.Ambient | ModifierFlags.Export | ModifierFlags.Default)
    ) {
      return false;
    }
    return grammarErrorOnFirstToken(node, qd.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier);
  }
  function checkGrammarTopLevelElementsForRequiredDeclareModifier(file: SourceFile): boolean {
    for (const decl of file.statements) {
      if (qc.is.declaration(decl) || decl.kind === Syntax.VariableStatement) {
        if (checkGrammarTopLevelElementForRequiredDeclareModifier(decl)) return true;
      }
    }
    return false;
  }
  function checkGrammarSourceFile(node: SourceFile): boolean {
    return !!(node.flags & NodeFlags.Ambient) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node);
  }
  function checkGrammarStatementInAmbientContext(node: Node): boolean {
    if (node.flags & NodeFlags.Ambient) {
      const links = getNodeLinks(node);
      if (!links.hasReportedStatementInAmbientContext && (qc.is.functionLike(node.parent) || qc.is.accessor(node.parent)))
        return (getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, qd.An_implementation_cannot_be_declared_in_ambient_contexts));
      if (node.parent.kind === Syntax.Block || node.parent.kind === Syntax.ModuleBlock || node.parent.kind === Syntax.SourceFile) {
        const links = getNodeLinks(node.parent);
        if (!links.hasReportedStatementInAmbientContext) return (links.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, qd.Statements_are_not_allowed_in_ambient_contexts));
      } else {
      }
    }
    return false;
  }
  function checkGrammarNumericLiteral(node: NumericLiteral): boolean {
    if (node.numericLiteralFlags & TokenFlags.Octal) {
      const diagnosticMessage = qd.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0;
      const withMinus = qc.is.kind(PrefixUnaryExpression, node.parent) && node.parent.operator === Syntax.MinusToken;
      const literal = (withMinus ? '-' : '') + '0o' + node.text;
      return grammarErrorOnNode(withMinus ? node.parent : node, diagnosticMessage, literal);
    }
    checkNumericLiteralValueSize(node);
    return false;
  }
  function checkNumericLiteralValueSize(node: NumericLiteral) {
    if (node.numericLiteralFlags & TokenFlags.Scientific || node.text.length <= 15 || node.text.indexOf('.') !== -1) return;
    const apparentValue = +qc.get.textOf(node);
    if (apparentValue <= 2 ** 53 - 1 && apparentValue + 1 > apparentValue) return;
    addErrorOrSuggestion(false, createDiagnosticForNode(node, qd.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers));
  }
  function checkGrammarBigIntLiteral(node: BigIntLiteral): boolean {
    const literalType = qc.is.kind(LiteralTypeNode, node.parent) || (qc.is.kind(PrefixUnaryExpression, node.parent) && qc.is.kind(LiteralTypeNode, node.parent.parent));
    return false;
  }
  function grammarErrorAfterFirstToken(node: Node, message: DiagnosticMessage, arg0?: any, arg1?: any, arg2?: any): boolean {
    const sourceFile = qc.get.sourceFileOf(node);
    if (!hasParseDiagnostics(sourceFile)) {
      const span = getSpanOfTokenAtPosition(sourceFile, node.pos);
      diagnostics.add(createFileDiagnostic(sourceFile, textSpanEnd(span), 0, message, arg0, arg1, arg2));
      return true;
    }
    return false;
  }
  function getAmbientModules(): Symbol[] {
    if (!ambientModulesCache) {
      ambientModulesCache = [];
      globals.forEach((global, sym) => {
        if (ambientModuleSymbolRegex.test(sym as string)) ambientModulesCache!.push(global);
      });
    }
    return ambientModulesCache;
  }
  function checkGrammarImportClause(node: ImportClause): boolean {
    if (node.isTypeOnly && node.name && node.namedBindings) return grammarErrorOnNode(node, qd.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both);
    return false;
  }
  function checkGrammarImportCallExpression(node: ImportCall): boolean {
    if (moduleKind === ModuleKind.ES2015) return grammarErrorOnNode(node, qd.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_esnext_commonjs_amd_system_or_umd);
    if (node.typeArguments) return grammarErrorOnNode(node, qd.Dynamic_import_cannot_have_type_arguments);
    const nodeArguments = node.arguments;
    if (nodeArguments.length !== 1) return grammarErrorOnNode(node, qd.Dynamic_import_must_have_one_specifier_as_an_argument);
    checkGrammarForDisallowedTrailingComma(nodeArguments);
    if (qc.is.kind(SpreadElement, nodeArguments[0])) return grammarErrorOnNode(nodeArguments[0], qd.Specifier_of_dynamic_import_cannot_be_spread_element);
    return false;
  }
  function findMatchingTypeReferenceOrTypeAliasReference(source: Type, unionTarget: UnionOrIntersectionType) {
    const sourceObjectFlags = getObjectFlags(source);
    if (sourceObjectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous) && unionTarget.flags & TypeFlags.Union) {
      return find(unionTarget.types, (target) => {
        if (target.flags & TypeFlags.Object) {
          const overlapObjFlags = sourceObjectFlags & getObjectFlags(target);
          if (overlapObjFlags & ObjectFlags.Reference) return (source as TypeReference).target === (target as TypeReference).target;
          if (overlapObjFlags & ObjectFlags.Anonymous) return !!(source as AnonymousType).aliasSymbol && (source as AnonymousType).aliasSymbol === (target as AnonymousType).aliasSymbol;
        }
        return false;
      });
    }
  }
  function findBestTypeForObjectLiteral(source: Type, unionTarget: UnionOrIntersectionType) {
    if (getObjectFlags(source) & ObjectFlags.ObjectLiteral && forEachType(unionTarget, isArrayLikeType)) return find(unionTarget.types, (t) => !isArrayLikeType(t));
  }
  function findBestTypeForInvokable(source: Type, unionTarget: UnionOrIntersectionType) {
    let signatureKind = SignatureKind.Call;
    const hasSignatures = getSignaturesOfType(source, signatureKind).length > 0 || ((signatureKind = SignatureKind.Construct), getSignaturesOfType(source, signatureKind).length > 0);
    if (hasSignatures) return find(unionTarget.types, (t) => getSignaturesOfType(t, signatureKind).length > 0);
  }
  function findMostOverlappyType(source: Type, unionTarget: UnionOrIntersectionType) {
    let bestMatch: Type | undefined;
    let matchingCount = 0;
    for (const target of unionTarget.types) {
      const overlap = getIntersectionType([getIndexType(source), getIndexType(target)]);
      if (overlap.flags & TypeFlags.Index) {
        bestMatch = target;
        matchingCount = Infinity;
      } else if (overlap.flags & TypeFlags.Union) {
        const len = length(filter((overlap as UnionType).types, isUnitType));
        if (len >= matchingCount) {
          bestMatch = target;
          matchingCount = len;
        }
      } else if (isUnitType(overlap) && 1 >= matchingCount) {
        bestMatch = target;
        matchingCount = 1;
      }
    }
    return bestMatch;
  }
  function filterPrimitivesIfContainsNonPrimitive(type: UnionType) {
    if (maybeTypeOfKind(type, TypeFlags.NonPrimitive)) {
      const result = filterType(type, (t) => !(t.flags & TypeFlags.Primitive));
      if (!(result.flags & TypeFlags.Never)) return result;
    }
    return type;
  }
  function findMatchingDiscriminantType(source: Type, target: Type, isRelatedTo: (source: Type, target: Type) => Ternary, skipPartial?: boolean) {
    if (target.flags & TypeFlags.Union && source.flags & (TypeFlags.Intersection | TypeFlags.Object)) {
      const sourceProperties = getPropertiesOfType(source);
      if (sourceProperties) {
        const sourcePropertiesFiltered = findDiscriminantProperties(sourceProperties, target);
        if (sourcePropertiesFiltered) {
          return discriminateTypeByDiscriminableItems(
            <UnionType>target,
            map(sourcePropertiesFiltered, (p) => [() => getTypeOfSymbol(p), p.escName] as [() => Type, __String]),
            isRelatedTo,
            undefined,
            skipPartial
          );
        }
      }
    }
    return;
  }
}
namespace JsxNames {
  export const JSX = 'JSX' as __String;
  export const IntrinsicElements = 'IntrinsicElements' as __String;
  export const ElementClass = 'ElementClass' as __String;
  export const ElementAttributesPropertyNameContainer = 'ElementAttributesProperty' as __String;
  export const ElementChildrenAttributeNameContainer = 'ElementChildrenAttribute' as __String;
  export const Element = 'Element' as __String;
  export const IntrinsicAttributes = 'IntrinsicAttributes' as __String;
  export const IntrinsicClassAttributes = 'IntrinsicClassAttributes' as __String;
  export const LibraryManagedAttributes = 'LibraryManagedAttributes' as __String;
}
function getIterationTypesKeyFromIterationTypeKind(typeKind: IterationTypeKind) {
  switch (typeKind) {
    case IterationTypeKind.Yield:
      return 'yieldType';
    case IterationTypeKind.Return:
      return 'returnType';
    case IterationTypeKind.Next:
      return 'nextType';
  }
}
